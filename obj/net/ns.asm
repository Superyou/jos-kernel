
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 a8 ef 00 00       	call   80efd9 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
  800033:	66 90                	xchg   %ax,%ax
  800035:	66 90                	xchg   %ax,%ax
  800037:	66 90                	xchg   %ax,%ax
  800039:	66 90                	xchg   %ax,%ax
  80003b:	66 90                	xchg   %ax,%ax
  80003d:	66 90                	xchg   %ax,%ax
  80003f:	90                   	nop

00800040 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
  800043:	83 ec 18             	sub    $0x18,%esp
  800046:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800049:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  80004f:	89 04 24             	mov    %eax,(%esp)
  800052:	e8 28 ae 00 00       	call   80ae7f <thread_wakeup>
}
  800057:	c9                   	leave  
  800058:	c3                   	ret    

00800059 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800059:	55                   	push   %ebp
  80005a:	89 e5                	mov    %esp,%ebp
  80005c:	53                   	push   %ebx
  80005d:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  800060:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800063:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800065:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800068:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80006b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80006f:	c7 44 24 08 b9 00 80 	movl   $0x8000b9,0x8(%esp)
  800076:	00 
  800077:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80007b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800082:	e8 66 ae 00 00       	call   80aeed <thread_create>
	if (r < 0)
  800087:	85 c0                	test   %eax,%eax
  800089:	79 28                	jns    8000b3 <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  80008b:	89 04 24             	mov    %eax,(%esp)
  80008e:	e8 bd b1 00 00       	call   80b250 <e2s>
  800093:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800097:	c7 44 24 08 60 1f 81 	movl   $0x811f60,0x8(%esp)
  80009e:	00 
  80009f:	c7 44 24 04 83 00 00 	movl   $0x83,0x4(%esp)
  8000a6:	00 
  8000a7:	c7 04 24 95 20 81 00 	movl   $0x812095,(%esp)
  8000ae:	e8 87 ef 00 00       	call   80f03a <_panic>
}
  8000b3:	83 c4 14             	add    $0x14,%esp
  8000b6:	5b                   	pop    %ebx
  8000b7:	5d                   	pop    %ebp
  8000b8:	c3                   	ret    

008000b9 <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8000b9:	55                   	push   %ebp
  8000ba:	89 e5                	mov    %esp,%ebp
  8000bc:	56                   	push   %esi
  8000bd:	53                   	push   %ebx
  8000be:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8000c1:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  8000c4:	e8 d4 fd 00 00       	call   80fe9d <sys_time_msec>
  8000c9:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  8000cb:	e8 67 ad 00 00       	call   80ae37 <lwip_core_lock>
		t->func();
  8000d0:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  8000d3:	e8 64 ad 00 00       	call   80ae3c <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8000d8:	03 33                	add    (%ebx),%esi
  8000da:	89 74 24 08          	mov    %esi,0x8(%esp)
  8000de:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8000e5:	00 
  8000e6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8000ed:	e8 c7 af 00 00       	call   80b0b9 <thread_wait>
  8000f2:	eb d0                	jmp    8000c4 <net_timer+0xb>

008000f4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000f4:	55                   	push   %ebp
  8000f5:	89 e5                	mov    %esp,%ebp
  8000f7:	57                   	push   %edi
  8000f8:	56                   	push   %esi
  8000f9:	53                   	push   %ebx
  8000fa:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
  800100:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  800103:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  800106:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800109:	0f 87 3a 01 00 00    	ja     800249 <serve_thread+0x155>
  80010f:	8b 03                	mov    (%ebx),%eax
  800111:	ff 24 85 40 21 81 00 	jmp    *0x812140(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  800118:	8b 46 04             	mov    0x4(%esi),%eax
  80011b:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80011e:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800121:	89 44 24 08          	mov    %eax,0x8(%esp)
  800125:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800128:	89 44 24 04          	mov    %eax,0x4(%esp)
  80012c:	8b 06                	mov    (%esi),%eax
  80012e:	89 04 24             	mov    %eax,(%esp)
  800131:	e8 0c 0f 00 00       	call   801042 <lwip_accept>
  800136:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  800138:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80013f:	00 
  800140:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800143:	89 44 24 04          	mov    %eax,0x4(%esp)
  800147:	89 34 24             	mov    %esi,(%esp)
  80014a:	e8 f5 f7 00 00       	call   80f944 <memmove>
  80014f:	e9 13 01 00 00       	jmp    800267 <serve_thread+0x173>
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800154:	8b 46 14             	mov    0x14(%esi),%eax
  800157:	89 44 24 08          	mov    %eax,0x8(%esp)
  80015b:	8d 46 04             	lea    0x4(%esi),%eax
  80015e:	89 44 24 04          	mov    %eax,0x4(%esp)
  800162:	8b 06                	mov    (%esi),%eax
  800164:	89 04 24             	mov    %eax,(%esp)
  800167:	e8 9c 10 00 00       	call   801208 <lwip_bind>
  80016c:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  80016e:	e9 f4 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800173:	8b 46 04             	mov    0x4(%esi),%eax
  800176:	89 44 24 04          	mov    %eax,0x4(%esp)
  80017a:	8b 06                	mov    (%esi),%eax
  80017c:	89 04 24             	mov    %eax,(%esp)
  80017f:	e8 7c 1c 00 00       	call   801e00 <lwip_shutdown>
  800184:	89 c7                	mov    %eax,%edi
		break;
  800186:	e9 dc 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  80018b:	8b 06                	mov    (%esi),%eax
  80018d:	89 04 24             	mov    %eax,(%esp)
  800190:	e8 30 11 00 00       	call   8012c5 <lwip_close>
  800195:	89 c7                	mov    %eax,%edi
		break;
  800197:	e9 cb 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80019c:	8b 46 14             	mov    0x14(%esi),%eax
  80019f:	89 44 24 08          	mov    %eax,0x8(%esp)
  8001a3:	8d 46 04             	lea    0x4(%esi),%eax
  8001a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8001aa:	8b 06                	mov    (%esi),%eax
  8001ac:	89 04 24             	mov    %eax,(%esp)
  8001af:	e8 8f 11 00 00       	call   801343 <lwip_connect>
  8001b4:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  8001b6:	e9 ac 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001bb:	8b 46 04             	mov    0x4(%esi),%eax
  8001be:	89 44 24 04          	mov    %eax,0x4(%esp)
  8001c2:	8b 06                	mov    (%esi),%eax
  8001c4:	89 04 24             	mov    %eax,(%esp)
  8001c7:	e8 34 12 00 00       	call   801400 <lwip_listen>
  8001cc:	89 c7                	mov    %eax,%edi
		break;
  8001ce:	e9 94 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001d3:	8b 46 08             	mov    0x8(%esi),%eax
  8001d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8001da:	8b 46 04             	mov    0x4(%esi),%eax
  8001dd:	89 44 24 08          	mov    %eax,0x8(%esp)
  8001e1:	89 74 24 04          	mov    %esi,0x4(%esp)
  8001e5:	8b 06                	mov    (%esi),%eax
  8001e7:	89 04 24             	mov    %eax,(%esp)
  8001ea:	e8 16 15 00 00       	call   801705 <lwip_recv>
  8001ef:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  8001f1:	eb 74                	jmp    800267 <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001f3:	8b 46 08             	mov    0x8(%esi),%eax
  8001f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8001fa:	8b 46 04             	mov    0x4(%esi),%eax
  8001fd:	89 44 24 08          	mov    %eax,0x8(%esp)
  800201:	8d 46 0c             	lea    0xc(%esi),%eax
  800204:	89 44 24 04          	mov    %eax,0x4(%esp)
  800208:	8b 06                	mov    (%esi),%eax
  80020a:	89 04 24             	mov    %eax,(%esp)
  80020d:	e8 8b 16 00 00       	call   80189d <lwip_send>
  800212:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800214:	eb 51                	jmp    800267 <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800216:	8b 46 08             	mov    0x8(%esi),%eax
  800219:	89 44 24 08          	mov    %eax,0x8(%esp)
  80021d:	8b 46 04             	mov    0x4(%esi),%eax
  800220:	89 44 24 04          	mov    %eax,0x4(%esp)
  800224:	8b 06                	mov    (%esi),%eax
  800226:	89 04 24             	mov    %eax,(%esp)
  800229:	e8 22 17 00 00       	call   801950 <lwip_socket>
  80022e:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800230:	eb 35                	jmp    800267 <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800232:	89 74 24 04          	mov    %esi,0x4(%esp)
  800236:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  80023d:	e8 44 b1 00 00       	call   80b386 <jif_input>
		r = 0;
  800242:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  800247:	eb 4c                	jmp    800295 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800249:	89 74 24 08          	mov    %esi,0x8(%esp)
  80024d:	8b 43 04             	mov    0x4(%ebx),%eax
  800250:	89 44 24 04          	mov    %eax,0x4(%esp)
  800254:	c7 04 24 80 1f 81 00 	movl   $0x811f80,(%esp)
  80025b:	e8 d3 ee 00 00       	call   80f133 <cprintf>
		r = -E_INVAL;
  800260:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  800265:	eb 2e                	jmp    800295 <serve_thread+0x1a1>
	}

	if (r == -1) {
  800267:	83 ff ff             	cmp    $0xffffffff,%edi
  80026a:	75 29                	jne    800295 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  80026c:	8b 03                	mov    (%ebx),%eax
  80026e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800272:	c7 44 24 08 a0 20 81 	movl   $0x8120a0,0x8(%esp)
  800279:	00 
  80027a:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  800281:	00 
  800282:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800285:	89 34 24             	mov    %esi,(%esp)
  800288:	e8 b8 f4 00 00       	call   80f745 <snprintf>
		perror(buf);
  80028d:	89 34 24             	mov    %esi,(%esp)
  800290:	e8 90 af 00 00       	call   80b225 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  800295:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800298:	74 1f                	je     8002b9 <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  80029a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8002a1:	00 
  8002a2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8002a9:	00 
  8002aa:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8002ae:	8b 43 04             	mov    0x4(%ebx),%eax
  8002b1:	89 04 24             	mov    %eax,(%esp)
  8002b4:	e8 7f 02 01 00       	call   810538 <ipc_send>

	put_buffer(args->req);
  8002b9:	8b 43 08             	mov    0x8(%ebx),%eax
So marks buse[i] = 0 i.e it is empty/ready to accept new request*/


static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8002bc:	8d 90 00 50 01 f0    	lea    -0xffeb000(%eax),%edx
  8002c2:	c1 ea 0c             	shr    $0xc,%edx
	buse[i] = 0;
  8002c5:	c6 82 00 60 81 00 00 	movb   $0x0,0x816000(%edx)

	if (args->reqno != NSREQ_INPUT)
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
	sys_page_unmap(0, (void*) args->req);
  8002cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8002d0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002d7:	e8 e0 f9 00 00       	call   80fcbc <sys_page_unmap>
	free(args);
  8002dc:	89 1c 24             	mov    %ebx,(%esp)
  8002df:	e8 2c 11 01 00       	call   811410 <free>
}
  8002e4:	81 c4 8c 00 00 00    	add    $0x8c,%esp
  8002ea:	5b                   	pop    %ebx
  8002eb:	5e                   	pop    %esi
  8002ec:	5f                   	pop    %edi
  8002ed:	5d                   	pop    %ebp
  8002ee:	c3                   	ret    

008002ef <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  8002ef:	55                   	push   %ebp
  8002f0:	89 e5                	mov    %esp,%ebp
  8002f2:	56                   	push   %esi
  8002f3:	53                   	push   %ebx
  8002f4:	83 ec 30             	sub    $0x30,%esp
  8002f7:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  8002fa:	e8 38 ab 00 00       	call   80ae37 <lwip_core_lock>

	uint32_t done = 0;
  8002ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800306:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800309:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80030d:	c7 04 24 40 00 80 00 	movl   $0x800040,(%esp)
  800314:	e8 47 24 00 00       	call   802760 <tcpip_init>
	lwip_core_unlock();
  800319:	e8 1e ab 00 00       	call   80ae3c <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  80031e:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  800325:	ff 
  800326:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80032d:	00 
  80032e:	89 1c 24             	mov    %ebx,(%esp)
  800331:	e8 83 ad 00 00       	call   80b0b9 <thread_wait>
	lwip_core_lock();
  800336:	e8 fc aa 00 00       	call   80ae37 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  80033b:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  80033e:	8b 45 0c             	mov    0xc(%ebp),%eax
  800341:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  800344:	8b 45 10             	mov    0x10(%ebp),%eax
  800347:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  80034a:	c7 44 24 18 20 6b 80 	movl   $0x806b20,0x18(%esp)
  800351:	00 
  800352:	c7 44 24 14 8e b4 80 	movl   $0x80b48e,0x14(%esp)
  800359:	00 
  80035a:	c7 44 24 10 14 60 81 	movl   $0x816014,0x10(%esp)
  800361:	00 
  800362:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800365:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800369:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80036c:	89 44 24 08          	mov    %eax,0x8(%esp)
  800370:	8d 45 e8             	lea    -0x18(%ebp),%eax
  800373:	89 44 24 04          	mov    %eax,0x4(%esp)
  800377:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  80037e:	e8 3e 48 00 00       	call   804bc1 <netif_add>
  800383:	85 c0                	test   %eax,%eax
  800385:	75 1c                	jne    8003a3 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  800387:	c7 44 24 08 a4 1f 81 	movl   $0x811fa4,0x8(%esp)
  80038e:	00 
  80038f:	c7 44 24 04 65 00 00 	movl   $0x65,0x4(%esp)
  800396:	00 
  800397:	c7 04 24 95 20 81 00 	movl   $0x812095,(%esp)
  80039e:	e8 97 ec 00 00       	call   80f03a <_panic>

	netif_set_default(nif);
  8003a3:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  8003aa:	e8 d4 48 00 00       	call   804c83 <netif_set_default>
	netif_set_up(nif);
  8003af:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  8003b6:	e8 d5 48 00 00       	call   804c90 <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  8003bb:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8003c2:	b9 af 20 81 00       	mov    $0x8120af,%ecx
  8003c7:	ba b0 9c 80 00       	mov    $0x809cb0,%edx
  8003cc:	b8 38 60 81 00       	mov    $0x816038,%eax
  8003d1:	e8 83 fc ff ff       	call   800059 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  8003d6:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8003dd:	b9 b9 20 81 00       	mov    $0x8120b9,%ecx
  8003e2:	ba 2f 5d 80 00       	mov    $0x805d2f,%edx
  8003e7:	b8 2c 60 81 00       	mov    $0x81602c,%eax
  8003ec:	e8 68 fc ff ff       	call   800059 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  8003f1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8003f8:	b9 c5 20 81 00       	mov    $0x8120c5,%ecx
  8003fd:	ba cd 62 80 00       	mov    $0x8062cd,%edx
  800402:	b8 20 60 81 00       	mov    $0x816020,%eax
  800407:	e8 4d fc ff ff       	call   800059 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80040c:	89 34 24             	mov    %esi,(%esp)
  80040f:	e8 7c 78 00 00       	call   807c90 <inet_ntoa>
  800414:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  800418:	0f b6 05 4a c2 b3 00 	movzbl 0xb3c24a,%eax
  80041f:	89 44 24 18          	mov    %eax,0x18(%esp)
  800423:	0f b6 05 49 c2 b3 00 	movzbl 0xb3c249,%eax
  80042a:	89 44 24 14          	mov    %eax,0x14(%esp)
  80042e:	0f b6 05 48 c2 b3 00 	movzbl 0xb3c248,%eax
  800435:	89 44 24 10          	mov    %eax,0x10(%esp)
  800439:	0f b6 05 47 c2 b3 00 	movzbl 0xb3c247,%eax
  800440:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800444:	0f b6 05 46 c2 b3 00 	movzbl 0xb3c246,%eax
  80044b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80044f:	0f b6 05 45 c2 b3 00 	movzbl 0xb3c245,%eax
  800456:	89 44 24 04          	mov    %eax,0x4(%esp)
  80045a:	c7 04 24 c4 1f 81 00 	movl   $0x811fc4,(%esp)
  800461:	e8 cd ec 00 00       	call   80f133 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  800466:	e8 d1 a9 00 00       	call   80ae3c <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  80046b:	c7 04 24 d1 20 81 00 	movl   $0x8120d1,(%esp)
  800472:	e8 bc ec 00 00       	call   80f133 <cprintf>
}
  800477:	83 c4 30             	add    $0x30,%esp
  80047a:	5b                   	pop    %ebx
  80047b:	5e                   	pop    %esi
  80047c:	5d                   	pop    %ebp
  80047d:	c3                   	ret    

0080047e <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80047e:	55                   	push   %ebp
  80047f:	89 e5                	mov    %esp,%ebp
  800481:	57                   	push   %edi
  800482:	56                   	push   %esi
  800483:	53                   	push   %ebx
  800484:	83 ec 3c             	sub    $0x3c,%esp

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800487:	bb 00 00 00 00       	mov    $0x0,%ebx
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80048c:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80048f:	eb 08                	jmp    800499 <serve+0x1b>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  800491:	e8 a3 ab 00 00       	call   80b039 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800496:	83 c3 01             	add    $0x1,%ebx
  800499:	e8 00 aa 00 00       	call   80ae9e <thread_wakeups_pending>
  80049e:	85 c0                	test   %eax,%eax
  8004a0:	74 05                	je     8004a7 <serve+0x29>
  8004a2:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a5:	7e ea                	jle    800491 <serve+0x13>
			thread_yield();

		perm = 0;
  8004a7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004ae:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8004b3:	80 b8 00 60 81 00 00 	cmpb   $0x0,0x816000(%eax)
  8004ba:	74 0a                	je     8004c6 <serve+0x48>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004bc:	83 c0 01             	add    $0x1,%eax
  8004bf:	83 f8 14             	cmp    $0x14,%eax
  8004c2:	75 ef                	jne    8004b3 <serve+0x35>
  8004c4:	eb 05                	jmp    8004cb <serve+0x4d>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8004c6:	83 f8 14             	cmp    $0x14,%eax
  8004c9:	75 1c                	jne    8004e7 <serve+0x69>
		panic("NS: buffer overflow");
  8004cb:	c7 44 24 08 ea 20 81 	movl   $0x8120ea,0x8(%esp)
  8004d2:	00 
  8004d3:	c7 44 24 04 43 00 00 	movl   $0x43,0x4(%esp)
  8004da:	00 
  8004db:	c7 04 24 95 20 81 00 	movl   $0x812095,(%esp)
  8004e2:	e8 53 eb 00 00       	call   80f03a <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8004e7:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8004ed:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8004f0:	c6 80 00 60 81 00 01 	movb   $0x1,0x816000(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8004f7:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8004fb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8004ff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800502:	89 04 24             	mov    %eax,(%esp)
  800505:	e8 c6 ff 00 00       	call   8104d0 <ipc_recv>
  80050a:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  80050c:	83 f8 0c             	cmp    $0xc,%eax
  80050f:	75 70                	jne    800581 <serve+0x103>
			process_timer(whom);
  800511:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800514:	3b 35 1c 60 81 00    	cmp    0x81601c,%esi
  80051a:	74 12                	je     80052e <serve+0xb0>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80051c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800520:	c7 04 24 00 20 81 00 	movl   $0x812000,(%esp)
  800527:	e8 07 ec 00 00       	call   80f133 <cprintf>
  80052c:	eb 39                	jmp    800567 <serve+0xe9>
		return;
	}

	start = sys_time_msec();
  80052e:	e8 6a f9 00 00       	call   80fe9d <sys_time_msec>
  800533:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800536:	e8 fe aa 00 00       	call   80b039 <thread_yield>
	now = sys_time_msec();
  80053b:	e8 5d f9 00 00       	call   80fe9d <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  800540:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800547:	00 
  800548:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80054f:	00 

	start = sys_time_msec();
	thread_yield();
	now = sys_time_msec();

	to = TIMER_INTERVAL - (now - start);
  800550:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800553:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800559:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  80055b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80055f:	89 34 24             	mov    %esi,(%esp)
  800562:	e8 d1 ff 00 00       	call   810538 <ipc_send>
So marks buse[i] = 0 i.e it is empty/ready to accept new request*/


static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800567:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  80056d:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  800570:	c6 83 00 60 81 00 00 	movb   $0x0,0x816000(%ebx)

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800577:	bb 00 00 00 00       	mov    $0x0,%ebx

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  80057c:	e9 18 ff ff ff       	jmp    800499 <serve+0x1b>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800581:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800585:	75 1d                	jne    8005a4 <serve+0x126>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800587:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80058a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80058e:	c7 04 24 3c 20 81 00 	movl   $0x81203c,(%esp)
  800595:	e8 99 eb 00 00       	call   80f133 <cprintf>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80059a:	bb 00 00 00 00       	mov    $0x0,%ebx
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
			cprintf("Invalid request from %08x: no argument page\n", whom);
			continue; // just leave it hanging...
  80059f:	e9 f5 fe ff ff       	jmp    800499 <serve+0x1b>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  8005a4:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8005ab:	e8 32 0f 01 00       	call   8114e2 <malloc>
		if (!args)
  8005b0:	85 c0                	test   %eax,%eax
  8005b2:	75 1c                	jne    8005d0 <serve+0x152>
			panic("could not allocate thread args structure");
  8005b4:	c7 44 24 08 6c 20 81 	movl   $0x81206c,0x8(%esp)
  8005bb:	00 
  8005bc:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  8005c3:	00 
  8005c4:	c7 04 24 95 20 81 00 	movl   $0x812095,(%esp)
  8005cb:	e8 6a ea 00 00       	call   80f03a <_panic>

		args->reqno = reqno;
  8005d0:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8005d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8005d5:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8005d8:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8005db:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005df:	c7 44 24 08 f4 00 80 	movl   $0x8000f4,0x8(%esp)
  8005e6:	00 
  8005e7:	c7 44 24 04 fe 20 81 	movl   $0x8120fe,0x4(%esp)
  8005ee:	00 
  8005ef:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8005f6:	e8 f2 a8 00 00       	call   80aeed <thread_create>
		thread_yield(); // let the thread created run
  8005fb:	e8 39 aa 00 00       	call   80b039 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800600:	bb 00 00 00 00       	mov    $0x0,%ebx
  800605:	e9 8f fe ff ff       	jmp    800499 <serve+0x1b>

0080060a <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  80060a:	55                   	push   %ebp
  80060b:	89 e5                	mov    %esp,%ebp
  80060d:	56                   	push   %esi
  80060e:	53                   	push   %ebx
  80060f:	83 ec 10             	sub    $0x10,%esp
	serve_init(inet_addr(IP),
  800612:	c7 04 24 0b 21 81 00 	movl   $0x81210b,(%esp)
  800619:	e8 57 79 00 00       	call   807f75 <inet_addr>
  80061e:	89 c6                	mov    %eax,%esi
  800620:	c7 04 24 14 21 81 00 	movl   $0x812114,(%esp)
  800627:	e8 49 79 00 00       	call   807f75 <inet_addr>
  80062c:	89 c3                	mov    %eax,%ebx
  80062e:	c7 04 24 22 21 81 00 	movl   $0x812122,(%esp)
  800635:	e8 3b 79 00 00       	call   807f75 <inet_addr>
  80063a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80063e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800642:	89 04 24             	mov    %eax,(%esp)
  800645:	e8 a5 fc ff ff       	call   8002ef <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  80064a:	e8 2f fe ff ff       	call   80047e <serve>

0080064f <umain>:
}

void
umain(int argc, char **argv)
{
  80064f:	55                   	push   %ebp
  800650:	89 e5                	mov    %esp,%ebp
  800652:	53                   	push   %ebx
  800653:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  800656:	e8 7c f5 00 00       	call   80fbd7 <sys_getenvid>
  80065b:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  80065d:	c7 05 e8 52 81 00 fd 	movl   $0x814afd,0x8152e8
  800664:	4a 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800667:	e8 c3 fa 00 00       	call   81012f <fork>
  80066c:	a3 1c 60 81 00       	mov    %eax,0x81601c
	if (timer_envid < 0)
  800671:	85 c0                	test   %eax,%eax
  800673:	79 1c                	jns    800691 <umain+0x42>
		panic("error forking");
  800675:	c7 44 24 08 2c 21 81 	movl   $0x81212c,0x8(%esp)
  80067c:	00 
  80067d:	c7 44 24 04 4d 01 00 	movl   $0x14d,0x4(%esp)
  800684:	00 
  800685:	c7 04 24 95 20 81 00 	movl   $0x812095,(%esp)
  80068c:	e8 a9 e9 00 00       	call   80f03a <_panic>
	else if (timer_envid == 0) {
  800691:	85 c0                	test   %eax,%eax
  800693:	75 15                	jne    8006aa <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  800695:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80069c:	00 
  80069d:	89 1c 24             	mov    %ebx,(%esp)
  8006a0:	e8 ab 00 00 00       	call   800750 <timer>
		return;
  8006a5:	e9 9e 00 00 00       	jmp    800748 <umain+0xf9>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8006aa:	e8 80 fa 00 00       	call   81012f <fork>
  8006af:	a3 18 60 81 00       	mov    %eax,0x816018
	if (input_envid < 0)
  8006b4:	85 c0                	test   %eax,%eax
  8006b6:	79 1c                	jns    8006d4 <umain+0x85>
		panic("error forking");
  8006b8:	c7 44 24 08 2c 21 81 	movl   $0x81212c,0x8(%esp)
  8006bf:	00 
  8006c0:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
  8006c7:	00 
  8006c8:	c7 04 24 95 20 81 00 	movl   $0x812095,(%esp)
  8006cf:	e8 66 e9 00 00       	call   80f03a <_panic>
	else if (input_envid == 0) {
  8006d4:	85 c0                	test   %eax,%eax
  8006d6:	75 0a                	jne    8006e2 <umain+0x93>
		input(ns_envid);
  8006d8:	89 1c 24             	mov    %ebx,(%esp)
  8006db:	e8 35 01 00 00       	call   800815 <input>
		return;
  8006e0:	eb 66                	jmp    800748 <umain+0xf9>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8006e2:	e8 48 fa 00 00       	call   81012f <fork>
  8006e7:	a3 14 60 81 00       	mov    %eax,0x816014
	if (output_envid < 0)
  8006ec:	85 c0                	test   %eax,%eax
  8006ee:	79 1c                	jns    80070c <umain+0xbd>
		panic("error forking");
  8006f0:	c7 44 24 08 2c 21 81 	movl   $0x81212c,0x8(%esp)
  8006f7:	00 
  8006f8:	c7 44 24 04 61 01 00 	movl   $0x161,0x4(%esp)
  8006ff:	00 
  800700:	c7 04 24 95 20 81 00 	movl   $0x812095,(%esp)
  800707:	e8 2e e9 00 00       	call   80f03a <_panic>
	else if (output_envid == 0) {
  80070c:	85 c0                	test   %eax,%eax
  80070e:	75 0a                	jne    80071a <umain+0xcb>
		output(ns_envid);
  800710:	89 1c 24             	mov    %ebx,(%esp)
  800713:	e8 78 01 00 00       	call   800890 <output>
		return;
  800718:	eb 2e                	jmp    800748 <umain+0xf9>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  80071a:	e8 31 a7 00 00       	call   80ae50 <thread_init>
	thread_create(0, "main", tmain, 0);
  80071f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800726:	00 
  800727:	c7 44 24 08 0a 06 80 	movl   $0x80060a,0x8(%esp)
  80072e:	00 
  80072f:	c7 44 24 04 3a 21 81 	movl   $0x81213a,0x4(%esp)
  800736:	00 
  800737:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80073e:	e8 aa a7 00 00       	call   80aeed <thread_create>
	thread_yield();
  800743:	e8 f1 a8 00 00       	call   80b039 <thread_yield>
	// never coming here!
}
  800748:	83 c4 14             	add    $0x14,%esp
  80074b:	5b                   	pop    %ebx
  80074c:	5d                   	pop    %ebp
  80074d:	c3                   	ret    
  80074e:	66 90                	xchg   %ax,%ax

00800750 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800750:	55                   	push   %ebp
  800751:	89 e5                	mov    %esp,%ebp
  800753:	57                   	push   %edi
  800754:	56                   	push   %esi
  800755:	53                   	push   %ebx
  800756:	83 ec 2c             	sub    $0x2c,%esp
  800759:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80075c:	e8 3c f7 00 00       	call   80fe9d <sys_time_msec>
  800761:	03 45 0c             	add    0xc(%ebp),%eax
  800764:	89 c6                	mov    %eax,%esi

	binaryname = "ns_timer";
  800766:	c7 05 e8 52 81 00 6c 	movl   $0x81216c,0x8152e8
  80076d:	21 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800770:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800773:	eb 05                	jmp    80077a <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800775:	e8 7c f4 00 00       	call   80fbf6 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  80077a:	e8 1e f7 00 00       	call   80fe9d <sys_time_msec>
  80077f:	39 c6                	cmp    %eax,%esi
  800781:	76 06                	jbe    800789 <timer+0x39>
  800783:	85 c0                	test   %eax,%eax
  800785:	79 ee                	jns    800775 <timer+0x25>
  800787:	eb 09                	jmp    800792 <timer+0x42>
			sys_yield();
		}
		if (r < 0)
  800789:	85 c0                	test   %eax,%eax
  80078b:	90                   	nop
  80078c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800790:	79 20                	jns    8007b2 <timer+0x62>
			panic("sys_time_msec: %e", r);
  800792:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800796:	c7 44 24 08 75 21 81 	movl   $0x812175,0x8(%esp)
  80079d:	00 
  80079e:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  8007a5:	00 
  8007a6:	c7 04 24 87 21 81 00 	movl   $0x812187,(%esp)
  8007ad:	e8 88 e8 00 00       	call   80f03a <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007b2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007b9:	00 
  8007ba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007c1:	00 
  8007c2:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007c9:	00 
  8007ca:	89 1c 24             	mov    %ebx,(%esp)
  8007cd:	e8 66 fd 00 00       	call   810538 <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007d2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007d9:	00 
  8007da:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8007e1:	00 
  8007e2:	89 3c 24             	mov    %edi,(%esp)
  8007e5:	e8 e6 fc 00 00       	call   8104d0 <ipc_recv>
  8007ea:	89 c6                	mov    %eax,%esi

			if (whom != ns_envid) {
  8007ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8007ef:	39 c3                	cmp    %eax,%ebx
  8007f1:	74 12                	je     800805 <timer+0xb5>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8007f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8007f7:	c7 04 24 94 21 81 00 	movl   $0x812194,(%esp)
  8007fe:	e8 30 e9 00 00       	call   80f133 <cprintf>
  800803:	eb cd                	jmp    8007d2 <timer+0x82>
				continue;
			}

			stop = sys_time_msec() + to;
  800805:	e8 93 f6 00 00       	call   80fe9d <sys_time_msec>
  80080a:	01 c6                	add    %eax,%esi
  80080c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800810:	e9 65 ff ff ff       	jmp    80077a <timer+0x2a>

00800815 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800815:	55                   	push   %ebp
  800816:	89 e5                	mov    %esp,%ebp
  800818:	53                   	push   %ebx
  800819:	83 ec 14             	sub    $0x14,%esp
  80081c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int ret;
	binaryname = "ns_input";
  80081f:	c7 05 e8 52 81 00 cf 	movl   $0x8121cf,0x8152e8
  800826:	21 81 00 
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
	while(1)
	{
		sys_page_alloc(0, &nsipcbuf, PTE_W|PTE_U|PTE_P);
  800829:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  800830:	00 
  800831:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  800838:	00 
  800839:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800840:	e8 d0 f3 00 00       	call   80fc15 <sys_page_alloc>

		while((ret = sys_rx_packet(&nsipcbuf.pkt.jp_data, &nsipcbuf.pkt.jp_len)) < 0)
  800845:	eb 05                	jmp    80084c <input+0x37>
			sys_yield();
  800847:	e8 aa f3 00 00       	call   80fbf6 <sys_yield>
	// another packet in to the same physical page.
	while(1)
	{
		sys_page_alloc(0, &nsipcbuf, PTE_W|PTE_U|PTE_P);

		while((ret = sys_rx_packet(&nsipcbuf.pkt.jp_data, &nsipcbuf.pkt.jp_len)) < 0)
  80084c:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  800853:	00 
  800854:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  80085b:	e8 7d f6 00 00       	call   80fedd <sys_rx_packet>
  800860:	85 c0                	test   %eax,%eax
  800862:	78 e3                	js     800847 <input+0x32>
			sys_yield();


		//cprintf("\ndata:%s",nsipcbuf.pkt.jp_data);
		while((sys_ipc_try_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P|PTE_W|PTE_U)) < 0);	
  800864:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80086b:	00 
  80086c:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  800873:	00 
  800874:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  80087b:	00 
  80087c:	89 1c 24             	mov    %ebx,(%esp)
  80087f:	e8 a4 f5 00 00       	call   80fe28 <sys_ipc_try_send>
  800884:	85 c0                	test   %eax,%eax
  800886:	78 dc                	js     800864 <input+0x4f>
  800888:	eb 9f                	jmp    800829 <input+0x14>
  80088a:	66 90                	xchg   %ax,%ax
  80088c:	66 90                	xchg   %ax,%ax
  80088e:	66 90                	xchg   %ax,%ax

00800890 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800890:	55                   	push   %ebp
  800891:	89 e5                	mov    %esp,%ebp
  800893:	57                   	push   %edi
  800894:	56                   	push   %esi
  800895:	53                   	push   %ebx
  800896:	83 ec 2c             	sub    $0x2c,%esp
  800899:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int32_t reqno;
	uint32_t whom;
	int i, perm;
	void *va;
	int ret;
	binaryname = "ns_output";
  80089c:	c7 05 e8 52 81 00 d8 	movl   $0x8121d8,0x8152e8
  8008a3:	21 81 00 
	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
	while(1)
	{
		reqno = ipc_recv((int32_t *) &whom, (void *)&nsipcbuf, &perm);
  8008a6:	8d 7d e0             	lea    -0x20(%ebp),%edi
  8008a9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8008ad:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  8008b4:	00 
  8008b5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8008b8:	89 04 24             	mov    %eax,(%esp)
  8008bb:	e8 10 fc 00 00       	call   8104d0 <ipc_recv>
  8008c0:	89 c6                	mov    %eax,%esi
		while(1)
		{

			if((reqno == NSREQ_OUTPUT) && (whom == ns_envid))
  8008c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8008c5:	83 fe 0b             	cmp    $0xb,%esi
  8008c8:	75 49                	jne    800913 <output+0x83>
  8008ca:	39 c3                	cmp    %eax,%ebx
  8008cc:	75 fc                	jne    8008ca <output+0x3a>
			{
				//cprintf("\nreceived packet from ns server\n");
				//cprintf("\nlength of packet:%d\n",nsipcbuf.pkt.jp_len);
				//cprintf("\ndata:");
				ret = sys_tx_packet(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len);
  8008ce:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
  8008d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8008d7:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  8008de:	e8 d9 f5 00 00       	call   80febc <sys_tx_packet>
				if(ret == E_TX_DESC_SUCCESS)
  8008e3:	83 f8 10             	cmp    $0x10,%eax
  8008e6:	74 c1                	je     8008a9 <output+0x19>
					break;
				else if(ret == -E_TX_DESC_FAILURE)
  8008e8:	83 f8 ef             	cmp    $0xffffffef,%eax
  8008eb:	75 0a                	jne    8008f7 <output+0x67>
				{
					sys_yield();
  8008ed:	8d 76 00             	lea    0x0(%esi),%esi
  8008f0:	e8 01 f3 00 00       	call   80fbf6 <sys_yield>
  8008f5:	eb cb                	jmp    8008c2 <output+0x32>
				}
				else
					panic("\nError while sending transmittong packet\n");	
  8008f7:	c7 44 24 08 f0 21 81 	movl   $0x8121f0,0x8(%esp)
  8008fe:	00 
  8008ff:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
  800906:	00 
  800907:	c7 04 24 e2 21 81 00 	movl   $0x8121e2,(%esp)
  80090e:	e8 27 e7 00 00       	call   80f03a <_panic>
  800913:	eb fe                	jmp    800913 <output+0x83>
  800915:	66 90                	xchg   %ax,%ax
  800917:	66 90                	xchg   %ax,%ax
  800919:	66 90                	xchg   %ax,%ax
  80091b:	66 90                	xchg   %ax,%ax
  80091d:	66 90                	xchg   %ax,%ax
  80091f:	90                   	nop

00800920 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800920:	55                   	push   %ebp
  800921:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800923:	83 f8 1f             	cmp    $0x1f,%eax
  800926:	76 11                	jbe    800939 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  800928:	c7 05 00 c2 b3 00 09 	movl   $0x9,0xb3c200
  80092f:	00 00 00 
    return NULL;
  800932:	b8 00 00 00 00       	mov    $0x0,%eax
  800937:	eb 24                	jmp    80095d <get_socket+0x3d>
  }

  sock = &sockets[s];
  800939:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80093c:	c1 e2 02             	shl    $0x2,%edx
  80093f:	8d 82 80 60 81 00    	lea    0x816080(%edx),%eax

  if (!sock->conn) {
  800945:	83 ba 80 60 81 00 00 	cmpl   $0x0,0x816080(%edx)
  80094c:	75 0f                	jne    80095d <get_socket+0x3d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  80094e:	c7 05 00 c2 b3 00 09 	movl   $0x9,0xb3c200
  800955:	00 00 00 
    return NULL;
  800958:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  return sock;
}
  80095d:	5d                   	pop    %ebp
  80095e:	c3                   	ret    

0080095f <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  80095f:	55                   	push   %ebp
  800960:	89 e5                	mov    %esp,%ebp
  800962:	57                   	push   %edi
  800963:	56                   	push   %esi
  800964:	53                   	push   %ebx
  800965:	83 ec 3c             	sub    $0x3c,%esp
  800968:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80096b:	89 55 cc             	mov    %edx,-0x34(%ebp)
  80096e:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800971:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800978:	00 
  800979:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800980:	00 
  800981:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800984:	89 04 24             	mov    %eax,(%esp)
  800987:	e8 6b ef 00 00       	call   80f8f7 <memset>
  FD_ZERO(&lwriteset);
  80098c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800993:	00 
  800994:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80099b:	00 
  80099c:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80099f:	89 04 24             	mov    %eax,(%esp)
  8009a2:	e8 50 ef 00 00       	call   80f8f7 <memset>
  FD_ZERO(&lexceptset);
  8009a7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8009ae:	00 
  8009af:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8009b6:	00 
  8009b7:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8009ba:	89 04 24             	mov    %eax,(%esp)
  8009bd:	e8 35 ef 00 00       	call   80f8f7 <memset>
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  8009c2:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8009c9:	bf 00 00 00 00       	mov    $0x0,%edi
  8009ce:	e9 80 00 00 00       	jmp    800a53 <lwip_selscan+0xf4>
    if (FD_ISSET(i, readset)) {
  8009d3:	8d 5f 07             	lea    0x7(%edi),%ebx
  8009d6:	85 ff                	test   %edi,%edi
  8009d8:	0f 49 df             	cmovns %edi,%ebx
  8009db:	c1 fb 03             	sar    $0x3,%ebx
  8009de:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  8009e1:	89 fe                	mov    %edi,%esi
  8009e3:	83 e6 07             	and    $0x7,%esi
  8009e6:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8009e9:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8009ed:	0f a3 f0             	bt     %esi,%eax
  8009f0:	73 2c                	jae    800a1e <lwip_selscan+0xbf>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8009f2:	89 f8                	mov    %edi,%eax
  8009f4:	e8 27 ff ff ff       	call   800920 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8009f9:	85 c0                	test   %eax,%eax
  8009fb:	74 21                	je     800a1e <lwip_selscan+0xbf>
  8009fd:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  800a01:	75 07                	jne    800a0a <lwip_selscan+0xab>
  800a03:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800a08:	74 14                	je     800a1e <lwip_selscan+0xbf>
        FD_SET(i, &lreadset);
  800a0a:	b8 01 00 00 00       	mov    $0x1,%eax
  800a0f:	89 f1                	mov    %esi,%ecx
  800a11:	d3 e0                	shl    %cl,%eax
  800a13:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800a16:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  800a1a:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  800a1e:	8b 45 c8             	mov    -0x38(%ebp),%eax
  800a21:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800a25:	0f a3 f0             	bt     %esi,%eax
  800a28:	73 26                	jae    800a50 <lwip_selscan+0xf1>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800a2a:	89 f8                	mov    %edi,%eax
  800a2c:	e8 ef fe ff ff       	call   800920 <get_socket>
      if (p_sock && p_sock->sendevent) {
  800a31:	85 c0                	test   %eax,%eax
  800a33:	74 1b                	je     800a50 <lwip_selscan+0xf1>
  800a35:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a3a:	74 14                	je     800a50 <lwip_selscan+0xf1>
        FD_SET(i, &lwriteset);
  800a3c:	b8 01 00 00 00       	mov    $0x1,%eax
  800a41:	89 f1                	mov    %esi,%ecx
  800a43:	d3 e0                	shl    %cl,%eax
  800a45:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800a48:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800a4c:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800a50:	83 c7 01             	add    $0x1,%edi
  800a53:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  800a56:	0f 8c 77 ff ff ff    	jl     8009d3 <lwip_selscan+0x74>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  800a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a5f:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800a62:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800a64:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800a67:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800a6a:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800a6c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800a73:	00 
  800a74:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800a7b:	00 
  800a7c:	8b 45 08             	mov    0x8(%ebp),%eax
  800a7f:	89 04 24             	mov    %eax,(%esp)
  800a82:	e8 70 ee 00 00       	call   80f8f7 <memset>
  
  return nready;
}
  800a87:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800a8a:	83 c4 3c             	add    $0x3c,%esp
  800a8d:	5b                   	pop    %ebx
  800a8e:	5e                   	pop    %esi
  800a8f:	5f                   	pop    %edi
  800a90:	5d                   	pop    %ebp
  800a91:	c3                   	ret    

00800a92 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800a92:	55                   	push   %ebp
  800a93:	89 e5                	mov    %esp,%ebp
  800a95:	57                   	push   %edi
  800a96:	56                   	push   %esi
  800a97:	53                   	push   %ebx
  800a98:	83 ec 4c             	sub    $0x4c,%esp
  800a9b:	89 d7                	mov    %edx,%edi
  800a9d:	89 ce                	mov    %ecx,%esi
  800a9f:	8b 55 08             	mov    0x8(%ebp),%edx
  800aa2:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800aa5:	e8 76 fe ff ff       	call   800920 <get_socket>
  800aaa:	89 c3                	mov    %eax,%ebx
  if (!sock)
  800aac:	85 c0                	test   %eax,%eax
  800aae:	0f 84 91 00 00 00    	je     800b45 <lwip_getaddrname+0xb3>
    return -1;

  memset(&sin, 0, sizeof(sin));
  800ab4:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  800abb:	00 
  800abc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800ac3:	00 
  800ac4:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800ac7:	89 04 24             	mov    %eax,(%esp)
  800aca:	e8 28 ee 00 00       	call   80f8f7 <memset>
  sin.sin_len = sizeof(sin);
  800acf:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800ad3:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800ad7:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
  800adb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800adf:	8d 45 da             	lea    -0x26(%ebp),%eax
  800ae2:	89 44 24 08          	mov    %eax,0x8(%esp)
  800ae6:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800ae9:	89 44 24 04          	mov    %eax,0x4(%esp)
  800aed:	8b 03                	mov    (%ebx),%eax
  800aef:	89 04 24             	mov    %eax,(%esp)
  800af2:	e8 b2 ab 00 00       	call   80b6a9 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  800af7:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800afb:	89 04 24             	mov    %eax,(%esp)
  800afe:	e8 43 72 00 00       	call   807d46 <htons>
  800b03:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800b07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800b0a:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  800b0d:	83 3e 10             	cmpl   $0x10,(%esi)
  800b10:	76 06                	jbe    800b18 <lwip_getaddrname+0x86>
    *namelen = sizeof(sin);
  800b12:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  800b18:	8b 06                	mov    (%esi),%eax
  800b1a:	89 44 24 08          	mov    %eax,0x8(%esp)
  800b1e:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800b21:	89 44 24 04          	mov    %eax,0x4(%esp)
  800b25:	89 3c 24             	mov    %edi,(%esp)
  800b28:	e8 7f ee 00 00       	call   80f9ac <memcpy>
  sock_set_errno(sock, 0);
  800b2d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  800b34:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  800b3b:	00 00 00 
  return 0;
  800b3e:	b8 00 00 00 00       	mov    $0x0,%eax
  800b43:	eb 05                	jmp    800b4a <lwip_getaddrname+0xb8>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  800b45:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  800b4a:	83 c4 4c             	add    $0x4c,%esp
  800b4d:	5b                   	pop    %ebx
  800b4e:	5e                   	pop    %esi
  800b4f:	5f                   	pop    %edi
  800b50:	5d                   	pop    %ebp
  800b51:	c3                   	ret    

00800b52 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  800b52:	55                   	push   %ebp
  800b53:	89 e5                	mov    %esp,%ebp
  800b55:	57                   	push   %edi
  800b56:	56                   	push   %esi
  800b57:	53                   	push   %ebx
  800b58:	83 ec 1c             	sub    $0x1c,%esp
  800b5b:	8b 7d 08             	mov    0x8(%ebp),%edi
  800b5e:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  800b61:	85 ff                	test   %edi,%edi
  800b63:	0f 84 6a 01 00 00    	je     800cd3 <event_callback+0x181>
    s = conn->socket;
  800b69:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800b6c:	85 db                	test   %ebx,%ebx
  800b6e:	79 3d                	jns    800bad <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  800b70:	a1 64 60 81 00       	mov    0x816064,%eax
  800b75:	89 04 24             	mov    %eax,(%esp)
  800b78:	e8 8b 4b 00 00       	call   805708 <sys_sem_wait>
      if (conn->socket < 0) {
  800b7d:	8b 47 1c             	mov    0x1c(%edi),%eax
  800b80:	85 c0                	test   %eax,%eax
  800b82:	79 1c                	jns    800ba0 <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800b84:	85 f6                	test   %esi,%esi
  800b86:	75 06                	jne    800b8e <event_callback+0x3c>
          conn->socket--;
  800b88:	83 e8 01             	sub    $0x1,%eax
  800b8b:	89 47 1c             	mov    %eax,0x1c(%edi)
        }
        sys_sem_signal(socksem);
  800b8e:	a1 64 60 81 00       	mov    0x816064,%eax
  800b93:	89 04 24             	mov    %eax,(%esp)
  800b96:	e8 35 9d 00 00       	call   80a8d0 <sys_sem_signal>
        return;
  800b9b:	e9 33 01 00 00       	jmp    800cd3 <event_callback+0x181>
      }
      sys_sem_signal(socksem);
  800ba0:	a1 64 60 81 00       	mov    0x816064,%eax
  800ba5:	89 04 24             	mov    %eax,(%esp)
  800ba8:	e8 23 9d 00 00       	call   80a8d0 <sys_sem_signal>
    }

    sock = get_socket(s);
  800bad:	89 d8                	mov    %ebx,%eax
  800baf:	e8 6c fd ff ff       	call   800920 <get_socket>
  800bb4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800bb7:	85 c0                	test   %eax,%eax
  800bb9:	0f 84 14 01 00 00    	je     800cd3 <event_callback+0x181>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  800bbf:	a1 60 60 81 00       	mov    0x816060,%eax
  800bc4:	89 04 24             	mov    %eax,(%esp)
  800bc7:	e8 3c 4b 00 00       	call   805708 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  800bcc:	83 fe 01             	cmp    $0x1,%esi
  800bcf:	74 1d                	je     800bee <event_callback+0x9c>
  800bd1:	83 fe 01             	cmp    $0x1,%esi
  800bd4:	72 0e                	jb     800be4 <event_callback+0x92>
  800bd6:	83 fe 02             	cmp    $0x2,%esi
  800bd9:	74 1d                	je     800bf8 <event_callback+0xa6>
  800bdb:	83 fe 03             	cmp    $0x3,%esi
  800bde:	66 90                	xchg   %ax,%ax
  800be0:	74 21                	je     800c03 <event_callback+0xb1>
  800be2:	eb 2a                	jmp    800c0e <event_callback+0xbc>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  800be4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800be7:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  800bec:	eb 3c                	jmp    800c2a <event_callback+0xd8>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  800bee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800bf1:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800bf6:	eb 32                	jmp    800c2a <event_callback+0xd8>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  800bf8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800bfb:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800c01:	eb 27                	jmp    800c2a <event_callback+0xd8>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  800c03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c06:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800c0c:	eb 1c                	jmp    800c2a <event_callback+0xd8>
    default:
      LWIP_ASSERT("unknown event", 0);
  800c0e:	c7 44 24 08 1a 22 81 	movl   $0x81221a,0x8(%esp)
  800c15:	00 
  800c16:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  800c1d:	00 
  800c1e:	c7 04 24 28 22 81 00 	movl   $0x812228,(%esp)
  800c25:	e8 10 e4 00 00       	call   80f03a <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  800c2a:	a1 60 60 81 00       	mov    0x816060,%eax
  800c2f:	89 04 24             	mov    %eax,(%esp)
  800c32:	e8 99 9c 00 00       	call   80a8d0 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800c37:	8d 7b 07             	lea    0x7(%ebx),%edi
  800c3a:	85 db                	test   %ebx,%ebx
  800c3c:	0f 49 fb             	cmovns %ebx,%edi
  800c3f:	c1 ff 03             	sar    $0x3,%edi
  800c42:	89 d9                	mov    %ebx,%ecx
  800c44:	83 e1 07             	and    $0x7,%ecx
  800c47:	b8 01 00 00 00       	mov    $0x1,%eax
  800c4c:	d3 e0                	shl    %cl,%eax
  800c4e:	89 c6                	mov    %eax,%esi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  800c50:	a1 60 60 81 00       	mov    0x816060,%eax
  800c55:	89 04 24             	mov    %eax,(%esp)
  800c58:	e8 ab 4a 00 00       	call   805708 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800c5d:	8b 1d 68 60 81 00    	mov    0x816068,%ebx
  800c63:	eb 3a                	jmp    800c9f <event_callback+0x14d>
      if (scb->sem_signalled == 0) {
  800c65:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800c69:	75 32                	jne    800c9d <event_callback+0x14b>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800c6b:	8b 43 04             	mov    0x4(%ebx),%eax
  800c6e:	85 c0                	test   %eax,%eax
  800c70:	74 12                	je     800c84 <event_callback+0x132>
  800c72:	0f b6 04 38          	movzbl (%eax,%edi,1),%eax
  800c76:	85 f0                	test   %esi,%eax
  800c78:	74 0a                	je     800c84 <event_callback+0x132>
          if (sock->rcvevent)
  800c7a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c7d:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800c82:	75 21                	jne    800ca5 <event_callback+0x153>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800c84:	8b 43 08             	mov    0x8(%ebx),%eax
  800c87:	85 c0                	test   %eax,%eax
  800c89:	74 12                	je     800c9d <event_callback+0x14b>
  800c8b:	0f b6 04 38          	movzbl (%eax,%edi,1),%eax
  800c8f:	85 f0                	test   %esi,%eax
  800c91:	74 0a                	je     800c9d <event_callback+0x14b>
          if (sock->sendevent)
  800c93:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c96:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800c9b:	75 08                	jne    800ca5 <event_callback+0x153>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  800c9d:	8b 1b                	mov    (%ebx),%ebx
  800c9f:	85 db                	test   %ebx,%ebx
  800ca1:	75 c2                	jne    800c65 <event_callback+0x113>
  800ca3:	eb 21                	jmp    800cc6 <event_callback+0x174>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  800ca5:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800cac:	a1 60 60 81 00       	mov    0x816060,%eax
  800cb1:	89 04 24             	mov    %eax,(%esp)
  800cb4:	e8 17 9c 00 00       	call   80a8d0 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800cb9:	8b 43 14             	mov    0x14(%ebx),%eax
  800cbc:	89 04 24             	mov    %eax,(%esp)
  800cbf:	e8 0c 9c 00 00       	call   80a8d0 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  800cc4:	eb 8a                	jmp    800c50 <event_callback+0xfe>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  800cc6:	a1 60 60 81 00       	mov    0x816060,%eax
  800ccb:	89 04 24             	mov    %eax,(%esp)
  800cce:	e8 fd 9b 00 00       	call   80a8d0 <sys_sem_signal>
      break;
    }
  }
}
  800cd3:	83 c4 1c             	add    $0x1c,%esp
  800cd6:	5b                   	pop    %ebx
  800cd7:	5e                   	pop    %esi
  800cd8:	5f                   	pop    %edi
  800cd9:	5d                   	pop    %ebp
  800cda:	c3                   	ret    

00800cdb <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800cdb:	55                   	push   %ebp
  800cdc:	89 e5                	mov    %esp,%ebp
  800cde:	56                   	push   %esi
  800cdf:	53                   	push   %ebx
  800ce0:	83 ec 10             	sub    $0x10,%esp
  800ce3:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800ce5:	a1 64 60 81 00       	mov    0x816064,%eax
  800cea:	89 04 24             	mov    %eax,(%esp)
  800ced:	e8 16 4a 00 00       	call   805708 <sys_sem_wait>
  800cf2:	ba 80 60 81 00       	mov    $0x816080,%edx

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800cf7:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800cfc:	83 3a 00             	cmpl   $0x0,(%edx)
  800cff:	75 5f                	jne    800d60 <alloc_socket+0x85>
      sockets[i].conn       = newconn;
  800d01:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
  800d08:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
  800d0b:	c1 e1 02             	shl    $0x2,%ecx
  800d0e:	89 b1 80 60 81 00    	mov    %esi,0x816080(%ecx)
      sockets[i].lastdata   = NULL;
  800d14:	c7 81 84 60 81 00 00 	movl   $0x0,0x816084(%ecx)
  800d1b:	00 00 00 
      sockets[i].lastoffset = 0;
  800d1e:	66 c7 81 88 60 81 00 	movw   $0x0,0x816088(%ecx)
  800d25:	00 00 
      sockets[i].rcvevent   = 0;
  800d27:	66 c7 81 8a 60 81 00 	movw   $0x0,0x81608a(%ecx)
  800d2e:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800d30:	66 c7 81 8c 60 81 00 	movw   $0x1,0x81608c(%ecx)
  800d37:	01 00 
      sockets[i].flags      = 0;
  800d39:	66 c7 81 8e 60 81 00 	movw   $0x0,0x81608e(%ecx)
  800d40:	00 00 
      sockets[i].err        = 0;
  800d42:	01 da                	add    %ebx,%edx
  800d44:	c7 04 95 90 60 81 00 	movl   $0x0,0x816090(,%edx,4)
  800d4b:	00 00 00 00 
      sys_sem_signal(socksem);
  800d4f:	a1 64 60 81 00       	mov    0x816064,%eax
  800d54:	89 04 24             	mov    %eax,(%esp)
  800d57:	e8 74 9b 00 00       	call   80a8d0 <sys_sem_signal>
      return i;
  800d5c:	89 d8                	mov    %ebx,%eax
  800d5e:	eb 1d                	jmp    800d7d <alloc_socket+0xa2>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800d60:	83 c3 01             	add    $0x1,%ebx
  800d63:	83 c2 14             	add    $0x14,%edx
  800d66:	83 fb 20             	cmp    $0x20,%ebx
  800d69:	75 91                	jne    800cfc <alloc_socket+0x21>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800d6b:	a1 64 60 81 00       	mov    0x816064,%eax
  800d70:	89 04 24             	mov    %eax,(%esp)
  800d73:	e8 58 9b 00 00       	call   80a8d0 <sys_sem_signal>
  return -1;
  800d78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800d7d:	83 c4 10             	add    $0x10,%esp
  800d80:	5b                   	pop    %ebx
  800d81:	5e                   	pop    %esi
  800d82:	5d                   	pop    %ebp
  800d83:	c3                   	ret    

00800d84 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800d84:	55                   	push   %ebp
  800d85:	89 e5                	mov    %esp,%ebp
  800d87:	53                   	push   %ebx
  800d88:	83 ec 14             	sub    $0x14,%esp
  800d8b:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d8e:	85 c0                	test   %eax,%eax
  800d90:	75 1c                	jne    800dae <lwip_getsockopt_internal+0x2a>
  800d92:	c7 44 24 08 3f 22 81 	movl   $0x81223f,0x8(%esp)
  800d99:	00 
  800d9a:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  800da1:	00 
  800da2:	c7 04 24 28 22 81 00 	movl   $0x812228,(%esp)
  800da9:	e8 8c e2 00 00       	call   80f03a <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800dae:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800db0:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800db3:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800db6:	8b 40 08             	mov    0x8(%eax),%eax
  800db9:	83 f8 06             	cmp    $0x6,%eax
  800dbc:	0f 84 0a 01 00 00    	je     800ecc <lwip_getsockopt_internal+0x148>
  800dc2:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800dc7:	74 0d                	je     800dd6 <lwip_getsockopt_internal+0x52>
  800dc9:	85 c0                	test   %eax,%eax
  800dcb:	0f 85 27 01 00 00    	jne    800ef8 <lwip_getsockopt_internal+0x174>
  800dd1:	e9 d2 00 00 00       	jmp    800ea8 <lwip_getsockopt_internal+0x124>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800dd6:	83 fa 20             	cmp    $0x20,%edx
  800dd9:	74 39                	je     800e14 <lwip_getsockopt_internal+0x90>
  800ddb:	83 fa 20             	cmp    $0x20,%edx
  800dde:	66 90                	xchg   %ax,%ax
  800de0:	7f 10                	jg     800df2 <lwip_getsockopt_internal+0x6e>
  800de2:	83 fa 02             	cmp    $0x2,%edx
  800de5:	74 2d                	je     800e14 <lwip_getsockopt_internal+0x90>
  800de7:	83 fa 08             	cmp    $0x8,%edx
  800dea:	0f 85 08 01 00 00    	jne    800ef8 <lwip_getsockopt_internal+0x174>
  800df0:	eb 22                	jmp    800e14 <lwip_getsockopt_internal+0x90>
  800df2:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800df8:	74 2c                	je     800e26 <lwip_getsockopt_internal+0xa2>
  800dfa:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800e00:	0f 84 92 00 00 00    	je     800e98 <lwip_getsockopt_internal+0x114>
  800e06:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800e0c:	0f 85 e6 00 00 00    	jne    800ef8 <lwip_getsockopt_internal+0x174>
  800e12:	eb 4f                	jmp    800e63 <lwip_getsockopt_internal+0xdf>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800e14:	8b 01                	mov    (%ecx),%eax
  800e16:	8b 40 08             	mov    0x8(%eax),%eax
  800e19:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800e1d:	21 c2                	and    %eax,%edx
  800e1f:	89 13                	mov    %edx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800e21:	e9 d2 00 00 00       	jmp    800ef8 <lwip_getsockopt_internal+0x174>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800e26:	8b 01                	mov    (%ecx),%eax
  800e28:	8b 10                	mov    (%eax),%edx
  800e2a:	89 d0                	mov    %edx,%eax
  800e2c:	25 f0 00 00 00       	and    $0xf0,%eax
  800e31:	83 f8 20             	cmp    $0x20,%eax
  800e34:	74 22                	je     800e58 <lwip_getsockopt_internal+0xd4>
  800e36:	83 f8 40             	cmp    $0x40,%eax
  800e39:	74 12                	je     800e4d <lwip_getsockopt_internal+0xc9>
  800e3b:	83 f8 10             	cmp    $0x10,%eax
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800e3e:	b8 01 00 00 00       	mov    $0x1,%eax
  800e43:	0f 44 d0             	cmove  %eax,%edx
  800e46:	89 13                	mov    %edx,(%ebx)
  800e48:	e9 ab 00 00 00       	jmp    800ef8 <lwip_getsockopt_internal+0x174>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800e4d:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800e53:	e9 a0 00 00 00       	jmp    800ef8 <lwip_getsockopt_internal+0x174>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800e58:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800e5e:	e9 95 00 00 00       	jmp    800ef8 <lwip_getsockopt_internal+0x174>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800e63:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  800e67:	75 21                	jne    800e8a <lwip_getsockopt_internal+0x106>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800e69:	8b 01                	mov    (%ecx),%eax
  800e6b:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  800e6f:	f7 da                	neg    %edx
  800e71:	b8 05 00 00 00       	mov    $0x5,%eax
  800e76:	83 fa 0e             	cmp    $0xe,%edx
  800e79:	77 07                	ja     800e82 <lwip_getsockopt_internal+0xfe>
  800e7b:	8b 04 95 e0 22 81 00 	mov    0x8122e0(,%edx,4),%eax
  800e82:	89 41 10             	mov    %eax,0x10(%ecx)
  800e85:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
      } 
      *(int *)optval = sock->err;
  800e8a:	8b 41 10             	mov    0x10(%ecx),%eax
  800e8d:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800e8f:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800e96:	eb 60                	jmp    800ef8 <lwip_getsockopt_internal+0x174>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800e98:	8b 01                	mov    (%ecx),%eax
  800e9a:	8b 40 08             	mov    0x8(%eax),%eax
  800e9d:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800ea1:	83 e0 01             	and    $0x1,%eax
  800ea4:	89 03                	mov    %eax,(%ebx)
      break;
  800ea6:	eb 50                	jmp    800ef8 <lwip_getsockopt_internal+0x174>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800ea8:	83 fa 01             	cmp    $0x1,%edx
  800eab:	74 12                	je     800ebf <lwip_getsockopt_internal+0x13b>
  800ead:	83 fa 02             	cmp    $0x2,%edx
  800eb0:	75 46                	jne    800ef8 <lwip_getsockopt_internal+0x174>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800eb2:	8b 01                	mov    (%ecx),%eax
  800eb4:	8b 40 08             	mov    0x8(%eax),%eax
  800eb7:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800ebb:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800ebd:	eb 39                	jmp    800ef8 <lwip_getsockopt_internal+0x174>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800ebf:	8b 01                	mov    (%ecx),%eax
  800ec1:	8b 40 08             	mov    0x8(%eax),%eax
  800ec4:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800ec8:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800eca:	eb 2c                	jmp    800ef8 <lwip_getsockopt_internal+0x174>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800ecc:	83 fa 01             	cmp    $0x1,%edx
  800ecf:	74 07                	je     800ed8 <lwip_getsockopt_internal+0x154>
  800ed1:	83 fa 02             	cmp    $0x2,%edx
  800ed4:	74 15                	je     800eeb <lwip_getsockopt_internal+0x167>
  800ed6:	eb 20                	jmp    800ef8 <lwip_getsockopt_internal+0x174>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800ed8:	8b 01                	mov    (%ecx),%eax
  800eda:	8b 40 08             	mov    0x8(%eax),%eax
  800edd:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800ee1:	83 e0 40             	and    $0x40,%eax
  800ee4:	0f b6 c0             	movzbl %al,%eax
  800ee7:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800ee9:	eb 0d                	jmp    800ef8 <lwip_getsockopt_internal+0x174>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800eeb:	8b 01                	mov    (%ecx),%eax
  800eed:	8b 40 08             	mov    0x8(%eax),%eax
  800ef0:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800ef6:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800ef8:	8b 01                	mov    (%ecx),%eax
  800efa:	8b 40 10             	mov    0x10(%eax),%eax
  800efd:	89 04 24             	mov    %eax,(%esp)
  800f00:	e8 cb 99 00 00       	call   80a8d0 <sys_sem_signal>
}
  800f05:	83 c4 14             	add    $0x14,%esp
  800f08:	5b                   	pop    %ebx
  800f09:	5d                   	pop    %ebp
  800f0a:	c3                   	ret    

00800f0b <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800f0b:	55                   	push   %ebp
  800f0c:	89 e5                	mov    %esp,%ebp
  800f0e:	53                   	push   %ebx
  800f0f:	83 ec 14             	sub    $0x14,%esp
  800f12:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800f15:	85 c0                	test   %eax,%eax
  800f17:	75 1c                	jne    800f35 <lwip_setsockopt_internal+0x2a>
  800f19:	c7 44 24 08 3f 22 81 	movl   $0x81223f,0x8(%esp)
  800f20:	00 
  800f21:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  800f28:	00 
  800f29:	c7 04 24 28 22 81 00 	movl   $0x812228,(%esp)
  800f30:	e8 05 e1 00 00       	call   80f03a <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800f35:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800f37:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800f3a:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800f3d:	8b 40 08             	mov    0x8(%eax),%eax
  800f40:	83 f8 06             	cmp    $0x6,%eax
  800f43:	0f 84 87 00 00 00    	je     800fd0 <lwip_setsockopt_internal+0xc5>
  800f49:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800f4e:	74 0a                	je     800f5a <lwip_setsockopt_internal+0x4f>
  800f50:	85 c0                	test   %eax,%eax
  800f52:	0f 85 ad 00 00 00    	jne    801005 <lwip_setsockopt_internal+0xfa>
  800f58:	eb 54                	jmp    800fae <lwip_setsockopt_internal+0xa3>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800f5a:	83 f9 20             	cmp    $0x20,%ecx
  800f5d:	8d 76 00             	lea    0x0(%esi),%esi
  800f60:	74 11                	je     800f73 <lwip_setsockopt_internal+0x68>
  800f62:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800f68:	74 29                	je     800f93 <lwip_setsockopt_internal+0x88>
  800f6a:	83 f9 08             	cmp    $0x8,%ecx
  800f6d:	0f 85 92 00 00 00    	jne    801005 <lwip_setsockopt_internal+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800f73:	83 3b 00             	cmpl   $0x0,(%ebx)
  800f76:	74 0e                	je     800f86 <lwip_setsockopt_internal+0x7b>
        sock->conn->pcb.ip->so_options |= optname;
  800f78:	8b 02                	mov    (%edx),%eax
  800f7a:	8b 40 08             	mov    0x8(%eax),%eax
  800f7d:	66 09 48 08          	or     %cx,0x8(%eax)
  800f81:	e9 7f 00 00 00       	jmp    801005 <lwip_setsockopt_internal+0xfa>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800f86:	8b 02                	mov    (%edx),%eax
  800f88:	8b 40 08             	mov    0x8(%eax),%eax
  800f8b:	f7 d1                	not    %ecx
  800f8d:	66 21 48 08          	and    %cx,0x8(%eax)
  800f91:	eb 72                	jmp    801005 <lwip_setsockopt_internal+0xfa>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800f93:	83 3b 00             	cmpl   $0x0,(%ebx)
  800f96:	74 0b                	je     800fa3 <lwip_setsockopt_internal+0x98>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800f98:	8b 02                	mov    (%edx),%eax
  800f9a:	8b 40 08             	mov    0x8(%eax),%eax
  800f9d:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800fa1:	eb 62                	jmp    801005 <lwip_setsockopt_internal+0xfa>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800fa3:	8b 02                	mov    (%edx),%eax
  800fa5:	8b 40 08             	mov    0x8(%eax),%eax
  800fa8:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800fac:	eb 57                	jmp    801005 <lwip_setsockopt_internal+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800fae:	83 f9 01             	cmp    $0x1,%ecx
  800fb1:	74 11                	je     800fc4 <lwip_setsockopt_internal+0xb9>
  800fb3:	83 f9 02             	cmp    $0x2,%ecx
  800fb6:	75 4d                	jne    801005 <lwip_setsockopt_internal+0xfa>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800fb8:	8b 02                	mov    (%edx),%eax
  800fba:	8b 40 08             	mov    0x8(%eax),%eax
  800fbd:	8b 0b                	mov    (%ebx),%ecx
  800fbf:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800fc2:	eb 41                	jmp    801005 <lwip_setsockopt_internal+0xfa>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800fc4:	8b 02                	mov    (%edx),%eax
  800fc6:	8b 40 08             	mov    0x8(%eax),%eax
  800fc9:	8b 0b                	mov    (%ebx),%ecx
  800fcb:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  800fce:	eb 35                	jmp    801005 <lwip_setsockopt_internal+0xfa>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800fd0:	83 f9 01             	cmp    $0x1,%ecx
  800fd3:	74 07                	je     800fdc <lwip_setsockopt_internal+0xd1>
  800fd5:	83 f9 02             	cmp    $0x2,%ecx
  800fd8:	74 1e                	je     800ff8 <lwip_setsockopt_internal+0xed>
  800fda:	eb 29                	jmp    801005 <lwip_setsockopt_internal+0xfa>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800fdc:	83 3b 00             	cmpl   $0x0,(%ebx)
  800fdf:	90                   	nop
  800fe0:	74 0b                	je     800fed <lwip_setsockopt_internal+0xe2>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800fe2:	8b 02                	mov    (%edx),%eax
  800fe4:	8b 40 08             	mov    0x8(%eax),%eax
  800fe7:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800feb:	eb 18                	jmp    801005 <lwip_setsockopt_internal+0xfa>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800fed:	8b 02                	mov    (%edx),%eax
  800fef:	8b 40 08             	mov    0x8(%eax),%eax
  800ff2:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800ff6:	eb 0d                	jmp    801005 <lwip_setsockopt_internal+0xfa>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800ff8:	8b 02                	mov    (%edx),%eax
  800ffa:	8b 40 08             	mov    0x8(%eax),%eax
  800ffd:	8b 0b                	mov    (%ebx),%ecx
  800fff:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  801005:	8b 02                	mov    (%edx),%eax
  801007:	8b 40 10             	mov    0x10(%eax),%eax
  80100a:	89 04 24             	mov    %eax,(%esp)
  80100d:	e8 be 98 00 00       	call   80a8d0 <sys_sem_signal>
}
  801012:	83 c4 14             	add    $0x14,%esp
  801015:	5b                   	pop    %ebx
  801016:	5d                   	pop    %ebp
  801017:	c3                   	ret    

00801018 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  801018:	55                   	push   %ebp
  801019:	89 e5                	mov    %esp,%ebp
  80101b:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  80101e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801025:	e8 c4 95 00 00       	call   80a5ee <sys_sem_new>
  80102a:	a3 64 60 81 00       	mov    %eax,0x816064
  selectsem = sys_sem_new(1);
  80102f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801036:	e8 b3 95 00 00       	call   80a5ee <sys_sem_new>
  80103b:	a3 60 60 81 00       	mov    %eax,0x816060
}
  801040:	c9                   	leave  
  801041:	c3                   	ret    

00801042 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  801042:	55                   	push   %ebp
  801043:	89 e5                	mov    %esp,%ebp
  801045:	57                   	push   %edi
  801046:	56                   	push   %esi
  801047:	53                   	push   %ebx
  801048:	83 ec 4c             	sub    $0x4c,%esp
  80104b:	8b 75 10             	mov    0x10(%ebp),%esi
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  80104e:	8b 45 08             	mov    0x8(%ebp),%eax
  801051:	e8 ca f8 ff ff       	call   800920 <get_socket>
  801056:	89 c7                	mov    %eax,%edi
  if (!sock)
  801058:	85 c0                	test   %eax,%eax
  80105a:	0f 84 9b 01 00 00    	je     8011fb <lwip_accept+0x1b9>
    return -1;

  newconn = netconn_accept(sock->conn);
  801060:	8b 00                	mov    (%eax),%eax
  801062:	89 04 24             	mov    %eax,(%esp)
  801065:	e8 18 a8 00 00       	call   80b882 <netconn_accept>
  80106a:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  80106c:	85 c0                	test   %eax,%eax
  80106e:	75 2b                	jne    80109b <lwip_accept+0x59>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  801070:	8b 07                	mov    (%edi),%eax
  801072:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  801076:	f7 da                	neg    %edx
  801078:	b8 05 00 00 00       	mov    $0x5,%eax
  80107d:	83 fa 0e             	cmp    $0xe,%edx
  801080:	77 07                	ja     801089 <lwip_accept+0x47>
  801082:	8b 04 95 e0 22 81 00 	mov    0x8122e0(,%edx,4),%eax
  801089:	89 47 10             	mov    %eax,0x10(%edi)
  80108c:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  801091:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801096:	e9 65 01 00 00       	jmp    801200 <lwip_accept+0x1be>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  80109b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8010a2:	00 
  8010a3:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  8010a6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010aa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8010ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010b1:	89 1c 24             	mov    %ebx,(%esp)
  8010b4:	e8 f0 a5 00 00       	call   80b6a9 <netconn_getaddr>
  8010b9:	88 45 c4             	mov    %al,-0x3c(%ebp)
  if (err != ERR_OK) {
  8010bc:	84 c0                	test   %al,%al
  8010be:	74 31                	je     8010f1 <lwip_accept+0xaf>
    netconn_delete(newconn);
  8010c0:	89 1c 24             	mov    %ebx,(%esp)
  8010c3:	e8 77 a5 00 00       	call   80b63f <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  8010c8:	0f be 55 c4          	movsbl -0x3c(%ebp),%edx
  8010cc:	f7 da                	neg    %edx
  8010ce:	b8 05 00 00 00       	mov    $0x5,%eax
  8010d3:	83 fa 0e             	cmp    $0xe,%edx
  8010d6:	77 07                	ja     8010df <lwip_accept+0x9d>
  8010d8:	8b 04 95 e0 22 81 00 	mov    0x8122e0(,%edx,4),%eax
  8010df:	89 47 10             	mov    %eax,0x10(%edi)
  8010e2:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  8010e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010ec:	e9 0f 01 00 00       	jmp    801200 <lwip_accept+0x1be>
  }

  memset(&sin, 0, sizeof(sin));
  8010f1:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  8010f8:	00 
  8010f9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801100:	00 
  801101:	8d 45 d0             	lea    -0x30(%ebp),%eax
  801104:	89 04 24             	mov    %eax,(%esp)
  801107:	e8 eb e7 00 00       	call   80f8f7 <memset>
  sin.sin_len = sizeof(sin);
  80110c:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  801110:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  801114:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  801118:	89 04 24             	mov    %eax,(%esp)
  80111b:	e8 26 6c 00 00       	call   807d46 <htons>
  801120:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  801124:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801127:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  80112a:	83 3e 10             	cmpl   $0x10,(%esi)
  80112d:	76 06                	jbe    801135 <lwip_accept+0xf3>
    *addrlen = sizeof(sin);
  80112f:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(addr, &sin, *addrlen);
  801135:	8b 06                	mov    (%esi),%eax
  801137:	89 44 24 08          	mov    %eax,0x8(%esp)
  80113b:	8d 45 d0             	lea    -0x30(%ebp),%eax
  80113e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801142:	8b 45 0c             	mov    0xc(%ebp),%eax
  801145:	89 04 24             	mov    %eax,(%esp)
  801148:	e8 5f e8 00 00       	call   80f9ac <memcpy>

  newsock = alloc_socket(newconn);
  80114d:	89 d8                	mov    %ebx,%eax
  80114f:	e8 87 fb ff ff       	call   800cdb <alloc_socket>
  801154:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  801156:	83 f8 ff             	cmp    $0xffffffff,%eax
  801159:	75 23                	jne    80117e <lwip_accept+0x13c>
    netconn_delete(newconn);
  80115b:	89 1c 24             	mov    %ebx,(%esp)
  80115e:	e8 dc a4 00 00       	call   80b63f <netconn_delete>
    sock_set_errno(sock, ENFILE);
  801163:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  80116a:	c7 05 00 c2 b3 00 17 	movl   $0x17,0xb3c200
  801171:	00 00 00 
    return -1;
  801174:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801179:	e9 82 00 00 00       	jmp    801200 <lwip_accept+0x1be>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  80117e:	83 f8 1f             	cmp    $0x1f,%eax
  801181:	76 1c                	jbe    80119f <lwip_accept+0x15d>
  801183:	c7 44 24 08 4b 22 81 	movl   $0x81224b,0x8(%esp)
  80118a:	00 
  80118b:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  801192:	00 
  801193:	c7 04 24 28 22 81 00 	movl   $0x812228,(%esp)
  80119a:	e8 9b de 00 00       	call   80f03a <_panic>
  newconn->callback = event_callback;
  80119f:	c7 43 2c 52 0b 80 00 	movl   $0x800b52,0x2c(%ebx)
  nsock = &sockets[newsock];
  8011a6:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8011a9:	8d 04 85 80 60 81 00 	lea    0x816080(,%eax,4),%eax
  8011b0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  8011b3:	a1 64 60 81 00       	mov    0x816064,%eax
  8011b8:	89 04 24             	mov    %eax,(%esp)
  8011bb:	e8 48 45 00 00       	call   805708 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  8011c0:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  8011c3:	0f b7 41 0a          	movzwl 0xa(%ecx),%eax
  8011c7:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
  8011cb:	83 e8 01             	sub    $0x1,%eax
  8011ce:	66 2b 43 1c          	sub    0x1c(%ebx),%ax
  8011d2:	66 89 41 0a          	mov    %ax,0xa(%ecx)
  newconn->socket = newsock;
  8011d6:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  8011d9:	a1 64 60 81 00       	mov    0x816064,%eax
  8011de:	89 04 24             	mov    %eax,(%esp)
  8011e1:	e8 ea 96 00 00       	call   80a8d0 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  8011e6:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8011ed:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8011f4:	00 00 00 
  return newsock;
  8011f7:	89 f0                	mov    %esi,%eax
  8011f9:	eb 05                	jmp    801200 <lwip_accept+0x1be>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  8011fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  801200:	83 c4 4c             	add    $0x4c,%esp
  801203:	5b                   	pop    %ebx
  801204:	5e                   	pop    %esi
  801205:	5f                   	pop    %edi
  801206:	5d                   	pop    %ebp
  801207:	c3                   	ret    

00801208 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  801208:	55                   	push   %ebp
  801209:	89 e5                	mov    %esp,%ebp
  80120b:	56                   	push   %esi
  80120c:	53                   	push   %ebx
  80120d:	83 ec 20             	sub    $0x20,%esp
  801210:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  801213:	8b 45 08             	mov    0x8(%ebp),%eax
  801216:	e8 05 f7 ff ff       	call   800920 <get_socket>
  80121b:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80121d:	85 c0                	test   %eax,%eax
  80121f:	0f 84 94 00 00 00    	je     8012b9 <lwip_bind+0xb1>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801225:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801229:	75 06                	jne    801231 <lwip_bind+0x29>
  80122b:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80122f:	74 1c                	je     80124d <lwip_bind+0x45>
  801231:	c7 44 24 08 60 22 81 	movl   $0x812260,0x8(%esp)
  801238:	00 
  801239:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  801240:	00 
  801241:	c7 04 24 28 22 81 00 	movl   $0x812228,(%esp)
  801248:	e8 ed dd 00 00       	call   80f03a <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80124d:	8b 46 04             	mov    0x4(%esi),%eax
  801250:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  801253:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801257:	89 04 24             	mov    %eax,(%esp)
  80125a:	e8 f4 6a 00 00       	call   807d53 <ntohs>
  80125f:	0f b7 c0             	movzwl %ax,%eax
  801262:	89 44 24 08          	mov    %eax,0x8(%esp)
  801266:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801269:	89 44 24 04          	mov    %eax,0x4(%esp)
  80126d:	8b 03                	mov    (%ebx),%eax
  80126f:	89 04 24             	mov    %eax,(%esp)
  801272:	e8 cd a4 00 00       	call   80b744 <netconn_bind>

  if (err != ERR_OK) {
  801277:	84 c0                	test   %al,%al
  801279:	74 26                	je     8012a1 <lwip_bind+0x99>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80127b:	0f be c0             	movsbl %al,%eax
  80127e:	f7 d8                	neg    %eax
  801280:	ba 05 00 00 00       	mov    $0x5,%edx
  801285:	83 f8 0e             	cmp    $0xe,%eax
  801288:	77 07                	ja     801291 <lwip_bind+0x89>
  80128a:	8b 14 85 e0 22 81 00 	mov    0x8122e0(,%eax,4),%edx
  801291:	89 53 10             	mov    %edx,0x10(%ebx)
  801294:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
    return -1;
  80129a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80129f:	eb 1d                	jmp    8012be <lwip_bind+0xb6>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8012a1:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8012a8:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8012af:	00 00 00 
  return 0;
  8012b2:	b8 00 00 00 00       	mov    $0x0,%eax
  8012b7:	eb 05                	jmp    8012be <lwip_bind+0xb6>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8012b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  8012be:	83 c4 20             	add    $0x20,%esp
  8012c1:	5b                   	pop    %ebx
  8012c2:	5e                   	pop    %esi
  8012c3:	5d                   	pop    %ebp
  8012c4:	c3                   	ret    

008012c5 <lwip_close>:

int
lwip_close(int s)
{
  8012c5:	55                   	push   %ebp
  8012c6:	89 e5                	mov    %esp,%ebp
  8012c8:	53                   	push   %ebx
  8012c9:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8012cc:	8b 45 08             	mov    0x8(%ebp),%eax
  8012cf:	e8 4c f6 ff ff       	call   800920 <get_socket>
  8012d4:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  8012d6:	85 c0                	test   %eax,%eax
  8012d8:	74 5e                	je     801338 <lwip_close+0x73>
    return -1;
  }

  netconn_delete(sock->conn);
  8012da:	8b 00                	mov    (%eax),%eax
  8012dc:	89 04 24             	mov    %eax,(%esp)
  8012df:	e8 5b a3 00 00       	call   80b63f <netconn_delete>

  sys_sem_wait(socksem);
  8012e4:	a1 64 60 81 00       	mov    0x816064,%eax
  8012e9:	89 04 24             	mov    %eax,(%esp)
  8012ec:	e8 17 44 00 00       	call   805708 <sys_sem_wait>
  if (sock->lastdata) {
  8012f1:	8b 43 04             	mov    0x4(%ebx),%eax
  8012f4:	85 c0                	test   %eax,%eax
  8012f6:	74 08                	je     801300 <lwip_close+0x3b>
    netbuf_delete(sock->lastdata);
  8012f8:	89 04 24             	mov    %eax,(%esp)
  8012fb:	e8 2c 15 00 00       	call   80282c <netbuf_delete>
  }
  sock->lastdata   = NULL;
  801300:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801307:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  80130d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  801313:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80131a:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801321:	00 00 00 
  sys_sem_signal(socksem);
  801324:	a1 64 60 81 00       	mov    0x816064,%eax
  801329:	89 04 24             	mov    %eax,(%esp)
  80132c:	e8 9f 95 00 00       	call   80a8d0 <sys_sem_signal>
  return 0;
  801331:	b8 00 00 00 00       	mov    $0x0,%eax
  801336:	eb 05                	jmp    80133d <lwip_close+0x78>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  801338:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  80133d:	83 c4 14             	add    $0x14,%esp
  801340:	5b                   	pop    %ebx
  801341:	5d                   	pop    %ebp
  801342:	c3                   	ret    

00801343 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  801343:	55                   	push   %ebp
  801344:	89 e5                	mov    %esp,%ebp
  801346:	56                   	push   %esi
  801347:	53                   	push   %ebx
  801348:	83 ec 20             	sub    $0x20,%esp
  80134b:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80134e:	8b 45 08             	mov    0x8(%ebp),%eax
  801351:	e8 ca f5 ff ff       	call   800920 <get_socket>
  801356:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801358:	85 c0                	test   %eax,%eax
  80135a:	0f 84 94 00 00 00    	je     8013f4 <lwip_connect+0xb1>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801360:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801364:	75 06                	jne    80136c <lwip_connect+0x29>
  801366:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80136a:	74 1c                	je     801388 <lwip_connect+0x45>
  80136c:	c7 44 24 08 7b 22 81 	movl   $0x81227b,0x8(%esp)
  801373:	00 
  801374:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  80137b:	00 
  80137c:	c7 04 24 28 22 81 00 	movl   $0x812228,(%esp)
  801383:	e8 b2 dc 00 00       	call   80f03a <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801388:	8b 46 04             	mov    0x4(%esi),%eax
  80138b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80138e:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801392:	89 04 24             	mov    %eax,(%esp)
  801395:	e8 b9 69 00 00       	call   807d53 <ntohs>
  80139a:	0f b7 c0             	movzwl %ax,%eax
  80139d:	89 44 24 08          	mov    %eax,0x8(%esp)
  8013a1:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8013a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8013a8:	8b 03                	mov    (%ebx),%eax
  8013aa:	89 04 24             	mov    %eax,(%esp)
  8013ad:	e8 e8 a3 00 00       	call   80b79a <netconn_connect>
  }

  if (err != ERR_OK) {
  8013b2:	84 c0                	test   %al,%al
  8013b4:	74 26                	je     8013dc <lwip_connect+0x99>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8013b6:	0f be c0             	movsbl %al,%eax
  8013b9:	f7 d8                	neg    %eax
  8013bb:	ba 05 00 00 00       	mov    $0x5,%edx
  8013c0:	83 f8 0e             	cmp    $0xe,%eax
  8013c3:	77 07                	ja     8013cc <lwip_connect+0x89>
  8013c5:	8b 14 85 e0 22 81 00 	mov    0x8122e0(,%eax,4),%edx
  8013cc:	89 53 10             	mov    %edx,0x10(%ebx)
  8013cf:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
    return -1;
  8013d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8013da:	eb 1d                	jmp    8013f9 <lwip_connect+0xb6>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8013dc:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8013e3:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8013ea:	00 00 00 
  return 0;
  8013ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8013f2:	eb 05                	jmp    8013f9 <lwip_connect+0xb6>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8013f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  8013f9:	83 c4 20             	add    $0x20,%esp
  8013fc:	5b                   	pop    %ebx
  8013fd:	5e                   	pop    %esi
  8013fe:	5d                   	pop    %ebp
  8013ff:	c3                   	ret    

00801400 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  801400:	55                   	push   %ebp
  801401:	89 e5                	mov    %esp,%ebp
  801403:	56                   	push   %esi
  801404:	53                   	push   %ebx
  801405:	83 ec 10             	sub    $0x10,%esp
  801408:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80140b:	8b 45 08             	mov    0x8(%ebp),%eax
  80140e:	e8 0d f5 ff ff       	call   800920 <get_socket>
  801413:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801415:	85 c0                	test   %eax,%eax
  801417:	74 68                	je     801481 <lwip_listen+0x81>
  801419:	85 f6                	test   %esi,%esi
  80141b:	b8 00 00 00 00       	mov    $0x0,%eax
  801420:	0f 48 f0             	cmovs  %eax,%esi
  801423:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  801429:	b0 ff                	mov    $0xff,%al
  80142b:	0f 4e c6             	cmovle %esi,%eax
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80142e:	0f b6 f0             	movzbl %al,%esi
  801431:	89 74 24 04          	mov    %esi,0x4(%esp)
  801435:	8b 03                	mov    (%ebx),%eax
  801437:	89 04 24             	mov    %eax,(%esp)
  80143a:	e8 fa a3 00 00       	call   80b839 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  80143f:	84 c0                	test   %al,%al
  801441:	74 26                	je     801469 <lwip_listen+0x69>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801443:	0f be c0             	movsbl %al,%eax
  801446:	f7 d8                	neg    %eax
  801448:	ba 05 00 00 00       	mov    $0x5,%edx
  80144d:	83 f8 0e             	cmp    $0xe,%eax
  801450:	77 07                	ja     801459 <lwip_listen+0x59>
  801452:	8b 14 85 e0 22 81 00 	mov    0x8122e0(,%eax,4),%edx
  801459:	89 53 10             	mov    %edx,0x10(%ebx)
  80145c:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
    return -1;
  801462:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801467:	eb 1d                	jmp    801486 <lwip_listen+0x86>
  }

  sock_set_errno(sock, 0);
  801469:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801470:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801477:	00 00 00 
  return 0;
  80147a:	b8 00 00 00 00       	mov    $0x0,%eax
  80147f:	eb 05                	jmp    801486 <lwip_listen+0x86>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801481:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  801486:	83 c4 10             	add    $0x10,%esp
  801489:	5b                   	pop    %ebx
  80148a:	5e                   	pop    %esi
  80148b:	5d                   	pop    %ebp
  80148c:	c3                   	ret    

0080148d <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  80148d:	55                   	push   %ebp
  80148e:	89 e5                	mov    %esp,%ebp
  801490:	57                   	push   %edi
  801491:	56                   	push   %esi
  801492:	53                   	push   %ebx
  801493:	83 ec 5c             	sub    $0x5c,%esp
  801496:	8b 5d 14             	mov    0x14(%ebp),%ebx
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  801499:	8b 45 08             	mov    0x8(%ebp),%eax
  80149c:	e8 7f f4 ff ff       	call   800920 <get_socket>
  8014a1:	89 c7                	mov    %eax,%edi
  if (!sock)
  8014a3:	85 c0                	test   %eax,%eax
  8014a5:	0f 84 14 02 00 00    	je     8016bf <lwip_recvfrom+0x232>
  8014ab:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8014b1:	89 d8                	mov    %ebx,%eax
  8014b3:	83 e0 08             	and    $0x8,%eax
  8014b6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8014b9:	83 e3 01             	and    $0x1,%ebx
  8014bc:	89 5d b8             	mov    %ebx,-0x48(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8014bf:	8b 77 04             	mov    0x4(%edi),%esi
  8014c2:	85 f6                	test   %esi,%esi
  8014c4:	75 7d                	jne    801543 <lwip_recvfrom+0xb6>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8014c6:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8014ca:	75 06                	jne    8014d2 <lwip_recvfrom+0x45>
  8014cc:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  8014d0:	74 22                	je     8014f4 <lwip_recvfrom+0x67>
  8014d2:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8014d7:	75 1b                	jne    8014f4 <lwip_recvfrom+0x67>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  8014d9:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  8014e0:	c7 05 00 c2 b3 00 0b 	movl   $0xb,0xb3c200
  8014e7:	00 00 00 
        return -1;
  8014ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8014ef:	e9 d0 01 00 00       	jmp    8016c4 <lwip_recvfrom+0x237>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  8014f4:	8b 07                	mov    (%edi),%eax
  8014f6:	89 04 24             	mov    %eax,(%esp)
  8014f9:	e8 0e a4 00 00       	call   80b90c <netconn_recv>
  8014fe:	89 c6                	mov    %eax,%esi
  801500:	89 47 04             	mov    %eax,0x4(%edi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  801503:	85 c0                	test   %eax,%eax
  801505:	75 3c                	jne    801543 <lwip_recvfrom+0xb6>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801507:	8b 17                	mov    (%edi),%edx
  801509:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80150d:	74 0b                	je     80151a <lwip_recvfrom+0x8d>
  80150f:	b8 6e 00 00 00       	mov    $0x6e,%eax
  801514:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  801518:	74 17                	je     801531 <lwip_recvfrom+0xa4>
  80151a:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  80151e:	f7 da                	neg    %edx
  801520:	b8 05 00 00 00       	mov    $0x5,%eax
  801525:	83 fa 0e             	cmp    $0xe,%edx
  801528:	77 07                	ja     801531 <lwip_recvfrom+0xa4>
  80152a:	8b 04 95 e0 22 81 00 	mov    0x8122e0(,%edx,4),%eax
  801531:	89 47 10             	mov    %eax,0x10(%edi)
  801534:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
        return 0;
  801539:	b8 00 00 00 00       	mov    $0x0,%eax
  80153e:	e9 81 01 00 00       	jmp    8016c4 <lwip_recvfrom+0x237>
      }
    }

    buflen = netbuf_len(buf);
  801543:	8b 06                	mov    (%esi),%eax
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  801545:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  801549:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  80154d:	29 d3                	sub    %edx,%ebx

    if (len > buflen) {
  80154f:	0f b7 cb             	movzwl %bx,%ecx
  801552:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  801555:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  801558:	66 0f 4e 5d 10       	cmovle 0x10(%ebp),%bx
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80155d:	0f b7 cb             	movzwl %bx,%ecx
  801560:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801563:	0f b7 d2             	movzwl %dx,%edx
  801566:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80156a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80156e:	0f b7 55 c4          	movzwl -0x3c(%ebp),%edx
  801572:	03 55 0c             	add    0xc(%ebp),%edx
  801575:	89 54 24 04          	mov    %edx,0x4(%esp)
  801579:	89 04 24             	mov    %eax,(%esp)
  80157c:	e8 fe 3f 00 00       	call   80557f <pbuf_copy_partial>

    off += copylen;
  801581:	66 01 5d c4          	add    %bx,-0x3c(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801585:	8b 07                	mov    (%edi),%eax
  801587:	89 04 24             	mov    %eax,(%esp)
  80158a:	e8 ed a0 00 00       	call   80b67c <netconn_type>
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
      }
    } else {
      done = 1;
  80158f:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801593:	83 f8 10             	cmp    $0x10,%eax
  801596:	75 1d                	jne    8015b5 <lwip_recvfrom+0x128>
      len -= copylen;
  801598:	8b 45 c0             	mov    -0x40(%ebp),%eax
  80159b:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  80159e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8015a2:	7e 11                	jle    8015b5 <lwip_recvfrom+0x128>
  8015a4:	8b 06                	mov    (%esi),%eax
  8015a6:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8015aa:	75 09                	jne    8015b5 <lwip_recvfrom+0x128>
  8015ac:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8015b1:	0f 94 45 c7          	sete   -0x39(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8015b5:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  8015b9:	75 39                	jne    8015f4 <lwip_recvfrom+0x167>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8015bb:	8b 07                	mov    (%edi),%eax
  8015bd:	83 38 10             	cmpl   $0x10,(%eax)
  8015c0:	75 13                	jne    8015d5 <lwip_recvfrom+0x148>
  8015c2:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8015c5:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8015c8:	85 c0                	test   %eax,%eax
  8015ca:	7e 09                	jle    8015d5 <lwip_recvfrom+0x148>
        sock->lastdata = buf;
  8015cc:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8015cf:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8015d3:	eb 15                	jmp    8015ea <lwip_recvfrom+0x15d>
      } else {
        sock->lastdata = NULL;
  8015d5:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  8015dc:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  8015e2:	89 34 24             	mov    %esi,(%esp)
  8015e5:	e8 42 12 00 00       	call   80282c <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  8015ea:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  8015ee:	0f 84 cb fe ff ff    	je     8014bf <lwip_recvfrom+0x32>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  8015f4:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8015f8:	0f 84 aa 00 00 00    	je     8016a8 <lwip_recvfrom+0x21b>
  8015fe:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801602:	0f 84 a0 00 00 00    	je     8016a8 <lwip_recvfrom+0x21b>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801608:	8b 07                	mov    (%edi),%eax
  80160a:	89 04 24             	mov    %eax,(%esp)
  80160d:	e8 6a a0 00 00       	call   80b67c <netconn_type>
  801612:	83 f8 10             	cmp    $0x10,%eax
  801615:	75 25                	jne    80163c <lwip_recvfrom+0x1af>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  801617:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80161e:	00 
  80161f:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801622:	89 44 24 08          	mov    %eax,0x8(%esp)
  801626:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801629:	89 44 24 04          	mov    %eax,0x4(%esp)
  80162d:	8b 07                	mov    (%edi),%eax
  80162f:	89 04 24             	mov    %eax,(%esp)
  801632:	e8 72 a0 00 00       	call   80b6a9 <netconn_getaddr>
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801637:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  80163a:	eb 0b                	jmp    801647 <lwip_recvfrom+0x1ba>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  80163c:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  80163f:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  801643:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  801647:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  80164e:	00 
  80164f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801656:	00 
  801657:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80165a:	89 04 24             	mov    %eax,(%esp)
  80165d:	e8 95 e2 00 00       	call   80f8f7 <memset>
    sin.sin_len = sizeof(sin);
  801662:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  801666:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  80166a:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80166e:	89 04 24             	mov    %eax,(%esp)
  801671:	e8 d0 66 00 00       	call   807d46 <htons>
  801676:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80167a:	8b 03                	mov    (%ebx),%eax
  80167c:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  80167f:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801682:	83 38 10             	cmpl   $0x10,(%eax)
  801685:	76 06                	jbe    80168d <lwip_recvfrom+0x200>
      *fromlen = sizeof(sin);
  801687:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    SMEMCPY(from, &sin, *fromlen);
  80168d:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801690:	8b 00                	mov    (%eax),%eax
  801692:	89 44 24 08          	mov    %eax,0x8(%esp)
  801696:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801699:	89 44 24 04          	mov    %eax,0x4(%esp)
  80169d:	8b 45 18             	mov    0x18(%ebp),%eax
  8016a0:	89 04 24             	mov    %eax,(%esp)
  8016a3:	e8 04 e3 00 00       	call   80f9ac <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8016a8:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8016af:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8016b6:	00 00 00 
  return off;
  8016b9:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8016bd:	eb 05                	jmp    8016c4 <lwip_recvfrom+0x237>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  8016bf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  8016c4:	83 c4 5c             	add    $0x5c,%esp
  8016c7:	5b                   	pop    %ebx
  8016c8:	5e                   	pop    %esi
  8016c9:	5f                   	pop    %edi
  8016ca:	5d                   	pop    %ebp
  8016cb:	c3                   	ret    

008016cc <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  8016cc:	55                   	push   %ebp
  8016cd:	89 e5                	mov    %esp,%ebp
  8016cf:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8016d2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8016d9:	00 
  8016da:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8016e1:	00 
  8016e2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8016e9:	00 
  8016ea:	8b 45 10             	mov    0x10(%ebp),%eax
  8016ed:	89 44 24 08          	mov    %eax,0x8(%esp)
  8016f1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8016f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8016f8:	8b 45 08             	mov    0x8(%ebp),%eax
  8016fb:	89 04 24             	mov    %eax,(%esp)
  8016fe:	e8 8a fd ff ff       	call   80148d <lwip_recvfrom>
}
  801703:	c9                   	leave  
  801704:	c3                   	ret    

00801705 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  801705:	55                   	push   %ebp
  801706:	89 e5                	mov    %esp,%ebp
  801708:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  80170b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  801712:	00 
  801713:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80171a:	00 
  80171b:	8b 45 14             	mov    0x14(%ebp),%eax
  80171e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801722:	8b 45 10             	mov    0x10(%ebp),%eax
  801725:	89 44 24 08          	mov    %eax,0x8(%esp)
  801729:	8b 45 0c             	mov    0xc(%ebp),%eax
  80172c:	89 44 24 04          	mov    %eax,0x4(%esp)
  801730:	8b 45 08             	mov    0x8(%ebp),%eax
  801733:	89 04 24             	mov    %eax,(%esp)
  801736:	e8 52 fd ff ff       	call   80148d <lwip_recvfrom>
}
  80173b:	c9                   	leave  
  80173c:	c3                   	ret    

0080173d <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  80173d:	55                   	push   %ebp
  80173e:	89 e5                	mov    %esp,%ebp
  801740:	57                   	push   %edi
  801741:	56                   	push   %esi
  801742:	53                   	push   %ebx
  801743:	83 ec 3c             	sub    $0x3c,%esp
  801746:	8b 7d 10             	mov    0x10(%ebp),%edi
  801749:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80174c:	8b 45 08             	mov    0x8(%ebp),%eax
  80174f:	e8 cc f1 ff ff       	call   800920 <get_socket>
  801754:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801756:	85 c0                	test   %eax,%eax
  801758:	0f 84 32 01 00 00    	je     801890 <lwip_sendto+0x153>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  80175e:	8b 00                	mov    (%eax),%eax
  801760:	83 38 10             	cmpl   $0x10,(%eax)
  801763:	75 22                	jne    801787 <lwip_sendto+0x4a>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  801765:	8b 45 14             	mov    0x14(%ebp),%eax
  801768:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80176c:	89 7c 24 08          	mov    %edi,0x8(%esp)
  801770:	8b 45 0c             	mov    0xc(%ebp),%eax
  801773:	89 44 24 04          	mov    %eax,0x4(%esp)
  801777:	8b 45 08             	mov    0x8(%ebp),%eax
  80177a:	89 04 24             	mov    %eax,(%esp)
  80177d:	e8 1b 01 00 00       	call   80189d <lwip_send>
  801782:	e9 0e 01 00 00       	jmp    801895 <lwip_sendto+0x158>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  801787:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  80178d:	76 1c                	jbe    8017ab <lwip_sendto+0x6e>
  80178f:	c7 44 24 08 b8 22 81 	movl   $0x8122b8,0x8(%esp)
  801796:	00 
  801797:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  80179e:	00 
  80179f:	c7 04 24 28 22 81 00 	movl   $0x812228,(%esp)
  8017a6:	e8 8f d8 00 00       	call   80f03a <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8017ab:	85 f6                	test   %esi,%esi
  8017ad:	0f 95 c0             	setne  %al
  8017b0:	75 06                	jne    8017b8 <lwip_sendto+0x7b>
  8017b2:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8017b6:	74 28                	je     8017e0 <lwip_sendto+0xa3>
  8017b8:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8017bc:	75 06                	jne    8017c4 <lwip_sendto+0x87>
  8017be:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8017c2:	74 1c                	je     8017e0 <lwip_sendto+0xa3>
  8017c4:	c7 44 24 08 99 22 81 	movl   $0x812299,0x8(%esp)
  8017cb:	00 
  8017cc:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  8017d3:	00 
  8017d4:	c7 04 24 28 22 81 00 	movl   $0x812228,(%esp)
  8017db:	e8 5a d8 00 00       	call   80f03a <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  8017e0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8017e7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  8017ee:	84 c0                	test   %al,%al
  8017f0:	74 1e                	je     801810 <lwip_sendto+0xd3>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  8017f2:	8b 46 04             	mov    0x4(%esi),%eax
  8017f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  8017f8:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8017fc:	89 04 24             	mov    %eax,(%esp)
  8017ff:	e8 4f 65 00 00       	call   807d53 <ntohs>
    buf.addr         = &remote_addr;
  801804:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801807:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80180a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80180e:	eb 14                	jmp    801824 <lwip_sendto+0xe7>
  } else {
    remote_addr.addr = 0;
  801810:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  801817:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  80181e:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801824:	0f b7 c7             	movzwl %di,%eax
  801827:	89 44 24 08          	mov    %eax,0x8(%esp)
  80182b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80182e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801832:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801835:	89 04 24             	mov    %eax,(%esp)
  801838:	e8 0c 11 00 00       	call   802949 <netbuf_ref>
  80183d:	0f be f0             	movsbl %al,%esi
  801840:	85 f6                	test   %esi,%esi
  801842:	75 14                	jne    801858 <lwip_sendto+0x11b>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  801844:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801847:	89 44 24 04          	mov    %eax,0x4(%esp)
  80184b:	8b 03                	mov    (%ebx),%eax
  80184d:	89 04 24             	mov    %eax,(%esp)
  801850:	e8 5c a2 00 00       	call   80bab1 <netconn_send>
  801855:	0f be f0             	movsbl %al,%esi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  801858:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80185b:	85 c0                	test   %eax,%eax
  80185d:	74 08                	je     801867 <lwip_sendto+0x12a>
    pbuf_free(buf.p);
  80185f:	89 04 24             	mov    %eax,(%esp)
  801862:	e8 6d 35 00 00       	call   804dd4 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  801867:	89 f2                	mov    %esi,%edx
  801869:	f7 da                	neg    %edx
  80186b:	b8 05 00 00 00       	mov    $0x5,%eax
  801870:	83 fa 0e             	cmp    $0xe,%edx
  801873:	77 07                	ja     80187c <lwip_sendto+0x13f>
  801875:	8b 04 95 e0 22 81 00 	mov    0x8122e0(,%edx,4),%eax
  80187c:	89 43 10             	mov    %eax,0x10(%ebx)
  80187f:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
  return (err==ERR_OK?size:-1);
  801884:	85 f6                	test   %esi,%esi
  801886:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80188b:	0f 44 c7             	cmove  %edi,%eax
  80188e:	eb 05                	jmp    801895 <lwip_sendto+0x158>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  801890:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801895:	83 c4 3c             	add    $0x3c,%esp
  801898:	5b                   	pop    %ebx
  801899:	5e                   	pop    %esi
  80189a:	5f                   	pop    %edi
  80189b:	5d                   	pop    %ebp
  80189c:	c3                   	ret    

0080189d <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  80189d:	55                   	push   %ebp
  80189e:	89 e5                	mov    %esp,%ebp
  8018a0:	57                   	push   %edi
  8018a1:	56                   	push   %esi
  8018a2:	53                   	push   %ebx
  8018a3:	83 ec 2c             	sub    $0x2c,%esp
  8018a6:	8b 7d 08             	mov    0x8(%ebp),%edi
  8018a9:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  8018ac:	89 f8                	mov    %edi,%eax
  8018ae:	e8 6d f0 ff ff       	call   800920 <get_socket>
  8018b3:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8018b5:	85 c0                	test   %eax,%eax
  8018b7:	0f 84 86 00 00 00    	je     801943 <lwip_send+0xa6>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  8018bd:	8b 00                	mov    (%eax),%eax
  8018bf:	83 38 10             	cmpl   $0x10,(%eax)
  8018c2:	74 2c                	je     8018f0 <lwip_send+0x53>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8018c4:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8018cb:	00 
  8018cc:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8018d3:	00 
  8018d4:	8b 45 14             	mov    0x14(%ebp),%eax
  8018d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8018db:	89 74 24 08          	mov    %esi,0x8(%esp)
  8018df:	8b 45 0c             	mov    0xc(%ebp),%eax
  8018e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8018e6:	89 3c 24             	mov    %edi,(%esp)
  8018e9:	e8 4f fe ff ff       	call   80173d <lwip_sendto>
  8018ee:	eb 58                	jmp    801948 <lwip_send+0xab>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  8018f0:	8b 55 14             	mov    0x14(%ebp),%edx
  8018f3:	83 e2 10             	and    $0x10,%edx
  8018f6:	83 fa 01             	cmp    $0x1,%edx
  8018f9:	19 d2                	sbb    %edx,%edx
  8018fb:	83 e2 fe             	and    $0xfffffffe,%edx
  8018fe:	83 c2 03             	add    $0x3,%edx
  801901:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801905:	89 74 24 08          	mov    %esi,0x8(%esp)
  801909:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80190c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801910:	89 04 24             	mov    %eax,(%esp)
  801913:	e8 1a a2 00 00       	call   80bb32 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  801918:	0f be c8             	movsbl %al,%ecx
  80191b:	f7 d9                	neg    %ecx
  80191d:	ba 05 00 00 00       	mov    $0x5,%edx
  801922:	83 f9 0e             	cmp    $0xe,%ecx
  801925:	77 07                	ja     80192e <lwip_send+0x91>
  801927:	8b 14 8d e0 22 81 00 	mov    0x8122e0(,%ecx,4),%edx
  80192e:	89 53 10             	mov    %edx,0x10(%ebx)
  801931:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
  return (err==ERR_OK?size:-1);
  801937:	84 c0                	test   %al,%al
  801939:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80193e:	0f 44 c6             	cmove  %esi,%eax
  801941:	eb 05                	jmp    801948 <lwip_send+0xab>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801943:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801948:	83 c4 2c             	add    $0x2c,%esp
  80194b:	5b                   	pop    %ebx
  80194c:	5e                   	pop    %esi
  80194d:	5f                   	pop    %edi
  80194e:	5d                   	pop    %ebp
  80194f:	c3                   	ret    

00801950 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  801950:	55                   	push   %ebp
  801951:	89 e5                	mov    %esp,%ebp
  801953:	53                   	push   %ebx
  801954:	83 ec 14             	sub    $0x14,%esp
  801957:	8b 45 0c             	mov    0xc(%ebp),%eax
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  80195a:	83 f8 02             	cmp    $0x2,%eax
  80195d:	74 2c                	je     80198b <lwip_socket+0x3b>
  80195f:	83 f8 03             	cmp    $0x3,%eax
  801962:	74 07                	je     80196b <lwip_socket+0x1b>
  801964:	83 f8 01             	cmp    $0x1,%eax
  801967:	75 6e                	jne    8019d7 <lwip_socket+0x87>
  801969:	eb 4c                	jmp    8019b7 <lwip_socket+0x67>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  80196b:	c7 44 24 08 52 0b 80 	movl   $0x800b52,0x8(%esp)
  801972:	00 
  801973:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801977:	89 44 24 04          	mov    %eax,0x4(%esp)
  80197b:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  801982:	e8 ae 9b 00 00       	call   80b535 <netconn_new_with_proto_and_callback>
  801987:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801989:	eb 5d                	jmp    8019e8 <lwip_socket+0x98>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  80198b:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  801992:	0f 94 c0             	sete   %al
  801995:	0f b6 c0             	movzbl %al,%eax
  801998:	83 c0 20             	add    $0x20,%eax
  80199b:	c7 44 24 08 52 0b 80 	movl   $0x800b52,0x8(%esp)
  8019a2:	00 
  8019a3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8019aa:	00 
  8019ab:	89 04 24             	mov    %eax,(%esp)
  8019ae:	e8 82 9b 00 00       	call   80b535 <netconn_new_with_proto_and_callback>
  8019b3:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8019b5:	eb 31                	jmp    8019e8 <lwip_socket+0x98>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8019b7:	c7 44 24 08 52 0b 80 	movl   $0x800b52,0x8(%esp)
  8019be:	00 
  8019bf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8019c6:	00 
  8019c7:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  8019ce:	e8 62 9b 00 00       	call   80b535 <netconn_new_with_proto_and_callback>
  8019d3:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8019d5:	eb 11                	jmp    8019e8 <lwip_socket+0x98>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  8019d7:	c7 05 00 c2 b3 00 16 	movl   $0x16,0xb3c200
  8019de:	00 00 00 
    return -1;
  8019e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8019e6:	eb 47                	jmp    801a2f <lwip_socket+0xdf>
  }

  if (!conn) {
  8019e8:	85 db                	test   %ebx,%ebx
  8019ea:	75 11                	jne    8019fd <lwip_socket+0xad>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  8019ec:	c7 05 00 c2 b3 00 69 	movl   $0x69,0xb3c200
  8019f3:	00 00 00 
    return -1;
  8019f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8019fb:	eb 32                	jmp    801a2f <lwip_socket+0xdf>
  }

  i = alloc_socket(conn);
  8019fd:	89 d8                	mov    %ebx,%eax
  8019ff:	e8 d7 f2 ff ff       	call   800cdb <alloc_socket>

  if (i == -1) {
  801a04:	83 f8 ff             	cmp    $0xffffffff,%eax
  801a07:	75 19                	jne    801a22 <lwip_socket+0xd2>
    netconn_delete(conn);
  801a09:	89 1c 24             	mov    %ebx,(%esp)
  801a0c:	e8 2e 9c 00 00       	call   80b63f <netconn_delete>
    set_errno(ENFILE);
  801a11:	c7 05 00 c2 b3 00 17 	movl   $0x17,0xb3c200
  801a18:	00 00 00 
    return -1;
  801a1b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801a20:	eb 0d                	jmp    801a2f <lwip_socket+0xdf>
  }
  conn->socket = i;
  801a22:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  801a25:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801a2c:	00 00 00 
  return i;
}
  801a2f:	83 c4 14             	add    $0x14,%esp
  801a32:	5b                   	pop    %ebx
  801a33:	5d                   	pop    %ebp
  801a34:	c3                   	ret    

00801a35 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  801a35:	55                   	push   %ebp
  801a36:	89 e5                	mov    %esp,%ebp
  801a38:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  801a3b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801a42:	00 
  801a43:	8b 45 10             	mov    0x10(%ebp),%eax
  801a46:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a4a:	8b 45 0c             	mov    0xc(%ebp),%eax
  801a4d:	89 44 24 04          	mov    %eax,0x4(%esp)
  801a51:	8b 45 08             	mov    0x8(%ebp),%eax
  801a54:	89 04 24             	mov    %eax,(%esp)
  801a57:	e8 41 fe ff ff       	call   80189d <lwip_send>
}
  801a5c:	c9                   	leave  
  801a5d:	c3                   	ret    

00801a5e <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  801a5e:	55                   	push   %ebp
  801a5f:	89 e5                	mov    %esp,%ebp
  801a61:	57                   	push   %edi
  801a62:	56                   	push   %esi
  801a63:	53                   	push   %ebx
  801a64:	83 ec 4c             	sub    $0x4c,%esp
  801a67:	8b 75 0c             	mov    0xc(%ebp),%esi
  801a6a:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  801a6d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801a74:	89 75 c8             	mov    %esi,-0x38(%ebp)
  select_cb.writeset = writeset;
  801a77:	8b 45 10             	mov    0x10(%ebp),%eax
  801a7a:	89 45 cc             	mov    %eax,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  801a7d:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801a80:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  801a87:	a1 60 60 81 00       	mov    0x816060,%eax
  801a8c:	89 04 24             	mov    %eax,(%esp)
  801a8f:	e8 74 3c 00 00       	call   805708 <sys_sem_wait>

  if (readset)
  801a94:	85 f6                	test   %esi,%esi
  801a96:	74 07                	je     801a9f <lwip_select+0x41>
    lreadset = *readset;
  801a98:	8b 06                	mov    (%esi),%eax
  801a9a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801a9d:	eb 1b                	jmp    801aba <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  801a9f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801aa6:	00 
  801aa7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801aae:	00 
  801aaf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801ab2:	89 04 24             	mov    %eax,(%esp)
  801ab5:	e8 3d de 00 00       	call   80f8f7 <memset>
  if (writeset)
  801aba:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801abe:	74 0a                	je     801aca <lwip_select+0x6c>
    lwriteset = *writeset;
  801ac0:	8b 45 10             	mov    0x10(%ebp),%eax
  801ac3:	8b 00                	mov    (%eax),%eax
  801ac5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801ac8:	eb 1b                	jmp    801ae5 <lwip_select+0x87>
  else
    FD_ZERO(&lwriteset);
  801aca:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801ad1:	00 
  801ad2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801ad9:	00 
  801ada:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801add:	89 04 24             	mov    %eax,(%esp)
  801ae0:	e8 12 de 00 00       	call   80f8f7 <memset>
  if (exceptset)
  801ae5:	85 db                	test   %ebx,%ebx
  801ae7:	74 07                	je     801af0 <lwip_select+0x92>
    lexceptset = *exceptset;
  801ae9:	8b 03                	mov    (%ebx),%eax
  801aeb:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801aee:	eb 1b                	jmp    801b0b <lwip_select+0xad>
  else
    FD_ZERO(&lexceptset);
  801af0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801af7:	00 
  801af8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801aff:	00 
  801b00:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b03:	89 04 24             	mov    %eax,(%esp)
  801b06:	e8 ec dd 00 00       	call   80f8f7 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801b0b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b0e:	89 04 24             	mov    %eax,(%esp)
  801b11:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801b14:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801b17:	8b 45 08             	mov    0x8(%ebp),%eax
  801b1a:	e8 40 ee ff ff       	call   80095f <lwip_selscan>
  801b1f:	89 c7                	mov    %eax,%edi

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  801b21:	85 c0                	test   %eax,%eax
  801b23:	0f 85 fd 01 00 00    	jne    801d26 <lwip_select+0x2c8>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801b29:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801b2d:	0f 84 8f 02 00 00    	je     801dc2 <lwip_select+0x364>
  801b33:	8b 45 18             	mov    0x18(%ebp),%eax
  801b36:	83 38 00             	cmpl   $0x0,(%eax)
  801b39:	0f 85 25 02 00 00    	jne    801d64 <lwip_select+0x306>
  801b3f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801b43:	0f 85 1b 02 00 00    	jne    801d64 <lwip_select+0x306>
      sys_sem_signal(selectsem);
  801b49:	a1 60 60 81 00       	mov    0x816060,%eax
  801b4e:	89 04 24             	mov    %eax,(%esp)
  801b51:	e8 7a 8d 00 00       	call   80a8d0 <sys_sem_signal>
      if (readset)
  801b56:	85 f6                	test   %esi,%esi
  801b58:	74 18                	je     801b72 <lwip_select+0x114>
        FD_ZERO(readset);
  801b5a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b61:	00 
  801b62:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b69:	00 
  801b6a:	89 34 24             	mov    %esi,(%esp)
  801b6d:	e8 85 dd 00 00       	call   80f8f7 <memset>
      if (writeset)
  801b72:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801b76:	74 1b                	je     801b93 <lwip_select+0x135>
        FD_ZERO(writeset);
  801b78:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b7f:	00 
  801b80:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b87:	00 
  801b88:	8b 45 10             	mov    0x10(%ebp),%eax
  801b8b:	89 04 24             	mov    %eax,(%esp)
  801b8e:	e8 64 dd 00 00       	call   80f8f7 <memset>
      if (exceptset)
  801b93:	85 db                	test   %ebx,%ebx
  801b95:	74 18                	je     801baf <lwip_select+0x151>
        FD_ZERO(exceptset);
  801b97:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b9e:	00 
  801b9f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801ba6:	00 
  801ba7:	89 1c 24             	mov    %ebx,(%esp)
  801baa:	e8 48 dd 00 00       	call   80f8f7 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  801baf:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801bb6:	00 00 00 
  
      return 0;
  801bb9:	b8 00 00 00 00       	mov    $0x0,%eax
  801bbe:	e9 35 02 00 00       	jmp    801df8 <lwip_select+0x39a>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801bc3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801bc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801bca:	89 04 24             	mov    %eax,(%esp)
  801bcd:	e8 08 3d 00 00       	call   8058da <sys_sem_wait_timeout>
  801bd2:	89 c7                	mov    %eax,%edi
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  801bd4:	a1 60 60 81 00       	mov    0x816060,%eax
  801bd9:	89 04 24             	mov    %eax,(%esp)
  801bdc:	e8 27 3b 00 00       	call   805708 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801be1:	a1 68 60 81 00       	mov    0x816068,%eax
  801be6:	8d 55 c4             	lea    -0x3c(%ebp),%edx
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801be9:	89 d1                	mov    %edx,%ecx
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
  801beb:	39 d0                	cmp    %edx,%eax
  801bed:	75 1b                	jne    801c0a <lwip_select+0x1ac>
      select_cb_list = select_cb.next;
  801bef:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801bf2:	a3 68 60 81 00       	mov    %eax,0x816068
  801bf7:	eb 15                	jmp    801c0e <lwip_select+0x1b0>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801bf9:	8b 10                	mov    (%eax),%edx
  801bfb:	39 ca                	cmp    %ecx,%edx
  801bfd:	74 04                	je     801c03 <lwip_select+0x1a5>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801bff:	89 d0                	mov    %edx,%eax
  801c01:	eb 07                	jmp    801c0a <lwip_select+0x1ac>
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  801c03:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801c06:	89 10                	mov    %edx,(%eax)
          break;
  801c08:	eb 04                	jmp    801c0e <lwip_select+0x1b0>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801c0a:	85 c0                	test   %eax,%eax
  801c0c:	75 eb                	jne    801bf9 <lwip_select+0x19b>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  801c0e:	a1 60 60 81 00       	mov    0x816060,%eax
  801c13:	89 04 24             	mov    %eax,(%esp)
  801c16:	e8 b5 8c 00 00       	call   80a8d0 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  801c1b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801c1e:	89 04 24             	mov    %eax,(%esp)
  801c21:	e8 51 8a 00 00       	call   80a677 <sys_sem_free>
    if (i == 0)  {
  801c26:	85 ff                	test   %edi,%edi
  801c28:	75 6d                	jne    801c97 <lwip_select+0x239>
      /* Timeout */
      if (readset)
  801c2a:	85 f6                	test   %esi,%esi
  801c2c:	74 18                	je     801c46 <lwip_select+0x1e8>
        FD_ZERO(readset);
  801c2e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801c35:	00 
  801c36:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801c3d:	00 
  801c3e:	89 34 24             	mov    %esi,(%esp)
  801c41:	e8 b1 dc 00 00       	call   80f8f7 <memset>
      if (writeset)
  801c46:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801c4a:	74 1b                	je     801c67 <lwip_select+0x209>
        FD_ZERO(writeset);
  801c4c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801c53:	00 
  801c54:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801c5b:	00 
  801c5c:	8b 45 10             	mov    0x10(%ebp),%eax
  801c5f:	89 04 24             	mov    %eax,(%esp)
  801c62:	e8 90 dc 00 00       	call   80f8f7 <memset>
      if (exceptset)
  801c67:	85 db                	test   %ebx,%ebx
  801c69:	74 18                	je     801c83 <lwip_select+0x225>
        FD_ZERO(exceptset);
  801c6b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801c72:	00 
  801c73:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801c7a:	00 
  801c7b:	89 1c 24             	mov    %ebx,(%esp)
  801c7e:	e8 74 dc 00 00       	call   80f8f7 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801c83:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801c8a:	00 00 00 
  
      return 0;
  801c8d:	b8 00 00 00 00       	mov    $0x0,%eax
  801c92:	e9 61 01 00 00       	jmp    801df8 <lwip_select+0x39a>
    }
    
    if (readset)
  801c97:	85 f6                	test   %esi,%esi
  801c99:	74 07                	je     801ca2 <lwip_select+0x244>
      lreadset = *readset;
  801c9b:	8b 06                	mov    (%esi),%eax
  801c9d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801ca0:	eb 1b                	jmp    801cbd <lwip_select+0x25f>
    else
      FD_ZERO(&lreadset);
  801ca2:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801ca9:	00 
  801caa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801cb1:	00 
  801cb2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801cb5:	89 04 24             	mov    %eax,(%esp)
  801cb8:	e8 3a dc 00 00       	call   80f8f7 <memset>
    if (writeset)
  801cbd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801cc1:	74 0a                	je     801ccd <lwip_select+0x26f>
      lwriteset = *writeset;
  801cc3:	8b 45 10             	mov    0x10(%ebp),%eax
  801cc6:	8b 00                	mov    (%eax),%eax
  801cc8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801ccb:	eb 1b                	jmp    801ce8 <lwip_select+0x28a>
    else
      FD_ZERO(&lwriteset);
  801ccd:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801cd4:	00 
  801cd5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801cdc:	00 
  801cdd:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801ce0:	89 04 24             	mov    %eax,(%esp)
  801ce3:	e8 0f dc 00 00       	call   80f8f7 <memset>
    if (exceptset)
  801ce8:	85 db                	test   %ebx,%ebx
  801cea:	74 07                	je     801cf3 <lwip_select+0x295>
      lexceptset = *exceptset;
  801cec:	8b 03                	mov    (%ebx),%eax
  801cee:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801cf1:	eb 1b                	jmp    801d0e <lwip_select+0x2b0>
    else
      FD_ZERO(&lexceptset);
  801cf3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801cfa:	00 
  801cfb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d02:	00 
  801d03:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d06:	89 04 24             	mov    %eax,(%esp)
  801d09:	e8 e9 db 00 00       	call   80f8f7 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801d0e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d11:	89 04 24             	mov    %eax,(%esp)
  801d14:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801d17:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801d1a:	8b 45 08             	mov    0x8(%ebp),%eax
  801d1d:	e8 3d ec ff ff       	call   80095f <lwip_selscan>
  801d22:	89 c7                	mov    %eax,%edi
  801d24:	eb 0d                	jmp    801d33 <lwip_select+0x2d5>
  } else
    sys_sem_signal(selectsem);
  801d26:	a1 60 60 81 00       	mov    0x816060,%eax
  801d2b:	89 04 24             	mov    %eax,(%esp)
  801d2e:	e8 9d 8b 00 00       	call   80a8d0 <sys_sem_signal>
  
  if (readset)
  801d33:	85 f6                	test   %esi,%esi
  801d35:	74 05                	je     801d3c <lwip_select+0x2de>
    *readset = lreadset;
  801d37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801d3a:	89 06                	mov    %eax,(%esi)
  if (writeset)
  801d3c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801d40:	74 08                	je     801d4a <lwip_select+0x2ec>
    *writeset = lwriteset;
  801d42:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801d45:	8b 75 10             	mov    0x10(%ebp),%esi
  801d48:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801d4a:	85 db                	test   %ebx,%ebx
  801d4c:	74 05                	je     801d53 <lwip_select+0x2f5>
    *exceptset = lexceptset;
  801d4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801d51:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801d53:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801d5a:	00 00 00 
  
  return nready;
  801d5d:	89 f8                	mov    %edi,%eax
  801d5f:	e9 94 00 00 00       	jmp    801df8 <lwip_select+0x39a>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801d64:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801d6b:	e8 7e 88 00 00       	call   80a5ee <sys_sem_new>
  801d70:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801d73:	a1 68 60 81 00       	mov    0x816068,%eax
  801d78:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801d7b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801d7e:	a3 68 60 81 00       	mov    %eax,0x816068
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801d83:	a1 60 60 81 00       	mov    0x816060,%eax
  801d88:	89 04 24             	mov    %eax,(%esp)
  801d8b:	e8 40 8b 00 00       	call   80a8d0 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801d90:	8b 45 18             	mov    0x18(%ebp),%eax
  801d93:	69 38 e8 03 00 00    	imul   $0x3e8,(%eax),%edi
  801d99:	8b 48 04             	mov    0x4(%eax),%ecx
  801d9c:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  801da2:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801da7:	89 c8                	mov    %ecx,%eax
  801da9:	f7 ea                	imul   %edx
  801dab:	c1 fa 06             	sar    $0x6,%edx
  801dae:	c1 f9 1f             	sar    $0x1f,%ecx
  801db1:	29 ca                	sub    %ecx,%edx
      if(msectimeout == 0)
  801db3:	01 d7                	add    %edx,%edi
        msectimeout = 1;
  801db5:	b8 01 00 00 00       	mov    $0x1,%eax
  801dba:	0f 44 f8             	cmove  %eax,%edi
  801dbd:	e9 01 fe ff ff       	jmp    801bc3 <lwip_select+0x165>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801dc2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801dc9:	e8 20 88 00 00       	call   80a5ee <sys_sem_new>
  801dce:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801dd1:	a1 68 60 81 00       	mov    0x816068,%eax
  801dd6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801dd9:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801ddc:	a3 68 60 81 00       	mov    %eax,0x816068
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801de1:	a1 60 60 81 00       	mov    0x816060,%eax
  801de6:	89 04 24             	mov    %eax,(%esp)
  801de9:	e8 e2 8a 00 00       	call   80a8d0 <sys_sem_signal>
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801dee:	bf 00 00 00 00       	mov    $0x0,%edi
  801df3:	e9 cb fd ff ff       	jmp    801bc3 <lwip_select+0x165>
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
}
  801df8:	83 c4 4c             	add    $0x4c,%esp
  801dfb:	5b                   	pop    %ebx
  801dfc:	5e                   	pop    %esi
  801dfd:	5f                   	pop    %edi
  801dfe:	5d                   	pop    %ebp
  801dff:	c3                   	ret    

00801e00 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801e00:	55                   	push   %ebp
  801e01:	89 e5                	mov    %esp,%ebp
  801e03:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801e06:	8b 45 08             	mov    0x8(%ebp),%eax
  801e09:	89 04 24             	mov    %eax,(%esp)
  801e0c:	e8 b4 f4 ff ff       	call   8012c5 <lwip_close>
}
  801e11:	c9                   	leave  
  801e12:	c3                   	ret    

00801e13 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e13:	55                   	push   %ebp
  801e14:	89 e5                	mov    %esp,%ebp
  801e16:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801e19:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801e20:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e23:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e26:	8b 45 08             	mov    0x8(%ebp),%eax
  801e29:	e8 64 ec ff ff       	call   800a92 <lwip_getaddrname>
}
  801e2e:	c9                   	leave  
  801e2f:	c3                   	ret    

00801e30 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e30:	55                   	push   %ebp
  801e31:	89 e5                	mov    %esp,%ebp
  801e33:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801e36:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801e3d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e40:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e43:	8b 45 08             	mov    0x8(%ebp),%eax
  801e46:	e8 47 ec ff ff       	call   800a92 <lwip_getaddrname>
}
  801e4b:	c9                   	leave  
  801e4c:	c3                   	ret    

00801e4d <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801e4d:	55                   	push   %ebp
  801e4e:	89 e5                	mov    %esp,%ebp
  801e50:	57                   	push   %edi
  801e51:	56                   	push   %esi
  801e52:	53                   	push   %ebx
  801e53:	83 ec 3c             	sub    $0x3c,%esp
  801e56:	8b 75 0c             	mov    0xc(%ebp),%esi
  801e59:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801e5c:	8b 45 08             	mov    0x8(%ebp),%eax
  801e5f:	e8 bc ea ff ff       	call   800920 <get_socket>
  801e64:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801e66:	85 c0                	test   %eax,%eax
  801e68:	0f 84 8a 01 00 00    	je     801ff8 <lwip_getsockopt+0x1ab>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801e6e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801e72:	74 04                	je     801e78 <lwip_getsockopt+0x2b>
  801e74:	85 ff                	test   %edi,%edi
  801e76:	75 1b                	jne    801e93 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801e78:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801e7f:	c7 05 00 c2 b3 00 0e 	movl   $0xe,0xb3c200
  801e86:	00 00 00 
    return -1;
  801e89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e8e:	e9 a8 01 00 00       	jmp    80203b <lwip_getsockopt+0x1ee>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801e93:	83 fe 06             	cmp    $0x6,%esi
  801e96:	0f 84 a1 00 00 00    	je     801f3d <lwip_getsockopt+0xf0>
  801e9c:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801ea2:	74 0f                	je     801eb3 <lwip_getsockopt+0x66>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801ea4:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801ea9:	85 f6                	test   %esi,%esi
  801eab:	0f 85 c9 00 00 00    	jne    801f7a <lwip_getsockopt+0x12d>
  801eb1:	eb 74                	jmp    801f27 <lwip_getsockopt+0xda>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801eb3:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801eb7:	74 3c                	je     801ef5 <lwip_getsockopt+0xa8>
  801eb9:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801ebd:	8d 76 00             	lea    0x0(%esi),%esi
  801ec0:	7f 12                	jg     801ed4 <lwip_getsockopt+0x87>
  801ec2:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801ec6:	74 2d                	je     801ef5 <lwip_getsockopt+0xa8>
  801ec8:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801ecc:	0f 85 95 00 00 00    	jne    801f67 <lwip_getsockopt+0x11a>
  801ed2:	eb 21                	jmp    801ef5 <lwip_getsockopt+0xa8>
  801ed4:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801edb:	0f 8c 86 00 00 00    	jl     801f67 <lwip_getsockopt+0x11a>
  801ee1:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801ee8:	7e 0b                	jle    801ef5 <lwip_getsockopt+0xa8>
  801eea:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801ef1:	74 12                	je     801f05 <lwip_getsockopt+0xb8>
  801ef3:	eb 72                	jmp    801f67 <lwip_getsockopt+0x11a>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801ef5:	83 3f 03             	cmpl   $0x3,(%edi)
  801ef8:	0f 86 01 01 00 00    	jbe    801fff <lwip_getsockopt+0x1b2>
  801efe:	66 90                	xchg   %ax,%ax
  801f00:	e9 8e 00 00 00       	jmp    801f93 <lwip_getsockopt+0x146>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801f05:	83 3f 04             	cmpl   $0x4,(%edi)
  801f08:	19 c0                	sbb    %eax,%eax
  801f0a:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f0d:	8b 13                	mov    (%ebx),%edx
  801f0f:	83 3a 20             	cmpl   $0x20,(%edx)
  801f12:	0f 85 f1 00 00 00    	jne    802009 <lwip_getsockopt+0x1bc>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801f18:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f1b:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801f1f:	0f 85 ee 00 00 00    	jne    802013 <lwip_getsockopt+0x1c6>
  801f25:	eb 53                	jmp    801f7a <lwip_getsockopt+0x12d>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801f27:	8b 45 10             	mov    0x10(%ebp),%eax
  801f2a:	83 e8 01             	sub    $0x1,%eax
  801f2d:	83 f8 01             	cmp    $0x1,%eax
  801f30:	77 3c                	ja     801f6e <lwip_getsockopt+0x121>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801f32:	83 3f 03             	cmpl   $0x3,(%edi)
  801f35:	0f 86 e2 00 00 00    	jbe    80201d <lwip_getsockopt+0x1d0>
  801f3b:	eb 56                	jmp    801f93 <lwip_getsockopt+0x146>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801f3d:	83 3f 03             	cmpl   $0x3,(%edi)
  801f40:	0f 86 e1 00 00 00    	jbe    802027 <lwip_getsockopt+0x1da>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801f46:	8b 10                	mov    (%eax),%edx
      return 0;
  801f48:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801f4d:	83 3a 10             	cmpl   $0x10,(%edx)
  801f50:	0f 85 e5 00 00 00    	jne    80203b <lwip_getsockopt+0x1ee>
      return 0;

    switch (optname) {
  801f56:	8b 45 10             	mov    0x10(%ebp),%eax
  801f59:	83 e8 01             	sub    $0x1,%eax
  801f5c:	83 f8 01             	cmp    $0x1,%eax
  801f5f:	0f 87 cc 00 00 00    	ja     802031 <lwip_getsockopt+0x1e4>
  801f65:	eb 0e                	jmp    801f75 <lwip_getsockopt+0x128>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801f67:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f6c:	eb 0c                	jmp    801f7a <lwip_getsockopt+0x12d>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801f6e:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f73:	eb 05                	jmp    801f7a <lwip_getsockopt+0x12d>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801f75:	b8 00 00 00 00       	mov    $0x0,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801f7a:	84 c0                	test   %al,%al
  801f7c:	74 15                	je     801f93 <lwip_getsockopt+0x146>
    sock_set_errno(sock, err);
  801f7e:	0f be c0             	movsbl %al,%eax
  801f81:	89 43 10             	mov    %eax,0x10(%ebx)
  801f84:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  801f89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f8e:	e9 a8 00 00 00       	jmp    80203b <lwip_getsockopt+0x1ee>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801f93:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801f96:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801f99:	8b 45 10             	mov    0x10(%ebp),%eax
  801f9c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801f9f:	8b 45 14             	mov    0x14(%ebp),%eax
  801fa2:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801fa5:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801fa8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801fac:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  801fb3:	00 
  801fb4:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801fb7:	89 44 24 04          	mov    %eax,0x4(%esp)
  801fbb:	c7 04 24 84 0d 80 00 	movl   $0x800d84,(%esp)
  801fc2:	e8 4c 06 00 00       	call   802613 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801fc7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801fce:	00 
  801fcf:	8b 03                	mov    (%ebx),%eax
  801fd1:	8b 40 10             	mov    0x10(%eax),%eax
  801fd4:	89 04 24             	mov    %eax,(%esp)
  801fd7:	e8 69 89 00 00       	call   80a945 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  801fdc:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801fe0:	0f be d0             	movsbl %al,%edx
  801fe3:	89 53 10             	mov    %edx,0x10(%ebx)
  801fe6:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
  return err ? -1 : 0;
  801fec:	84 c0                	test   %al,%al
  801fee:	0f 95 c0             	setne  %al
  801ff1:	0f b6 c0             	movzbl %al,%eax
  801ff4:	f7 d8                	neg    %eax
  801ff6:	eb 43                	jmp    80203b <lwip_getsockopt+0x1ee>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801ff8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ffd:	eb 3c                	jmp    80203b <lwip_getsockopt+0x1ee>
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801fff:	b8 16 00 00 00       	mov    $0x16,%eax
  802004:	e9 75 ff ff ff       	jmp    801f7e <lwip_getsockopt+0x131>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  802009:	b8 61 00 00 00       	mov    $0x61,%eax
  80200e:	e9 6b ff ff ff       	jmp    801f7e <lwip_getsockopt+0x131>
  802013:	b8 61 00 00 00       	mov    $0x61,%eax
  802018:	e9 61 ff ff ff       	jmp    801f7e <lwip_getsockopt+0x131>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  80201d:	b8 16 00 00 00       	mov    $0x16,%eax
  802022:	e9 57 ff ff ff       	jmp    801f7e <lwip_getsockopt+0x131>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  802027:	b8 16 00 00 00       	mov    $0x16,%eax
  80202c:	e9 4d ff ff ff       	jmp    801f7e <lwip_getsockopt+0x131>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  802031:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802036:	e9 43 ff ff ff       	jmp    801f7e <lwip_getsockopt+0x131>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  80203b:	83 c4 3c             	add    $0x3c,%esp
  80203e:	5b                   	pop    %ebx
  80203f:	5e                   	pop    %esi
  802040:	5f                   	pop    %edi
  802041:	5d                   	pop    %ebp
  802042:	c3                   	ret    

00802043 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  802043:	55                   	push   %ebp
  802044:	89 e5                	mov    %esp,%ebp
  802046:	57                   	push   %edi
  802047:	56                   	push   %esi
  802048:	53                   	push   %ebx
  802049:	83 ec 3c             	sub    $0x3c,%esp
  80204c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80204f:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  802052:	8b 45 08             	mov    0x8(%ebp),%eax
  802055:	e8 c6 e8 ff ff       	call   800920 <get_socket>
  80205a:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  80205c:	85 c0                	test   %eax,%eax
  80205e:	0f 84 50 01 00 00    	je     8021b4 <lwip_setsockopt+0x171>
    return -1;

  if (NULL == optval) {
  802064:	85 ff                	test   %edi,%edi
  802066:	75 1b                	jne    802083 <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  802068:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  80206f:	c7 05 00 c2 b3 00 0e 	movl   $0xe,0xb3c200
  802076:	00 00 00 
    return -1;
  802079:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80207e:	e9 74 01 00 00       	jmp    8021f7 <lwip_setsockopt+0x1b4>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  802083:	83 fe 06             	cmp    $0x6,%esi
  802086:	74 7e                	je     802106 <lwip_setsockopt+0xc3>
  802088:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  80208e:	74 0f                	je     80209f <lwip_setsockopt+0x5c>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  802090:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  802095:	85 f6                	test   %esi,%esi
  802097:	0f 85 a0 00 00 00    	jne    80213d <lwip_setsockopt+0xfa>
  80209d:	eb 50                	jmp    8020ef <lwip_setsockopt+0xac>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80209f:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8020a3:	74 18                	je     8020bd <lwip_setsockopt+0x7a>
  8020a5:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8020ac:	74 1e                	je     8020cc <lwip_setsockopt+0x89>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8020ae:	b8 5c 00 00 00       	mov    $0x5c,%eax
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8020b3:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8020b7:	0f 85 80 00 00 00    	jne    80213d <lwip_setsockopt+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8020bd:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8020c1:	0f 86 f4 00 00 00    	jbe    8021bb <lwip_setsockopt+0x178>
  8020c7:	e9 87 00 00 00       	jmp    802153 <lwip_setsockopt+0x110>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  8020cc:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  8020d0:	19 c0                	sbb    %eax,%eax
  8020d2:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8020d5:	8b 13                	mov    (%ebx),%edx
  8020d7:	83 3a 20             	cmpl   $0x20,(%edx)
  8020da:	0f 85 e5 00 00 00    	jne    8021c5 <lwip_setsockopt+0x182>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8020e0:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8020e3:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8020e7:	0f 85 e2 00 00 00    	jne    8021cf <lwip_setsockopt+0x18c>
  8020ed:	eb 4e                	jmp    80213d <lwip_setsockopt+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8020ef:	8b 45 10             	mov    0x10(%ebp),%eax
  8020f2:	83 e8 01             	sub    $0x1,%eax
  8020f5:	83 f8 01             	cmp    $0x1,%eax
  8020f8:	77 37                	ja     802131 <lwip_setsockopt+0xee>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  8020fa:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8020fe:	0f 86 d5 00 00 00    	jbe    8021d9 <lwip_setsockopt+0x196>
  802104:	eb 4d                	jmp    802153 <lwip_setsockopt+0x110>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  802106:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80210a:	0f 86 d3 00 00 00    	jbe    8021e3 <lwip_setsockopt+0x1a0>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  802110:	8b 10                	mov    (%eax),%edx
      return 0;
  802112:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  802117:	83 3a 10             	cmpl   $0x10,(%edx)
  80211a:	0f 85 d7 00 00 00    	jne    8021f7 <lwip_setsockopt+0x1b4>
      return 0;

    switch (optname) {
  802120:	8b 45 10             	mov    0x10(%ebp),%eax
  802123:	83 e8 01             	sub    $0x1,%eax
  802126:	83 f8 01             	cmp    $0x1,%eax
  802129:	0f 87 be 00 00 00    	ja     8021ed <lwip_setsockopt+0x1aa>
  80212f:	eb 07                	jmp    802138 <lwip_setsockopt+0xf5>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  802131:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802136:	eb 05                	jmp    80213d <lwip_setsockopt+0xfa>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  802138:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  80213d:	85 c0                	test   %eax,%eax
  80213f:	74 12                	je     802153 <lwip_setsockopt+0x110>
    sock_set_errno(sock, err);
  802141:	89 43 10             	mov    %eax,0x10(%ebx)
  802144:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  802149:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80214e:	e9 a4 00 00 00       	jmp    8021f7 <lwip_setsockopt+0x1b4>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  802153:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  802156:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  802159:	8b 45 10             	mov    0x10(%ebp),%eax
  80215c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  80215f:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  802162:	8d 45 18             	lea    0x18(%ebp),%eax
  802165:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  802168:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  80216c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  802173:	00 
  802174:	8d 45 cc             	lea    -0x34(%ebp),%eax
  802177:	89 44 24 04          	mov    %eax,0x4(%esp)
  80217b:	c7 04 24 0b 0f 80 00 	movl   $0x800f0b,(%esp)
  802182:	e8 8c 04 00 00       	call   802613 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  802187:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80218e:	00 
  80218f:	8b 03                	mov    (%ebx),%eax
  802191:	8b 40 10             	mov    0x10(%eax),%eax
  802194:	89 04 24             	mov    %eax,(%esp)
  802197:	e8 a9 87 00 00       	call   80a945 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  80219c:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  8021a0:	89 43 10             	mov    %eax,0x10(%ebx)
  8021a3:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
  return err ? -1 : 0;
  8021a8:	85 c0                	test   %eax,%eax
  8021aa:	0f 95 c0             	setne  %al
  8021ad:	0f b6 c0             	movzbl %al,%eax
  8021b0:	f7 d8                	neg    %eax
  8021b2:	eb 43                	jmp    8021f7 <lwip_setsockopt+0x1b4>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  8021b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8021b9:	eb 3c                	jmp    8021f7 <lwip_setsockopt+0x1b4>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  8021bb:	b8 16 00 00 00       	mov    $0x16,%eax
  8021c0:	e9 7c ff ff ff       	jmp    802141 <lwip_setsockopt+0xfe>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  8021c5:	b8 61 00 00 00       	mov    $0x61,%eax
  8021ca:	e9 72 ff ff ff       	jmp    802141 <lwip_setsockopt+0xfe>
  8021cf:	b8 61 00 00 00       	mov    $0x61,%eax
  8021d4:	e9 68 ff ff ff       	jmp    802141 <lwip_setsockopt+0xfe>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  8021d9:	b8 16 00 00 00       	mov    $0x16,%eax
  8021de:	e9 5e ff ff ff       	jmp    802141 <lwip_setsockopt+0xfe>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  8021e3:	b8 16 00 00 00       	mov    $0x16,%eax
  8021e8:	e9 54 ff ff ff       	jmp    802141 <lwip_setsockopt+0xfe>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8021ed:	b8 5c 00 00 00       	mov    $0x5c,%eax
  8021f2:	e9 4a ff ff ff       	jmp    802141 <lwip_setsockopt+0xfe>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  8021f7:	83 c4 3c             	add    $0x3c,%esp
  8021fa:	5b                   	pop    %ebx
  8021fb:	5e                   	pop    %esi
  8021fc:	5f                   	pop    %edi
  8021fd:	5d                   	pop    %ebp
  8021fe:	c3                   	ret    

008021ff <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8021ff:	55                   	push   %ebp
  802200:	89 e5                	mov    %esp,%ebp
  802202:	56                   	push   %esi
  802203:	53                   	push   %ebx
  802204:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  802207:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  80220a:	8b 45 08             	mov    0x8(%ebp),%eax
  80220d:	e8 0e e7 ff ff       	call   800920 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  802212:	85 c0                	test   %eax,%eax
  802214:	0f 84 af 00 00 00    	je     8022c9 <lwip_ioctl+0xca>
    return -1;

  switch (cmd) {
  80221a:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  802220:	74 60                	je     802282 <lwip_ioctl+0x83>
  802222:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  802228:	0f 85 83 00 00 00    	jne    8022b1 <lwip_ioctl+0xb2>
  case FIONREAD:
    if (!argp) {
  80222e:	85 f6                	test   %esi,%esi
  802230:	75 1b                	jne    80224d <lwip_ioctl+0x4e>
      sock_set_errno(sock, EINVAL);
  802232:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  802239:	c7 05 00 c2 b3 00 16 	movl   $0x16,0xb3c200
  802240:	00 00 00 
      return -1;
  802243:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802248:	e9 81 00 00 00       	jmp    8022ce <lwip_ioctl+0xcf>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80224d:	8b 10                	mov    (%eax),%edx
  80224f:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  802253:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  802256:	8b 48 04             	mov    0x4(%eax),%ecx
  802259:	85 c9                	test   %ecx,%ecx
  80225b:	74 0d                	je     80226a <lwip_ioctl+0x6b>
      buflen = netbuf_len(sock->lastdata);
  80225d:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;
  80225f:	66 03 51 08          	add    0x8(%ecx),%dx

      *((u16_t*)argp) += buflen;
  802263:	66 2b 50 08          	sub    0x8(%eax),%dx
  802267:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  80226a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802271:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  802278:	00 00 00 
    return 0;
  80227b:	b8 00 00 00 00       	mov    $0x0,%eax
  802280:	eb 4c                	jmp    8022ce <lwip_ioctl+0xcf>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  802282:	85 f6                	test   %esi,%esi
  802284:	74 0d                	je     802293 <lwip_ioctl+0x94>
  802286:	83 3e 00             	cmpl   $0x0,(%esi)
  802289:	74 08                	je     802293 <lwip_ioctl+0x94>
      sock->flags |= O_NONBLOCK;
  80228b:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  802291:	eb 06                	jmp    802299 <lwip_ioctl+0x9a>
    else
      sock->flags &= ~O_NONBLOCK;
  802293:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  802299:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8022a0:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8022a7:	00 00 00 
    return 0;
  8022aa:	b8 00 00 00 00       	mov    $0x0,%eax
  8022af:	eb 1d                	jmp    8022ce <lwip_ioctl+0xcf>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  8022b1:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  8022b8:	c7 05 00 c2 b3 00 26 	movl   $0x26,0xb3c200
  8022bf:	00 00 00 
    return -1;
  8022c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022c7:	eb 05                	jmp    8022ce <lwip_ioctl+0xcf>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  8022c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  8022ce:	5b                   	pop    %ebx
  8022cf:	5e                   	pop    %esi
  8022d0:	5d                   	pop    %ebp
  8022d1:	c3                   	ret    
  8022d2:	66 90                	xchg   %ax,%ax
  8022d4:	66 90                	xchg   %ax,%ax
  8022d6:	66 90                	xchg   %ax,%ax
  8022d8:	66 90                	xchg   %ax,%ax
  8022da:	66 90                	xchg   %ax,%ax
  8022dc:	66 90                	xchg   %ax,%ax
  8022de:	66 90                	xchg   %ax,%ax

008022e0 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  8022e0:	55                   	push   %ebp
  8022e1:	89 e5                	mov    %esp,%ebp
  8022e3:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  8022e6:	e8 15 44 00 00       	call   806700 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8022eb:	83 3d 5c c2 b3 00 00 	cmpl   $0x0,0xb3c25c
  8022f2:	75 09                	jne    8022fd <tcpip_tcp_timer+0x1d>
  8022f4:	83 3d 70 c2 b3 00 00 	cmpl   $0x0,0xb3c270
  8022fb:	74 1e                	je     80231b <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8022fd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802304:	00 
  802305:	c7 44 24 04 e0 22 80 	movl   $0x8022e0,0x4(%esp)
  80230c:	00 
  80230d:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  802314:	e8 7c 34 00 00       	call   805795 <sys_timeout>
  802319:	eb 0a                	jmp    802325 <tcpip_tcp_timer+0x45>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  80231b:	c7 05 00 63 81 00 00 	movl   $0x0,0x816300
  802322:	00 00 00 
  }
}
  802325:	c9                   	leave  
  802326:	c3                   	ret    

00802327 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  802327:	55                   	push   %ebp
  802328:	89 e5                	mov    %esp,%ebp
  80232a:	53                   	push   %ebx
  80232b:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80232e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802335:	00 
  802336:	c7 44 24 04 16 25 80 	movl   $0x802516,0x4(%esp)
  80233d:	00 
  80233e:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  802345:	e8 4b 34 00 00       	call   805795 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80234a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802351:	00 
  802352:	c7 44 24 04 ed 24 80 	movl   $0x8024ed,0x4(%esp)
  802359:	00 
  80235a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  802361:	e8 2f 34 00 00       	call   805795 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802366:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80236d:	00 
  80236e:	c7 44 24 04 c4 24 80 	movl   $0x8024c4,0x4(%esp)
  802375:	00 
  802376:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80237d:	e8 13 34 00 00       	call   805795 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802382:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802389:	00 
  80238a:	c7 44 24 04 9b 24 80 	movl   $0x80249b,0x4(%esp)
  802391:	00 
  802392:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  802399:	e8 f7 33 00 00       	call   805795 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80239e:	a1 08 63 81 00       	mov    0x816308,%eax
  8023a3:	85 c0                	test   %eax,%eax
  8023a5:	75 05                	jne    8023ac <tcpip_thread+0x85>
    tcpip_init_done(tcpip_init_done_arg);
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8023a7:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8023aa:	eb 0d                	jmp    8023b9 <tcpip_thread+0x92>
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
    tcpip_init_done(tcpip_init_done_arg);
  8023ac:	8b 15 04 63 81 00    	mov    0x816304,%edx
  8023b2:	89 14 24             	mov    %edx,(%esp)
  8023b5:	ff d0                	call   *%eax
  8023b7:	eb ee                	jmp    8023a7 <tcpip_thread+0x80>
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8023b9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8023bd:	a1 00 50 81 00       	mov    0x815000,%eax
  8023c2:	89 04 24             	mov    %eax,(%esp)
  8023c5:	e8 a3 32 00 00       	call   80566d <sys_mbox_fetch>
    switch (msg->type) {
  8023ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8023cd:	8b 02                	mov    (%edx),%eax
  8023cf:	83 f8 01             	cmp    $0x1,%eax
  8023d2:	74 1e                	je     8023f2 <tcpip_thread+0xcb>
  8023d4:	83 f8 01             	cmp    $0x1,%eax
  8023d7:	72 0c                	jb     8023e5 <tcpip_thread+0xbe>
  8023d9:	83 f8 02             	cmp    $0x2,%eax
  8023dc:	74 52                	je     802430 <tcpip_thread+0x109>
  8023de:	83 f8 03             	cmp    $0x3,%eax
  8023e1:	74 6e                	je     802451 <tcpip_thread+0x12a>
  8023e3:	eb d4                	jmp    8023b9 <tcpip_thread+0x92>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  8023e5:	8b 42 08             	mov    0x8(%edx),%eax
  8023e8:	8d 50 04             	lea    0x4(%eax),%edx
  8023eb:	89 14 24             	mov    %edx,(%esp)
  8023ee:	ff 10                	call   *(%eax)
      break;
  8023f0:	eb c7                	jmp    8023b9 <tcpip_thread+0x92>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  8023f2:	8b 42 0c             	mov    0xc(%edx),%eax
  8023f5:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  8023f9:	74 11                	je     80240c <tcpip_thread+0xe5>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  8023fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023ff:	8b 42 08             	mov    0x8(%edx),%eax
  802402:	89 04 24             	mov    %eax,(%esp)
  802405:	e8 2b 80 00 00       	call   80a435 <ethernet_input>
  80240a:	eb 0f                	jmp    80241b <tcpip_thread+0xf4>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  80240c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802410:	8b 42 08             	mov    0x8(%edx),%eax
  802413:	89 04 24             	mov    %eax,(%esp)
  802416:	e8 05 47 00 00       	call   806b20 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  80241b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80241e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802422:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  802429:	e8 f4 25 00 00       	call   804a22 <memp_free>
      break;
  80242e:	eb 89                	jmp    8023b9 <tcpip_thread+0x92>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  802430:	8b 42 0c             	mov    0xc(%edx),%eax
  802433:	89 04 24             	mov    %eax,(%esp)
  802436:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802439:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80243c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802440:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802447:	e8 d6 25 00 00       	call   804a22 <memp_free>
      break;
  80244c:	e9 68 ff ff ff       	jmp    8023b9 <tcpip_thread+0x92>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  802451:	8b 42 08             	mov    0x8(%edx),%eax
  802454:	83 f8 ff             	cmp    $0xffffffff,%eax
  802457:	74 18                	je     802471 <tcpip_thread+0x14a>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  802459:	8b 4a 10             	mov    0x10(%edx),%ecx
  80245c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  802460:	8b 52 0c             	mov    0xc(%edx),%edx
  802463:	89 54 24 04          	mov    %edx,0x4(%esp)
  802467:	89 04 24             	mov    %eax,(%esp)
  80246a:	e8 26 33 00 00       	call   805795 <sys_timeout>
  80246f:	eb 12                	jmp    802483 <tcpip_thread+0x15c>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  802471:	8b 42 10             	mov    0x10(%edx),%eax
  802474:	89 44 24 04          	mov    %eax,0x4(%esp)
  802478:	8b 42 0c             	mov    0xc(%edx),%eax
  80247b:	89 04 24             	mov    %eax,(%esp)
  80247e:	e8 cb 33 00 00       	call   80584e <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802483:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802486:	89 44 24 04          	mov    %eax,0x4(%esp)
  80248a:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802491:	e8 8c 25 00 00       	call   804a22 <memp_free>
      break;
  802496:	e9 1e ff ff ff       	jmp    8023b9 <tcpip_thread+0x92>

0080249b <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  80249b:	55                   	push   %ebp
  80249c:	89 e5                	mov    %esp,%ebp
  80249e:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8024a1:	e8 51 1d 00 00       	call   8041f7 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8024a6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024ad:	00 
  8024ae:	c7 44 24 04 9b 24 80 	movl   $0x80249b,0x4(%esp)
  8024b5:	00 
  8024b6:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8024bd:	e8 d3 32 00 00       	call   805795 <sys_timeout>
}
  8024c2:	c9                   	leave  
  8024c3:	c3                   	ret    

008024c4 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8024c4:	55                   	push   %ebp
  8024c5:	89 e5                	mov    %esp,%ebp
  8024c7:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8024ca:	e8 3f 1b 00 00       	call   80400e <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8024cf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024d6:	00 
  8024d7:	c7 44 24 04 c4 24 80 	movl   $0x8024c4,0x4(%esp)
  8024de:	00 
  8024df:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  8024e6:	e8 aa 32 00 00       	call   805795 <sys_timeout>
}
  8024eb:	c9                   	leave  
  8024ec:	c3                   	ret    

008024ed <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  8024ed:	55                   	push   %ebp
  8024ee:	89 e5                	mov    %esp,%ebp
  8024f0:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  8024f3:	e8 b8 77 00 00       	call   809cb0 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8024f8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024ff:	00 
  802500:	c7 44 24 04 ed 24 80 	movl   $0x8024ed,0x4(%esp)
  802507:	00 
  802508:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  80250f:	e8 81 32 00 00       	call   805795 <sys_timeout>
}
  802514:	c9                   	leave  
  802515:	c3                   	ret    

00802516 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  802516:	55                   	push   %ebp
  802517:	89 e5                	mov    %esp,%ebp
  802519:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  80251c:	e8 e4 4c 00 00       	call   807205 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802521:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802528:	00 
  802529:	c7 44 24 04 16 25 80 	movl   $0x802516,0x4(%esp)
  802530:	00 
  802531:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  802538:	e8 58 32 00 00       	call   805795 <sys_timeout>
}
  80253d:	c9                   	leave  
  80253e:	c3                   	ret    

0080253f <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  80253f:	55                   	push   %ebp
  802540:	89 e5                	mov    %esp,%ebp
  802542:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802545:	8b 45 08             	mov    0x8(%ebp),%eax
  802548:	89 04 24             	mov    %eax,(%esp)
  80254b:	e8 84 28 00 00       	call   804dd4 <pbuf_free>
}
  802550:	c9                   	leave  
  802551:	c3                   	ret    

00802552 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  802552:	55                   	push   %ebp
  802553:	89 e5                	mov    %esp,%ebp
  802555:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802558:	83 3d 00 63 81 00 00 	cmpl   $0x0,0x816300
  80255f:	75 38                	jne    802599 <tcp_timer_needed+0x47>
  802561:	83 3d 5c c2 b3 00 00 	cmpl   $0x0,0xb3c25c
  802568:	75 09                	jne    802573 <tcp_timer_needed+0x21>
  80256a:	83 3d 70 c2 b3 00 00 	cmpl   $0x0,0xb3c270
  802571:	74 26                	je     802599 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  802573:	c7 05 00 63 81 00 01 	movl   $0x1,0x816300
  80257a:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80257d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802584:	00 
  802585:	c7 44 24 04 e0 22 80 	movl   $0x8022e0,0x4(%esp)
  80258c:	00 
  80258d:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  802594:	e8 fc 31 00 00       	call   805795 <sys_timeout>
  }
}
  802599:	c9                   	leave  
  80259a:	c3                   	ret    

0080259b <tcpip_input>:
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80259b:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  8025a2:	74 57                	je     8025fb <tcpip_input+0x60>
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  8025a4:	55                   	push   %ebp
  8025a5:	89 e5                	mov    %esp,%ebp
  8025a7:	53                   	push   %ebx
  8025a8:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8025ab:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8025b2:	e8 0b 24 00 00       	call   8049c2 <memp_malloc>
  8025b7:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8025b9:	85 c0                	test   %eax,%eax
  8025bb:	74 44                	je     802601 <tcpip_input+0x66>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  8025bd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8025c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8025c6:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8025c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8025cc:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8025cf:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8025d3:	a1 00 50 81 00       	mov    0x815000,%eax
  8025d8:	89 04 24             	mov    %eax,(%esp)
  8025db:	e8 7c 84 00 00       	call   80aa5c <sys_mbox_trypost>
  8025e0:	84 c0                	test   %al,%al
  8025e2:	74 24                	je     802608 <tcpip_input+0x6d>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8025e4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8025e8:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8025ef:	e8 2e 24 00 00       	call   804a22 <memp_free>
      return ERR_MEM;
  8025f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8025f9:	eb 12                	jmp    80260d <tcpip_input+0x72>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  8025fb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802600:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  802601:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802606:	eb 05                	jmp    80260d <tcpip_input+0x72>
    msg->msg.inp.netif = inp;
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
      return ERR_MEM;
    }
    return ERR_OK;
  802608:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  80260d:	83 c4 14             	add    $0x14,%esp
  802610:	5b                   	pop    %ebx
  802611:	5d                   	pop    %ebp
  802612:	c3                   	ret    

00802613 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  802613:	55                   	push   %ebp
  802614:	89 e5                	mov    %esp,%ebp
  802616:	56                   	push   %esi
  802617:	53                   	push   %ebx
  802618:	83 ec 10             	sub    $0x10,%esp
  80261b:	8b 75 10             	mov    0x10(%ebp),%esi
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80261e:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  802625:	74 6e                	je     802695 <tcpip_callback_with_block+0x82>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802627:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80262e:	e8 8f 23 00 00       	call   8049c2 <memp_malloc>
  802633:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802635:	85 c0                	test   %eax,%eax
  802637:	74 63                	je     80269c <tcpip_callback_with_block+0x89>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  802639:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80263f:	8b 45 08             	mov    0x8(%ebp),%eax
  802642:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802645:	8b 45 0c             	mov    0xc(%ebp),%eax
  802648:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80264b:	89 f0                	mov    %esi,%eax
  80264d:	84 c0                	test   %al,%al
  80264f:	74 18                	je     802669 <tcpip_callback_with_block+0x56>
      sys_mbox_post(mbox, msg);
  802651:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802655:	a1 00 50 81 00       	mov    0x815000,%eax
  80265a:	89 04 24             	mov    %eax,(%esp)
  80265d:	e8 c4 84 00 00       	call   80ab26 <sys_mbox_post>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  802662:	b8 00 00 00 00       	mov    $0x0,%eax
  802667:	eb 3f                	jmp    8026a8 <tcpip_callback_with_block+0x95>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  802669:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80266d:	a1 00 50 81 00       	mov    0x815000,%eax
  802672:	89 04 24             	mov    %eax,(%esp)
  802675:	e8 e2 83 00 00       	call   80aa5c <sys_mbox_trypost>
  80267a:	84 c0                	test   %al,%al
  80267c:	74 25                	je     8026a3 <tcpip_callback_with_block+0x90>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  80267e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802682:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802689:	e8 94 23 00 00       	call   804a22 <memp_free>
        return ERR_MEM;
  80268e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802693:	eb 13                	jmp    8026a8 <tcpip_callback_with_block+0x95>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  802695:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80269a:	eb 0c                	jmp    8026a8 <tcpip_callback_with_block+0x95>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  80269c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026a1:	eb 05                	jmp    8026a8 <tcpip_callback_with_block+0x95>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  8026a3:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  8026a8:	83 c4 10             	add    $0x10,%esp
  8026ab:	5b                   	pop    %ebx
  8026ac:	5e                   	pop    %esi
  8026ad:	5d                   	pop    %ebp
  8026ae:	c3                   	ret    

008026af <tcpip_timeout>:
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8026af:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  8026b6:	74 46                	je     8026fe <tcpip_timeout+0x4f>
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8026b8:	55                   	push   %ebp
  8026b9:	89 e5                	mov    %esp,%ebp
  8026bb:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8026be:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8026c5:	e8 f8 22 00 00       	call   8049c2 <memp_malloc>
    if (msg == NULL) {
  8026ca:	85 c0                	test   %eax,%eax
  8026cc:	74 36                	je     802704 <tcpip_timeout+0x55>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  8026ce:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8026d4:	8b 55 08             	mov    0x8(%ebp),%edx
  8026d7:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8026da:	8b 55 0c             	mov    0xc(%ebp),%edx
  8026dd:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8026e0:	8b 55 10             	mov    0x10(%ebp),%edx
  8026e3:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8026e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8026ea:	a1 00 50 81 00       	mov    0x815000,%eax
  8026ef:	89 04 24             	mov    %eax,(%esp)
  8026f2:	e8 2f 84 00 00       	call   80ab26 <sys_mbox_post>
    return ERR_OK;
  8026f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8026fc:	eb 0b                	jmp    802709 <tcpip_timeout+0x5a>
  }
  return ERR_VAL;
  8026fe:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802703:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  802704:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  802709:	c9                   	leave  
  80270a:	c3                   	ret    

0080270b <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  80270b:	55                   	push   %ebp
  80270c:	89 e5                	mov    %esp,%ebp
  80270e:	53                   	push   %ebx
  80270f:	83 ec 34             	sub    $0x34,%esp
  802712:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  802715:	a1 00 50 81 00       	mov    0x815000,%eax
  80271a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80271d:	74 36                	je     802755 <tcpip_apimsg+0x4a>
    msg.type = TCPIP_MSG_API;
  80271f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802726:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802729:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80272c:	89 54 24 04          	mov    %edx,0x4(%esp)
  802730:	89 04 24             	mov    %eax,(%esp)
  802733:	e8 ee 83 00 00       	call   80ab26 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802738:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80273f:	00 
  802740:	8b 43 04             	mov    0x4(%ebx),%eax
  802743:	8b 40 10             	mov    0x10(%eax),%eax
  802746:	89 04 24             	mov    %eax,(%esp)
  802749:	e8 f7 81 00 00       	call   80a945 <sys_arch_sem_wait>
    return ERR_OK;
  80274e:	b8 00 00 00 00       	mov    $0x0,%eax
  802753:	eb 05                	jmp    80275a <tcpip_apimsg+0x4f>
  }
  return ERR_VAL;
  802755:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80275a:	83 c4 34             	add    $0x34,%esp
  80275d:	5b                   	pop    %ebx
  80275e:	5d                   	pop    %ebp
  80275f:	c3                   	ret    

00802760 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802760:	55                   	push   %ebp
  802761:	89 e5                	mov    %esp,%ebp
  802763:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  802766:	e8 f5 03 00 00       	call   802b60 <lwip_init>

  tcpip_init_done = initfunc;
  80276b:	8b 45 08             	mov    0x8(%ebp),%eax
  80276e:	a3 08 63 81 00       	mov    %eax,0x816308
  tcpip_init_done_arg = arg;
  802773:	8b 45 0c             	mov    0xc(%ebp),%eax
  802776:	a3 04 63 81 00       	mov    %eax,0x816304
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80277b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802782:	e8 2f 80 00 00       	call   80a7b6 <sys_mbox_new>
  802787:	a3 00 50 81 00       	mov    %eax,0x815000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  80278c:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  802793:	00 
  802794:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80279b:	00 
  80279c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027a3:	00 
  8027a4:	c7 44 24 04 27 23 80 	movl   $0x802327,0x4(%esp)
  8027ab:	00 
  8027ac:	c7 04 24 1c 23 81 00 	movl   $0x81231c,(%esp)
  8027b3:	e8 cc 84 00 00       	call   80ac84 <sys_thread_new>
}
  8027b8:	c9                   	leave  
  8027b9:	c3                   	ret    

008027ba <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8027ba:	55                   	push   %ebp
  8027bb:	89 e5                	mov    %esp,%ebp
  8027bd:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8027c0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027c7:	00 
  8027c8:	8b 45 08             	mov    0x8(%ebp),%eax
  8027cb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027cf:	c7 04 24 3f 25 80 00 	movl   $0x80253f,(%esp)
  8027d6:	e8 38 fe ff ff       	call   802613 <tcpip_callback_with_block>
}
  8027db:	c9                   	leave  
  8027dc:	c3                   	ret    

008027dd <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8027dd:	55                   	push   %ebp
  8027de:	89 e5                	mov    %esp,%ebp
  8027e0:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8027e3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027ea:	00 
  8027eb:	8b 45 08             	mov    0x8(%ebp),%eax
  8027ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027f2:	c7 04 24 c5 44 80 00 	movl   $0x8044c5,(%esp)
  8027f9:	e8 15 fe ff ff       	call   802613 <tcpip_callback_with_block>
}
  8027fe:	c9                   	leave  
  8027ff:	c3                   	ret    

00802800 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  802800:	55                   	push   %ebp
  802801:	89 e5                	mov    %esp,%ebp
  802803:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  802806:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80280d:	e8 b0 21 00 00       	call   8049c2 <memp_malloc>
  if (buf != NULL) {
  802812:	85 c0                	test   %eax,%eax
  802814:	74 14                	je     80282a <netbuf_new+0x2a>
    buf->p = NULL;
  802816:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80281c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  802823:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  80282a:	c9                   	leave  
  80282b:	c3                   	ret    

0080282c <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  80282c:	55                   	push   %ebp
  80282d:	89 e5                	mov    %esp,%ebp
  80282f:	53                   	push   %ebx
  802830:	83 ec 14             	sub    $0x14,%esp
  802833:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802836:	85 db                	test   %ebx,%ebx
  802838:	74 2b                	je     802865 <netbuf_delete+0x39>
    if (buf->p != NULL) {
  80283a:	8b 03                	mov    (%ebx),%eax
  80283c:	85 c0                	test   %eax,%eax
  80283e:	74 15                	je     802855 <netbuf_delete+0x29>
      pbuf_free(buf->p);
  802840:	89 04 24             	mov    %eax,(%esp)
  802843:	e8 8c 25 00 00       	call   804dd4 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802848:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80284f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  802855:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802859:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  802860:	e8 bd 21 00 00       	call   804a22 <memp_free>
  }
}
  802865:	83 c4 14             	add    $0x14,%esp
  802868:	5b                   	pop    %ebx
  802869:	5d                   	pop    %ebp
  80286a:	c3                   	ret    

0080286b <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80286b:	55                   	push   %ebp
  80286c:	89 e5                	mov    %esp,%ebp
  80286e:	56                   	push   %esi
  80286f:	53                   	push   %ebx
  802870:	83 ec 10             	sub    $0x10,%esp
  802873:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802876:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802879:	85 db                	test   %ebx,%ebx
  80287b:	75 1c                	jne    802899 <netbuf_alloc+0x2e>
  80287d:	c7 44 24 08 29 23 81 	movl   $0x812329,0x8(%esp)
  802884:	00 
  802885:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  80288c:	00 
  80288d:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  802894:	e8 a1 c7 00 00       	call   80f03a <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802899:	8b 03                	mov    (%ebx),%eax
  80289b:	85 c0                	test   %eax,%eax
  80289d:	74 08                	je     8028a7 <netbuf_alloc+0x3c>
    pbuf_free(buf->p);
  80289f:	89 04 24             	mov    %eax,(%esp)
  8028a2:	e8 2d 25 00 00       	call   804dd4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8028a7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8028ae:	00 
  8028af:	0f b7 c6             	movzwl %si,%eax
  8028b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8028b6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8028bd:	e8 f3 25 00 00       	call   804eb5 <pbuf_alloc>
  8028c2:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8028c4:	85 c0                	test   %eax,%eax
  8028c6:	74 2a                	je     8028f2 <netbuf_alloc+0x87>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8028c8:	66 3b 70 0a          	cmp    0xa(%eax),%si
  8028cc:	76 1c                	jbe    8028ea <netbuf_alloc+0x7f>
  8028ce:	c7 44 24 08 10 24 81 	movl   $0x812410,0x8(%esp)
  8028d5:	00 
  8028d6:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  8028dd:	00 
  8028de:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  8028e5:	e8 50 c7 00 00       	call   80f03a <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8028ea:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8028ed:	8b 40 04             	mov    0x4(%eax),%eax
  8028f0:	eb 05                	jmp    8028f7 <netbuf_alloc+0x8c>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  8028f2:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  8028f7:	83 c4 10             	add    $0x10,%esp
  8028fa:	5b                   	pop    %ebx
  8028fb:	5e                   	pop    %esi
  8028fc:	5d                   	pop    %ebp
  8028fd:	c3                   	ret    

008028fe <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8028fe:	55                   	push   %ebp
  8028ff:	89 e5                	mov    %esp,%ebp
  802901:	53                   	push   %ebx
  802902:	83 ec 14             	sub    $0x14,%esp
  802905:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802908:	85 db                	test   %ebx,%ebx
  80290a:	75 1c                	jne    802928 <netbuf_free+0x2a>
  80290c:	c7 44 24 08 59 23 81 	movl   $0x812359,0x8(%esp)
  802913:	00 
  802914:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  80291b:	00 
  80291c:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  802923:	e8 12 c7 00 00       	call   80f03a <_panic>
  if (buf->p != NULL) {
  802928:	8b 03                	mov    (%ebx),%eax
  80292a:	85 c0                	test   %eax,%eax
  80292c:	74 08                	je     802936 <netbuf_free+0x38>
    pbuf_free(buf->p);
  80292e:	89 04 24             	mov    %eax,(%esp)
  802931:	e8 9e 24 00 00       	call   804dd4 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  802936:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80293d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  802943:	83 c4 14             	add    $0x14,%esp
  802946:	5b                   	pop    %ebx
  802947:	5d                   	pop    %ebp
  802948:	c3                   	ret    

00802949 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802949:	55                   	push   %ebp
  80294a:	89 e5                	mov    %esp,%ebp
  80294c:	56                   	push   %esi
  80294d:	53                   	push   %ebx
  80294e:	83 ec 10             	sub    $0x10,%esp
  802951:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802954:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802957:	85 db                	test   %ebx,%ebx
  802959:	75 1c                	jne    802977 <netbuf_ref+0x2e>
  80295b:	c7 44 24 08 72 23 81 	movl   $0x812372,0x8(%esp)
  802962:	00 
  802963:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80296a:	00 
  80296b:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  802972:	e8 c3 c6 00 00       	call   80f03a <_panic>
  if (buf->p != NULL) {
  802977:	8b 03                	mov    (%ebx),%eax
  802979:	85 c0                	test   %eax,%eax
  80297b:	74 08                	je     802985 <netbuf_ref+0x3c>
    pbuf_free(buf->p);
  80297d:	89 04 24             	mov    %eax,(%esp)
  802980:	e8 4f 24 00 00       	call   804dd4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802985:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80298c:	00 
  80298d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802994:	00 
  802995:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80299c:	e8 14 25 00 00       	call   804eb5 <pbuf_alloc>
  8029a1:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8029a3:	85 c0                	test   %eax,%eax
  8029a5:	75 0e                	jne    8029b5 <netbuf_ref+0x6c>
    buf->ptr = NULL;
  8029a7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  8029ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8029b3:	eb 1a                	jmp    8029cf <netbuf_ref+0x86>
  }
  buf->p->payload = (void*)dataptr;
  8029b5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8029b8:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  8029bb:	8b 03                	mov    (%ebx),%eax
  8029bd:	66 89 70 08          	mov    %si,0x8(%eax)
  8029c1:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  8029c5:	8b 03                	mov    (%ebx),%eax
  8029c7:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  8029ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8029cf:	83 c4 10             	add    $0x10,%esp
  8029d2:	5b                   	pop    %ebx
  8029d3:	5e                   	pop    %esi
  8029d4:	5d                   	pop    %ebp
  8029d5:	c3                   	ret    

008029d6 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8029d6:	55                   	push   %ebp
  8029d7:	89 e5                	mov    %esp,%ebp
  8029d9:	56                   	push   %esi
  8029da:	53                   	push   %ebx
  8029db:	83 ec 10             	sub    $0x10,%esp
  8029de:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8029e1:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8029e4:	85 db                	test   %ebx,%ebx
  8029e6:	75 1c                	jne    802a04 <netbuf_chain+0x2e>
  8029e8:	c7 44 24 08 8a 23 81 	movl   $0x81238a,0x8(%esp)
  8029ef:	00 
  8029f0:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  8029f7:	00 
  8029f8:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  8029ff:	e8 36 c6 00 00       	call   80f03a <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802a04:	85 f6                	test   %esi,%esi
  802a06:	75 1c                	jne    802a24 <netbuf_chain+0x4e>
  802a08:	c7 44 24 08 a3 23 81 	movl   $0x8123a3,0x8(%esp)
  802a0f:	00 
  802a10:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  802a17:	00 
  802a18:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  802a1f:	e8 16 c6 00 00       	call   80f03a <_panic>
  pbuf_chain(head->p, tail->p);
  802a24:	8b 06                	mov    (%esi),%eax
  802a26:	89 44 24 04          	mov    %eax,0x4(%esp)
  802a2a:	8b 03                	mov    (%ebx),%eax
  802a2c:	89 04 24             	mov    %eax,(%esp)
  802a2f:	e8 d6 28 00 00       	call   80530a <pbuf_chain>
  head->ptr = head->p;
  802a34:	8b 03                	mov    (%ebx),%eax
  802a36:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  802a39:	89 74 24 04          	mov    %esi,0x4(%esp)
  802a3d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  802a44:	e8 d9 1f 00 00       	call   804a22 <memp_free>
}
  802a49:	83 c4 10             	add    $0x10,%esp
  802a4c:	5b                   	pop    %ebx
  802a4d:	5e                   	pop    %esi
  802a4e:	5d                   	pop    %ebp
  802a4f:	c3                   	ret    

00802a50 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  802a50:	55                   	push   %ebp
  802a51:	89 e5                	mov    %esp,%ebp
  802a53:	53                   	push   %ebx
  802a54:	83 ec 14             	sub    $0x14,%esp
  802a57:	8b 45 08             	mov    0x8(%ebp),%eax
  802a5a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802a5d:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802a60:	85 c0                	test   %eax,%eax
  802a62:	75 1c                	jne    802a80 <netbuf_data+0x30>
  802a64:	c7 44 24 08 be 23 81 	movl   $0x8123be,0x8(%esp)
  802a6b:	00 
  802a6c:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  802a73:	00 
  802a74:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  802a7b:	e8 ba c5 00 00       	call   80f03a <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802a80:	85 c9                	test   %ecx,%ecx
  802a82:	75 1c                	jne    802aa0 <netbuf_data+0x50>
  802a84:	c7 44 24 08 d7 23 81 	movl   $0x8123d7,0x8(%esp)
  802a8b:	00 
  802a8c:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  802a93:	00 
  802a94:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  802a9b:	e8 9a c5 00 00       	call   80f03a <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802aa0:	85 d2                	test   %edx,%edx
  802aa2:	75 1c                	jne    802ac0 <netbuf_data+0x70>
  802aa4:	c7 44 24 08 f4 23 81 	movl   $0x8123f4,0x8(%esp)
  802aab:	00 
  802aac:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  802ab3:	00 
  802ab4:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  802abb:	e8 7a c5 00 00       	call   80f03a <_panic>

  if (buf->ptr == NULL) {
  802ac0:	8b 58 04             	mov    0x4(%eax),%ebx
  802ac3:	85 db                	test   %ebx,%ebx
  802ac5:	74 16                	je     802add <netbuf_data+0x8d>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802ac7:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802aca:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802acc:	8b 40 04             	mov    0x4(%eax),%eax
  802acf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802ad3:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802ad6:	b8 00 00 00 00       	mov    $0x0,%eax
  802adb:	eb 05                	jmp    802ae2 <netbuf_data+0x92>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  802add:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  802ae2:	83 c4 14             	add    $0x14,%esp
  802ae5:	5b                   	pop    %ebx
  802ae6:	5d                   	pop    %ebp
  802ae7:	c3                   	ret    

00802ae8 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802ae8:	55                   	push   %ebp
  802ae9:	89 e5                	mov    %esp,%ebp
  802aeb:	83 ec 18             	sub    $0x18,%esp
  802aee:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802af1:	85 c0                	test   %eax,%eax
  802af3:	75 1c                	jne    802b11 <netbuf_next+0x29>
  802af5:	c7 44 24 08 59 23 81 	movl   $0x812359,0x8(%esp)
  802afc:	00 
  802afd:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  802b04:	00 
  802b05:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  802b0c:	e8 29 c5 00 00       	call   80f03a <_panic>
  if (buf->ptr->next == NULL) {
  802b11:	8b 50 04             	mov    0x4(%eax),%edx
  802b14:	8b 12                	mov    (%edx),%edx
  802b16:	85 d2                	test   %edx,%edx
  802b18:	74 0b                	je     802b25 <netbuf_next+0x3d>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802b1a:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  802b1d:	83 3a 00             	cmpl   $0x0,(%edx)
  802b20:	0f 94 c0             	sete   %al
  802b23:	eb 05                	jmp    802b2a <netbuf_next+0x42>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  802b25:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  802b2a:	c9                   	leave  
  802b2b:	c3                   	ret    

00802b2c <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802b2c:	55                   	push   %ebp
  802b2d:	89 e5                	mov    %esp,%ebp
  802b2f:	83 ec 18             	sub    $0x18,%esp
  802b32:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802b35:	85 c0                	test   %eax,%eax
  802b37:	75 1c                	jne    802b55 <netbuf_first+0x29>
  802b39:	c7 44 24 08 59 23 81 	movl   $0x812359,0x8(%esp)
  802b40:	00 
  802b41:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  802b48:	00 
  802b49:	c7 04 24 43 23 81 00 	movl   $0x812343,(%esp)
  802b50:	e8 e5 c4 00 00       	call   80f03a <_panic>
  buf->ptr = buf->p;
  802b55:	8b 10                	mov    (%eax),%edx
  802b57:	89 50 04             	mov    %edx,0x4(%eax)
}
  802b5a:	c9                   	leave  
  802b5b:	c3                   	ret    
  802b5c:	66 90                	xchg   %ax,%ax
  802b5e:	66 90                	xchg   %ax,%ax

00802b60 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  802b60:	55                   	push   %ebp
  802b61:	89 e5                	mov    %esp,%ebp
  802b63:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802b66:	e8 ea 79 00 00       	call   80a555 <sys_init>
  mem_init();
  802b6b:	e8 ed 18 00 00       	call   80445d <mem_init>
  memp_init();
  802b70:	e8 f5 1d 00 00       	call   80496a <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802b75:	e8 9e e4 ff ff       	call   801018 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802b7a:	c9                   	leave  
  802b7b:	c3                   	ret    
  802b7c:	66 90                	xchg   %ax,%ax
  802b7e:	66 90                	xchg   %ax,%ax

00802b80 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  802b80:	55                   	push   %ebp
  802b81:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  802b83:	38 10                	cmp    %dl,(%eax)
  802b85:	74 06                	je     802b8d <dhcp_set_state+0xd>
    dhcp->state = new_state;
  802b87:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802b89:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802b8d:	5d                   	pop    %ebp
  802b8e:	c3                   	ret    

00802b8f <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802b8f:	55                   	push   %ebp
  802b90:	89 e5                	mov    %esp,%ebp
  802b92:	57                   	push   %edi
  802b93:	56                   	push   %esi
  802b94:	53                   	push   %ebx
  802b95:	83 ec 08             	sub    $0x8,%esp
  802b98:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802b9b:	8b 70 14             	mov    0x14(%eax),%esi
  802b9e:	85 f6                	test   %esi,%esi
  802ba0:	0f 84 c9 00 00 00    	je     802c6f <dhcp_get_option_ptr+0xe0>
  802ba6:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  802baa:	66 85 ff             	test   %di,%di
  802bad:	0f 84 c3 00 00 00    	je     802c76 <dhcp_get_option_ptr+0xe7>
  802bb3:	b9 00 00 00 00       	mov    $0x0,%ecx
  802bb8:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  802bbc:	eb 2d                	jmp    802beb <dhcp_get_option_ptr+0x5c>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802bbe:	80 fb 34             	cmp    $0x34,%bl
  802bc1:	75 12                	jne    802bd5 <dhcp_get_option_ptr+0x46>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802bc3:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802bc6:	83 c1 03             	add    $0x3,%ecx
  802bc9:	0f b7 c0             	movzwl %ax,%eax
  802bcc:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802bd0:	88 45 f3             	mov    %al,-0xd(%ebp)
  802bd3:	eb 16                	jmp    802beb <dhcp_get_option_ptr+0x5c>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802bd5:	38 d3                	cmp    %dl,%bl
  802bd7:	0f 84 ac 00 00 00    	je     802c89 <dhcp_get_option_ptr+0xfa>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  802bdd:	8d 41 01             	lea    0x1(%ecx),%eax
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  802be0:	0f b7 c0             	movzwl %ax,%eax
  802be3:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802be7:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802beb:	66 39 f9             	cmp    %di,%cx
  802bee:	73 0d                	jae    802bfd <dhcp_get_option_ptr+0x6e>
  802bf0:	0f b7 c1             	movzwl %cx,%eax
  802bf3:	01 f0                	add    %esi,%eax
  802bf5:	0f b6 18             	movzbl (%eax),%ebx
  802bf8:	80 fb ff             	cmp    $0xff,%bl
  802bfb:	75 c1                	jne    802bbe <dhcp_get_option_ptr+0x2f>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  802bfd:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  802c01:	84 c0                	test   %al,%al
  802c03:	74 78                	je     802c7d <dhcp_get_option_ptr+0xee>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802c05:	3c 01                	cmp    $0x1,%al
  802c07:	75 10                	jne    802c19 <dhcp_get_option_ptr+0x8a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  802c09:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802c0c:	8b 70 10             	mov    0x10(%eax),%esi
  802c0f:	83 c6 6c             	add    $0x6c,%esi
        field_len = DHCP_FILE_LEN;
  802c12:	bf 80 00 00 00       	mov    $0x80,%edi
  802c17:	eb 24                	jmp    802c3d <dhcp_get_option_ptr+0xae>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  802c19:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
  802c1d:	75 10                	jne    802c2f <dhcp_get_option_ptr+0xa0>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802c1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802c22:	8b 70 10             	mov    0x10(%eax),%esi
  802c25:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_SNAME_LEN;
  802c28:	bf 40 00 00 00       	mov    $0x40,%edi
  802c2d:	eb 0e                	jmp    802c3d <dhcp_get_option_ptr+0xae>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802c2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802c32:	8b 70 10             	mov    0x10(%eax),%esi
  802c35:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  802c38:	bf c0 00 00 00       	mov    $0xc0,%edi
      }
      offset = 0;
  802c3d:	b9 00 00 00 00       	mov    $0x0,%ecx

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802c42:	eb 12                	jmp    802c56 <dhcp_get_option_ptr+0xc7>
        if (options[offset] == option_type) {
  802c44:	38 da                	cmp    %bl,%dl
  802c46:	74 41                	je     802c89 <dhcp_get_option_ptr+0xfa>
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  802c48:	8d 41 01             	lea    0x1(%ecx),%eax
          offset += 1 + options[offset];
  802c4b:	0f b7 c0             	movzwl %ax,%eax
  802c4e:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802c52:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802c56:	66 39 f9             	cmp    %di,%cx
  802c59:	73 29                	jae    802c84 <dhcp_get_option_ptr+0xf5>
  802c5b:	0f b7 c1             	movzwl %cx,%eax
  802c5e:	01 f0                	add    %esi,%eax
  802c60:	0f b6 18             	movzbl (%eax),%ebx
  802c63:	80 fb ff             	cmp    $0xff,%bl
  802c66:	75 dc                	jne    802c44 <dhcp_get_option_ptr+0xb5>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802c68:	b8 00 00 00 00       	mov    $0x0,%eax
  802c6d:	eb 1a                	jmp    802c89 <dhcp_get_option_ptr+0xfa>
  802c6f:	b8 00 00 00 00       	mov    $0x0,%eax
  802c74:	eb 13                	jmp    802c89 <dhcp_get_option_ptr+0xfa>
  802c76:	b8 00 00 00 00       	mov    $0x0,%eax
  802c7b:	eb 0c                	jmp    802c89 <dhcp_get_option_ptr+0xfa>
  802c7d:	b8 00 00 00 00       	mov    $0x0,%eax
  802c82:	eb 05                	jmp    802c89 <dhcp_get_option_ptr+0xfa>
  802c84:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802c89:	83 c4 08             	add    $0x8,%esp
  802c8c:	5b                   	pop    %ebx
  802c8d:	5e                   	pop    %esi
  802c8e:	5f                   	pop    %edi
  802c8f:	5d                   	pop    %ebp
  802c90:	c3                   	ret    

00802c91 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802c91:	55                   	push   %ebp
  802c92:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802c94:	0f b6 08             	movzbl (%eax),%ecx
  802c97:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802c9a:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802c9e:	c1 e2 10             	shl    $0x10,%edx
  802ca1:	09 d1                	or     %edx,%ecx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802ca3:	0f b6 50 03          	movzbl 0x3(%eax),%edx
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  802ca7:	09 d1                	or     %edx,%ecx
  802ca9:	0f b6 50 02          	movzbl 0x2(%eax),%edx
  802cad:	c1 e2 08             	shl    $0x8,%edx
  value |= (u32_t)(*ptr++);
  802cb0:	89 c8                	mov    %ecx,%eax
  802cb2:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802cb4:	5d                   	pop    %ebp
  802cb5:	c3                   	ret    

00802cb6 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  802cb6:	55                   	push   %ebp
  802cb7:	89 e5                	mov    %esp,%ebp
  802cb9:	56                   	push   %esi
  802cba:	53                   	push   %ebx
  802cbb:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802cbe:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802cc2:	66 83 f9 43          	cmp    $0x43,%cx
  802cc6:	76 1c                	jbe    802ce4 <dhcp_option_byte+0x2e>
  802cc8:	c7 44 24 08 34 24 81 	movl   $0x812434,0x8(%esp)
  802ccf:	00 
  802cd0:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  802cd7:	00 
  802cd8:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802cdf:	e8 56 c3 00 00       	call   80f03a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802ce4:	8b 58 20             	mov    0x20(%eax),%ebx
  802ce7:	8d 71 01             	lea    0x1(%ecx),%esi
  802cea:	66 89 70 24          	mov    %si,0x24(%eax)
  802cee:	0f b7 c9             	movzwl %cx,%ecx
  802cf1:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802cf8:	83 c4 10             	add    $0x10,%esp
  802cfb:	5b                   	pop    %ebx
  802cfc:	5e                   	pop    %esi
  802cfd:	5d                   	pop    %ebp
  802cfe:	c3                   	ret    

00802cff <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  802cff:	55                   	push   %ebp
  802d00:	89 e5                	mov    %esp,%ebp
  802d02:	57                   	push   %edi
  802d03:	56                   	push   %esi
  802d04:	53                   	push   %ebx
  802d05:	83 ec 1c             	sub    $0x1c,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802d08:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802d0c:	0f b7 f3             	movzwl %bx,%esi
  802d0f:	8d 74 31 02          	lea    0x2(%ecx,%esi,1),%esi
  802d13:	83 fe 44             	cmp    $0x44,%esi
  802d16:	76 1c                	jbe    802d34 <dhcp_option+0x35>
  802d18:	c7 44 24 08 70 24 81 	movl   $0x812470,0x8(%esp)
  802d1f:	00 
  802d20:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  802d27:	00 
  802d28:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802d2f:	e8 06 c3 00 00       	call   80f03a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802d34:	8b 70 20             	mov    0x20(%eax),%esi
  802d37:	8d 7b 01             	lea    0x1(%ebx),%edi
  802d3a:	66 89 78 24          	mov    %di,0x24(%eax)
  802d3e:	0f b7 db             	movzwl %bx,%ebx
  802d41:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802d48:	8b 58 20             	mov    0x20(%eax),%ebx
  802d4b:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802d4f:	8d 72 01             	lea    0x1(%edx),%esi
  802d52:	66 89 70 24          	mov    %si,0x24(%eax)
  802d56:	0f b7 d2             	movzwl %dx,%edx
  802d59:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  802d60:	83 c4 1c             	add    $0x1c,%esp
  802d63:	5b                   	pop    %ebx
  802d64:	5e                   	pop    %esi
  802d65:	5f                   	pop    %edi
  802d66:	5d                   	pop    %ebp
  802d67:	c3                   	ret    

00802d68 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  802d68:	55                   	push   %ebp
  802d69:	89 e5                	mov    %esp,%ebp
  802d6b:	56                   	push   %esi
  802d6c:	53                   	push   %ebx
  802d6d:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802d70:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802d74:	0f b7 d9             	movzwl %cx,%ebx
  802d77:	83 c3 02             	add    $0x2,%ebx
  802d7a:	83 fb 44             	cmp    $0x44,%ebx
  802d7d:	76 1c                	jbe    802d9b <dhcp_option_short+0x33>
  802d7f:	c7 44 24 08 b8 24 81 	movl   $0x8124b8,0x8(%esp)
  802d86:	00 
  802d87:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  802d8e:	00 
  802d8f:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802d96:	e8 9f c2 00 00       	call   80f03a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802d9b:	8d 71 01             	lea    0x1(%ecx),%esi
  802d9e:	66 89 70 24          	mov    %si,0x24(%eax)
  802da2:	0f b7 c9             	movzwl %cx,%ecx
  802da5:	89 d3                	mov    %edx,%ebx
  802da7:	66 c1 eb 08          	shr    $0x8,%bx
  802dab:	8b 70 20             	mov    0x20(%eax),%esi
  802dae:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802db5:	8b 58 20             	mov    0x20(%eax),%ebx
  802db8:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802dbc:	8d 71 01             	lea    0x1(%ecx),%esi
  802dbf:	66 89 70 24          	mov    %si,0x24(%eax)
  802dc3:	0f b7 c9             	movzwl %cx,%ecx
  802dc6:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802dcd:	83 c4 10             	add    $0x10,%esp
  802dd0:	5b                   	pop    %ebx
  802dd1:	5e                   	pop    %esi
  802dd2:	5d                   	pop    %ebp
  802dd3:	c3                   	ret    

00802dd4 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802dd4:	55                   	push   %ebp
  802dd5:	89 e5                	mov    %esp,%ebp
  802dd7:	53                   	push   %ebx
  802dd8:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802ddb:	85 c0                	test   %eax,%eax
  802ddd:	75 1c                	jne    802dfb <dhcp_option_trailer+0x27>
  802ddf:	c7 44 24 08 fc 24 81 	movl   $0x8124fc,0x8(%esp)
  802de6:	00 
  802de7:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  802dee:	00 
  802def:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802df6:	e8 3f c2 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802dfb:	8b 48 20             	mov    0x20(%eax),%ecx
  802dfe:	85 c9                	test   %ecx,%ecx
  802e00:	75 1c                	jne    802e1e <dhcp_option_trailer+0x4a>
  802e02:	c7 44 24 08 20 25 81 	movl   $0x812520,0x8(%esp)
  802e09:	00 
  802e0a:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  802e11:	00 
  802e12:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802e19:	e8 1c c2 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802e1e:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802e22:	66 83 fa 43          	cmp    $0x43,%dx
  802e26:	76 1c                	jbe    802e44 <dhcp_option_trailer+0x70>
  802e28:	c7 44 24 08 4c 25 81 	movl   $0x81254c,0x8(%esp)
  802e2f:	00 
  802e30:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  802e37:	00 
  802e38:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802e3f:	e8 f6 c1 00 00       	call   80f03a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802e44:	8d 5a 01             	lea    0x1(%edx),%ebx
  802e47:	66 89 58 24          	mov    %bx,0x24(%eax)
  802e4b:	0f b7 d2             	movzwl %dx,%edx
  802e4e:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802e55:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802e56:	eb 31                	jmp    802e89 <dhcp_option_trailer+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802e58:	c7 44 24 08 4c 25 81 	movl   $0x81254c,0x8(%esp)
  802e5f:	00 
  802e60:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  802e67:	00 
  802e68:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802e6f:	e8 c6 c1 00 00       	call   80f03a <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802e74:	8b 48 20             	mov    0x20(%eax),%ecx
  802e77:	8d 5a 01             	lea    0x1(%edx),%ebx
  802e7a:	66 89 58 24          	mov    %bx,0x24(%eax)
  802e7e:	0f b7 d2             	movzwl %dx,%edx
  802e81:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802e88:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802e89:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802e8d:	66 83 fa 43          	cmp    $0x43,%dx
  802e91:	76 e1                	jbe    802e74 <dhcp_option_trailer+0xa0>
  802e93:	f6 c2 03             	test   $0x3,%dl
  802e96:	75 c0                	jne    802e58 <dhcp_option_trailer+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802e98:	83 c4 14             	add    $0x14,%esp
  802e9b:	5b                   	pop    %ebx
  802e9c:	5d                   	pop    %ebp
  802e9d:	c3                   	ret    

00802e9e <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802e9e:	55                   	push   %ebp
  802e9f:	89 e5                	mov    %esp,%ebp
  802ea1:	56                   	push   %esi
  802ea2:	53                   	push   %ebx
  802ea3:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802ea6:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802eaa:	0f b7 d9             	movzwl %cx,%ebx
  802ead:	83 c3 04             	add    $0x4,%ebx
  802eb0:	83 fb 44             	cmp    $0x44,%ebx
  802eb3:	76 1c                	jbe    802ed1 <dhcp_option_long+0x33>
  802eb5:	c7 44 24 08 8c 25 81 	movl   $0x81258c,0x8(%esp)
  802ebc:	00 
  802ebd:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  802ec4:	00 
  802ec5:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802ecc:	e8 69 c1 00 00       	call   80f03a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802ed1:	8d 71 01             	lea    0x1(%ecx),%esi
  802ed4:	66 89 70 24          	mov    %si,0x24(%eax)
  802ed8:	0f b7 c9             	movzwl %cx,%ecx
  802edb:	89 d3                	mov    %edx,%ebx
  802edd:	c1 eb 18             	shr    $0x18,%ebx
  802ee0:	8b 70 20             	mov    0x20(%eax),%esi
  802ee3:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802eea:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802eee:	8d 71 01             	lea    0x1(%ecx),%esi
  802ef1:	66 89 70 24          	mov    %si,0x24(%eax)
  802ef5:	0f b7 c9             	movzwl %cx,%ecx
  802ef8:	89 d3                	mov    %edx,%ebx
  802efa:	c1 eb 10             	shr    $0x10,%ebx
  802efd:	8b 70 20             	mov    0x20(%eax),%esi
  802f00:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802f07:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802f0b:	8d 71 01             	lea    0x1(%ecx),%esi
  802f0e:	66 89 70 24          	mov    %si,0x24(%eax)
  802f12:	0f b7 c9             	movzwl %cx,%ecx
  802f15:	0f b6 de             	movzbl %dh,%ebx
  802f18:	8b 70 20             	mov    0x20(%eax),%esi
  802f1b:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802f22:	8b 58 20             	mov    0x20(%eax),%ebx
  802f25:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802f29:	8d 71 01             	lea    0x1(%ecx),%esi
  802f2c:	66 89 70 24          	mov    %si,0x24(%eax)
  802f30:	0f b7 c9             	movzwl %cx,%ecx
  802f33:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802f3a:	83 c4 10             	add    $0x10,%esp
  802f3d:	5b                   	pop    %ebx
  802f3e:	5e                   	pop    %esi
  802f3f:	5d                   	pop    %ebp
  802f40:	c3                   	ret    

00802f41 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802f41:	55                   	push   %ebp
  802f42:	89 e5                	mov    %esp,%ebp
  802f44:	57                   	push   %edi
  802f45:	56                   	push   %esi
  802f46:	53                   	push   %ebx
  802f47:	83 ec 1c             	sub    $0x1c,%esp
  802f4a:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802f4c:	85 c0                	test   %eax,%eax
  802f4e:	75 1c                	jne    802f6c <dhcp_create_request+0x2b>
  802f50:	c7 44 24 08 cc 25 81 	movl   $0x8125cc,0x8(%esp)
  802f57:	00 
  802f58:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  802f5f:	00 
  802f60:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802f67:	e8 ce c0 00 00       	call   80f03a <_panic>
  dhcp = netif->dhcp;
  802f6c:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802f6f:	85 db                	test   %ebx,%ebx
  802f71:	75 1c                	jne    802f8f <dhcp_create_request+0x4e>
  802f73:	c7 44 24 08 f0 25 81 	movl   $0x8125f0,0x8(%esp)
  802f7a:	00 
  802f7b:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  802f82:	00 
  802f83:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802f8a:	e8 ab c0 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802f8f:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802f93:	74 1c                	je     802fb1 <dhcp_create_request+0x70>
  802f95:	c7 44 24 08 14 26 81 	movl   $0x812614,0x8(%esp)
  802f9c:	00 
  802f9d:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  802fa4:	00 
  802fa5:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802fac:	e8 89 c0 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802fb1:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802fb5:	74 1c                	je     802fd3 <dhcp_create_request+0x92>
  802fb7:	c7 44 24 08 40 26 81 	movl   $0x812640,0x8(%esp)
  802fbe:	00 
  802fbf:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  802fc6:	00 
  802fc7:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  802fce:	e8 67 c0 00 00       	call   80f03a <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802fd3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802fda:	00 
  802fdb:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  802fe2:	00 
  802fe3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802fea:	e8 c6 1e 00 00       	call   804eb5 <pbuf_alloc>
  802fef:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802ff2:	85 c0                	test   %eax,%eax
  802ff4:	0f 84 2a 01 00 00    	je     803124 <dhcp_create_request+0x1e3>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802ffa:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  803000:	77 1c                	ja     80301e <dhcp_create_request+0xdd>
  803002:	c7 44 24 08 6c 26 81 	movl   $0x81266c,0x8(%esp)
  803009:	00 
  80300a:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  803011:	00 
  803012:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  803019:	e8 1c c0 00 00       	call   80f03a <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80301e:	8b 15 04 50 81 00    	mov    0x815004,%edx
  803024:	8d 4a 01             	lea    0x1(%edx),%ecx
  803027:	89 0d 04 50 81 00    	mov    %ecx,0x815004
  80302d:	89 53 04             	mov    %edx,0x4(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  803030:	8b 40 04             	mov    0x4(%eax),%eax
  803033:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  803036:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  803039:	8b 43 20             	mov    0x20(%ebx),%eax
  80303c:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  803040:	8b 43 20             	mov    0x20(%ebx),%eax
  803043:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  803047:	8b 43 20             	mov    0x20(%ebx),%eax
  80304a:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80304e:	8b 73 20             	mov    0x20(%ebx),%esi
  803051:	8b 43 04             	mov    0x4(%ebx),%eax
  803054:	89 04 24             	mov    %eax,(%esp)
  803057:	e8 04 4d 00 00       	call   807d60 <htonl>
  80305c:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  80305f:	8b 43 20             	mov    0x20(%ebx),%eax
  803062:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  803068:	8b 43 20             	mov    0x20(%ebx),%eax
  80306b:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  803071:	8b 43 20             	mov    0x20(%ebx),%eax
  803074:	8b 57 04             	mov    0x4(%edi),%edx
  803077:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  80307a:	8b 43 20             	mov    0x20(%ebx),%eax
  80307d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  803084:	8b 43 20             	mov    0x20(%ebx),%eax
  803087:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  80308e:	8b 43 20             	mov    0x20(%ebx),%eax
  803091:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  803098:	b8 00 00 00 00       	mov    $0x0,%eax
  80309d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  8030a0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8030a3:	8b 59 20             	mov    0x20(%ecx),%ebx
  8030a6:	89 c1                	mov    %eax,%ecx
  8030a8:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  8030ac:	ba 00 00 00 00       	mov    $0x0,%edx
  8030b1:	66 39 c6             	cmp    %ax,%si
  8030b4:	76 05                	jbe    8030bb <dhcp_create_request+0x17a>
  8030b6:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  8030bb:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  8030bf:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  8030c2:	83 f8 10             	cmp    $0x10,%eax
  8030c5:	75 d9                	jne    8030a0 <dhcp_create_request+0x15f>
  8030c7:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8030ca:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  8030cc:	8b 53 20             	mov    0x20(%ebx),%edx
  8030cf:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  8030d4:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  8030d7:	83 f8 40             	cmp    $0x40,%eax
  8030da:	75 f0                	jne    8030cc <dhcp_create_request+0x18b>
  8030dc:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  8030de:	8b 53 20             	mov    0x20(%ebx),%edx
  8030e1:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  8030e6:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  8030e9:	3d 80 00 00 00       	cmp    $0x80,%eax
  8030ee:	75 ee                	jne    8030de <dhcp_create_request+0x19d>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  8030f0:	8b 73 20             	mov    0x20(%ebx),%esi
  8030f3:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  8030fa:	e8 61 4c 00 00       	call   807d60 <htonl>
  8030ff:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  803105:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  80310b:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  803110:	8b 53 20             	mov    0x20(%ebx),%edx
  803113:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  80311a:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80311d:	83 f8 44             	cmp    $0x44,%eax
  803120:	75 ee                	jne    803110 <dhcp_create_request+0x1cf>
  803122:	eb 07                	jmp    80312b <dhcp_create_request+0x1ea>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  803124:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803129:	eb 05                	jmp    803130 <dhcp_create_request+0x1ef>
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80312b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803130:	83 c4 1c             	add    $0x1c,%esp
  803133:	5b                   	pop    %ebx
  803134:	5e                   	pop    %esi
  803135:	5f                   	pop    %edi
  803136:	5d                   	pop    %ebp
  803137:	c3                   	ret    

00803138 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  803138:	55                   	push   %ebp
  803139:	89 e5                	mov    %esp,%ebp
  80313b:	53                   	push   %ebx
  80313c:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80313f:	85 c0                	test   %eax,%eax
  803141:	75 1c                	jne    80315f <dhcp_delete_request+0x27>
  803143:	c7 44 24 08 b0 26 81 	movl   $0x8126b0,0x8(%esp)
  80314a:	00 
  80314b:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  803152:	00 
  803153:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  80315a:	e8 db be 00 00       	call   80f03a <_panic>
  dhcp = netif->dhcp;
  80315f:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  803162:	85 db                	test   %ebx,%ebx
  803164:	75 1c                	jne    803182 <dhcp_delete_request+0x4a>
  803166:	c7 44 24 08 d4 26 81 	movl   $0x8126d4,0x8(%esp)
  80316d:	00 
  80316e:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  803175:	00 
  803176:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  80317d:	e8 b8 be 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  803182:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803185:	85 c0                	test   %eax,%eax
  803187:	75 1c                	jne    8031a5 <dhcp_delete_request+0x6d>
  803189:	c7 44 24 08 f8 26 81 	movl   $0x8126f8,0x8(%esp)
  803190:	00 
  803191:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  803198:	00 
  803199:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  8031a0:	e8 95 be 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  8031a5:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  8031a9:	75 1c                	jne    8031c7 <dhcp_delete_request+0x8f>
  8031ab:	c7 44 24 08 24 27 81 	movl   $0x812724,0x8(%esp)
  8031b2:	00 
  8031b3:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  8031ba:	00 
  8031bb:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  8031c2:	e8 73 be 00 00       	call   80f03a <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  8031c7:	89 04 24             	mov    %eax,(%esp)
  8031ca:	e8 05 1c 00 00       	call   804dd4 <pbuf_free>
  }
  dhcp->p_out = NULL;
  8031cf:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  8031d6:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  8031dd:	83 c4 14             	add    $0x14,%esp
  8031e0:	5b                   	pop    %ebx
  8031e1:	5d                   	pop    %ebp
  8031e2:	c3                   	ret    

008031e3 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  8031e3:	55                   	push   %ebp
  8031e4:	89 e5                	mov    %esp,%ebp
  8031e6:	57                   	push   %edi
  8031e7:	56                   	push   %esi
  8031e8:	53                   	push   %ebx
  8031e9:	83 ec 2c             	sub    $0x2c,%esp
  8031ec:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8031ee:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  8031f1:	ba 04 00 00 00       	mov    $0x4,%edx
  8031f6:	89 d8                	mov    %ebx,%eax
  8031f8:	e8 83 f9 ff ff       	call   802b80 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8031fd:	89 f8                	mov    %edi,%eax
  8031ff:	e8 3d fd ff ff       	call   802f41 <dhcp_create_request>
  803204:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803206:	84 c0                	test   %al,%al
  803208:	0f 85 a3 00 00 00    	jne    8032b1 <dhcp_rebind+0xce>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80320e:	b9 01 00 00 00       	mov    $0x1,%ecx
  803213:	ba 35 00 00 00       	mov    $0x35,%edx
  803218:	89 d8                	mov    %ebx,%eax
  80321a:	e8 e0 fa ff ff       	call   802cff <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80321f:	ba 03 00 00 00       	mov    $0x3,%edx
  803224:	89 d8                	mov    %ebx,%eax
  803226:	e8 8b fa ff ff       	call   802cb6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80322b:	b9 02 00 00 00       	mov    $0x2,%ecx
  803230:	ba 39 00 00 00       	mov    $0x39,%edx
  803235:	89 d8                	mov    %ebx,%eax
  803237:	e8 c3 fa ff ff       	call   802cff <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80323c:	ba 40 02 00 00       	mov    $0x240,%edx
  803241:	89 d8                	mov    %ebx,%eax
  803243:	e8 20 fb ff ff       	call   802d68 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  803248:	89 d8                	mov    %ebx,%eax
  80324a:	e8 85 fb ff ff       	call   802dd4 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80324f:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803253:	66 05 f0 00          	add    $0xf0,%ax
  803257:	0f b7 c0             	movzwl %ax,%eax
  80325a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80325e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803261:	89 04 24             	mov    %eax,(%esp)
  803264:	e8 dd 1e 00 00       	call   805146 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803269:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803270:	00 
  803271:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  803278:	00 
  803279:	8b 43 08             	mov    0x8(%ebx),%eax
  80327c:	89 04 24             	mov    %eax,(%esp)
  80327f:	e8 81 64 00 00       	call   809705 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803284:	89 7c 24 10          	mov    %edi,0x10(%esp)
  803288:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80328f:	00 
  803290:	c7 44 24 08 3c 30 81 	movl   $0x81303c,0x8(%esp)
  803297:	00 
  803298:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80329b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80329f:	8b 43 08             	mov    0x8(%ebx),%eax
  8032a2:	89 04 24             	mov    %eax,(%esp)
  8032a5:	e8 39 62 00 00       	call   8094e3 <udp_sendto_if>
    dhcp_delete_request(netif);
  8032aa:	89 f8                	mov    %edi,%eax
  8032ac:	e8 87 fe ff ff       	call   803138 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8032b1:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8032b5:	8d 48 01             	lea    0x1(%eax),%ecx
  8032b8:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  8032bb:	b8 10 27 00 00       	mov    $0x2710,%eax
  8032c0:	80 f9 09             	cmp    $0x9,%cl
  8032c3:	77 08                	ja     8032cd <dhcp_rebind+0xea>
  8032c5:	0f b6 c9             	movzbl %cl,%ecx
  8032c8:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8032cd:	0f b7 d0             	movzwl %ax,%edx
  8032d0:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8032d6:	bf d3 4d 62 10       	mov    $0x10624dd3,%edi
  8032db:	89 d0                	mov    %edx,%eax
  8032dd:	f7 ef                	imul   %edi
  8032df:	c1 fa 05             	sar    $0x5,%edx
  8032e2:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8032e6:	89 f0                	mov    %esi,%eax
  8032e8:	83 c4 2c             	add    $0x2c,%esp
  8032eb:	5b                   	pop    %ebx
  8032ec:	5e                   	pop    %esi
  8032ed:	5f                   	pop    %edi
  8032ee:	5d                   	pop    %ebp
  8032ef:	c3                   	ret    

008032f0 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  8032f0:	55                   	push   %ebp
  8032f1:	89 e5                	mov    %esp,%ebp
  8032f3:	57                   	push   %edi
  8032f4:	56                   	push   %esi
  8032f5:	53                   	push   %ebx
  8032f6:	83 ec 2c             	sub    $0x2c,%esp
  8032f9:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8032fb:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  8032fe:	a1 40 30 81 00       	mov    0x813040,%eax
  803303:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803306:	89 f8                	mov    %edi,%eax
  803308:	e8 34 fc ff ff       	call   802f41 <dhcp_create_request>
  80330d:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80330f:	84 c0                	test   %al,%al
  803311:	0f 85 f0 00 00 00    	jne    803407 <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803317:	b9 01 00 00 00       	mov    $0x1,%ecx
  80331c:	ba 35 00 00 00       	mov    $0x35,%edx
  803321:	89 d8                	mov    %ebx,%eax
  803323:	e8 d7 f9 ff ff       	call   802cff <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  803328:	ba 01 00 00 00       	mov    $0x1,%edx
  80332d:	89 d8                	mov    %ebx,%eax
  80332f:	e8 82 f9 ff ff       	call   802cb6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803334:	b9 02 00 00 00       	mov    $0x2,%ecx
  803339:	ba 39 00 00 00       	mov    $0x39,%edx
  80333e:	89 d8                	mov    %ebx,%eax
  803340:	e8 ba f9 ff ff       	call   802cff <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803345:	ba 40 02 00 00       	mov    $0x240,%edx
  80334a:	89 d8                	mov    %ebx,%eax
  80334c:	e8 17 fa ff ff       	call   802d68 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803351:	b9 04 00 00 00       	mov    $0x4,%ecx
  803356:	ba 37 00 00 00       	mov    $0x37,%edx
  80335b:	89 d8                	mov    %ebx,%eax
  80335d:	e8 9d f9 ff ff       	call   802cff <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803362:	ba 01 00 00 00       	mov    $0x1,%edx
  803367:	89 d8                	mov    %ebx,%eax
  803369:	e8 48 f9 ff ff       	call   802cb6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80336e:	ba 03 00 00 00       	mov    $0x3,%edx
  803373:	89 d8                	mov    %ebx,%eax
  803375:	e8 3c f9 ff ff       	call   802cb6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80337a:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80337f:	89 d8                	mov    %ebx,%eax
  803381:	e8 30 f9 ff ff       	call   802cb6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803386:	ba 06 00 00 00       	mov    $0x6,%edx
  80338b:	89 d8                	mov    %ebx,%eax
  80338d:	e8 24 f9 ff ff       	call   802cb6 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  803392:	89 d8                	mov    %ebx,%eax
  803394:	e8 3b fa ff ff       	call   802dd4 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803399:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80339d:	66 05 f0 00          	add    $0xf0,%ax
  8033a1:	0f b7 c0             	movzwl %ax,%eax
  8033a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033a8:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8033ab:	89 04 24             	mov    %eax,(%esp)
  8033ae:	e8 93 1d 00 00       	call   805146 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8033b3:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8033ba:	00 
  8033bb:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  8033c2:	00 
  8033c3:	8b 43 08             	mov    0x8(%ebx),%eax
  8033c6:	89 04 24             	mov    %eax,(%esp)
  8033c9:	e8 37 63 00 00       	call   809705 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8033ce:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8033d2:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8033d9:	00 
  8033da:	c7 44 24 08 3c 30 81 	movl   $0x81303c,0x8(%esp)
  8033e1:	00 
  8033e2:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8033e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033e9:	8b 43 08             	mov    0x8(%ebx),%eax
  8033ec:	89 04 24             	mov    %eax,(%esp)
  8033ef:	e8 ef 60 00 00       	call   8094e3 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  8033f4:	89 f8                	mov    %edi,%eax
  8033f6:	e8 3d fd ff ff       	call   803138 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  8033fb:	ba 06 00 00 00       	mov    $0x6,%edx
  803400:	89 d8                	mov    %ebx,%eax
  803402:	e8 79 f7 ff ff       	call   802b80 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803407:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80340b:	8d 48 01             	lea    0x1(%eax),%ecx
  80340e:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  803411:	b8 10 27 00 00       	mov    $0x2710,%eax
  803416:	80 f9 03             	cmp    $0x3,%cl
  803419:	77 0b                	ja     803426 <dhcp_discover+0x136>
  80341b:	0f b6 c1             	movzbl %cl,%eax
  80341e:	83 c0 01             	add    $0x1,%eax
  803421:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803426:	0f b7 d0             	movzwl %ax,%edx
  803429:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80342f:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803434:	89 d0                	mov    %edx,%eax
  803436:	f7 e9                	imul   %ecx
  803438:	c1 fa 05             	sar    $0x5,%edx
  80343b:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  80343f:	89 f0                	mov    %esi,%eax
  803441:	83 c4 2c             	add    $0x2c,%esp
  803444:	5b                   	pop    %ebx
  803445:	5e                   	pop    %esi
  803446:	5f                   	pop    %edi
  803447:	5d                   	pop    %ebp
  803448:	c3                   	ret    

00803449 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  803449:	55                   	push   %ebp
  80344a:	89 e5                	mov    %esp,%ebp
  80344c:	57                   	push   %edi
  80344d:	56                   	push   %esi
  80344e:	53                   	push   %ebx
  80344f:	83 ec 2c             	sub    $0x2c,%esp
  803452:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803454:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803457:	e8 e5 fa ff ff       	call   802f41 <dhcp_create_request>
  80345c:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80345e:	84 c0                	test   %al,%al
  803460:	0f 85 3a 01 00 00    	jne    8035a0 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803466:	b9 01 00 00 00       	mov    $0x1,%ecx
  80346b:	ba 35 00 00 00       	mov    $0x35,%edx
  803470:	89 d8                	mov    %ebx,%eax
  803472:	e8 88 f8 ff ff       	call   802cff <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803477:	ba 03 00 00 00       	mov    $0x3,%edx
  80347c:	89 d8                	mov    %ebx,%eax
  80347e:	e8 33 f8 ff ff       	call   802cb6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803483:	b9 02 00 00 00       	mov    $0x2,%ecx
  803488:	ba 39 00 00 00       	mov    $0x39,%edx
  80348d:	89 d8                	mov    %ebx,%eax
  80348f:	e8 6b f8 ff ff       	call   802cff <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803494:	ba 40 02 00 00       	mov    $0x240,%edx
  803499:	89 d8                	mov    %ebx,%eax
  80349b:	e8 c8 f8 ff ff       	call   802d68 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8034a0:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034a5:	ba 32 00 00 00       	mov    $0x32,%edx
  8034aa:	89 d8                	mov    %ebx,%eax
  8034ac:	e8 4e f8 ff ff       	call   802cff <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8034b1:	8b 43 30             	mov    0x30(%ebx),%eax
  8034b4:	89 04 24             	mov    %eax,(%esp)
  8034b7:	e8 de 4a 00 00       	call   807f9a <ntohl>
  8034bc:	89 c2                	mov    %eax,%edx
  8034be:	89 d8                	mov    %ebx,%eax
  8034c0:	e8 d9 f9 ff ff       	call   802e9e <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8034c5:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034ca:	ba 36 00 00 00       	mov    $0x36,%edx
  8034cf:	89 d8                	mov    %ebx,%eax
  8034d1:	e8 29 f8 ff ff       	call   802cff <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8034d6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8034d9:	89 04 24             	mov    %eax,(%esp)
  8034dc:	e8 b9 4a 00 00       	call   807f9a <ntohl>
  8034e1:	89 c2                	mov    %eax,%edx
  8034e3:	89 d8                	mov    %ebx,%eax
  8034e5:	e8 b4 f9 ff ff       	call   802e9e <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8034ea:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034ef:	ba 37 00 00 00       	mov    $0x37,%edx
  8034f4:	89 d8                	mov    %ebx,%eax
  8034f6:	e8 04 f8 ff ff       	call   802cff <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8034fb:	ba 01 00 00 00       	mov    $0x1,%edx
  803500:	89 d8                	mov    %ebx,%eax
  803502:	e8 af f7 ff ff       	call   802cb6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803507:	ba 03 00 00 00       	mov    $0x3,%edx
  80350c:	89 d8                	mov    %ebx,%eax
  80350e:	e8 a3 f7 ff ff       	call   802cb6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803513:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803518:	89 d8                	mov    %ebx,%eax
  80351a:	e8 97 f7 ff ff       	call   802cb6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80351f:	ba 06 00 00 00       	mov    $0x6,%edx
  803524:	89 d8                	mov    %ebx,%eax
  803526:	e8 8b f7 ff ff       	call   802cb6 <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  80352b:	89 d8                	mov    %ebx,%eax
  80352d:	e8 a2 f8 ff ff       	call   802dd4 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803532:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803536:	66 05 f0 00          	add    $0xf0,%ax
  80353a:	0f b7 c0             	movzwl %ax,%eax
  80353d:	89 44 24 04          	mov    %eax,0x4(%esp)
  803541:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803544:	89 04 24             	mov    %eax,(%esp)
  803547:	e8 fa 1b 00 00       	call   805146 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80354c:	89 7c 24 10          	mov    %edi,0x10(%esp)
  803550:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803557:	00 
  803558:	c7 44 24 08 3c 30 81 	movl   $0x81303c,0x8(%esp)
  80355f:	00 
  803560:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803563:	89 44 24 04          	mov    %eax,0x4(%esp)
  803567:	8b 43 08             	mov    0x8(%ebx),%eax
  80356a:	89 04 24             	mov    %eax,(%esp)
  80356d:	e8 71 5f 00 00       	call   8094e3 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803572:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803579:	00 
  80357a:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  803581:	00 
  803582:	8b 43 08             	mov    0x8(%ebx),%eax
  803585:	89 04 24             	mov    %eax,(%esp)
  803588:	e8 78 61 00 00       	call   809705 <udp_connect>
    dhcp_delete_request(netif);
  80358d:	89 f8                	mov    %edi,%eax
  80358f:	e8 a4 fb ff ff       	call   803138 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  803594:	ba 01 00 00 00       	mov    $0x1,%edx
  803599:	89 d8                	mov    %ebx,%eax
  80359b:	e8 e0 f5 ff ff       	call   802b80 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8035a0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8035a4:	8d 48 01             	lea    0x1(%eax),%ecx
  8035a7:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8035aa:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  8035af:	80 f9 03             	cmp    $0x3,%cl
  8035b2:	77 08                	ja     8035bc <dhcp_select+0x173>
  8035b4:	0f b6 c9             	movzbl %cl,%ecx
  8035b7:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8035bc:	0f b7 d0             	movzwl %ax,%edx
  8035bf:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8035c5:	bf d3 4d 62 10       	mov    $0x10624dd3,%edi
  8035ca:	89 d0                	mov    %edx,%eax
  8035cc:	f7 ef                	imul   %edi
  8035ce:	c1 fa 05             	sar    $0x5,%edx
  8035d1:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8035d5:	89 f0                	mov    %esi,%eax
  8035d7:	83 c4 2c             	add    $0x2c,%esp
  8035da:	5b                   	pop    %ebx
  8035db:	5e                   	pop    %esi
  8035dc:	5f                   	pop    %edi
  8035dd:	5d                   	pop    %ebp
  8035de:	c3                   	ret    

008035df <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8035df:	55                   	push   %ebp
  8035e0:	89 e5                	mov    %esp,%ebp
  8035e2:	53                   	push   %ebx
  8035e3:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  8035e6:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8035e9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8035f0:	00 
  8035f1:	8d 53 30             	lea    0x30(%ebx),%edx
  8035f4:	89 54 24 04          	mov    %edx,0x4(%esp)
  8035f8:	89 04 24             	mov    %eax,(%esp)
  8035fb:	e8 d4 6a 00 00       	call   80a0d4 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  803600:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803604:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  80360a:	ba 08 00 00 00       	mov    $0x8,%edx
  80360f:	89 d8                	mov    %ebx,%eax
  803611:	e8 6a f5 ff ff       	call   802b80 <dhcp_set_state>
}
  803616:	83 c4 14             	add    $0x14,%esp
  803619:	5b                   	pop    %ebx
  80361a:	5d                   	pop    %ebp
  80361b:	c3                   	ret    

0080361c <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80361c:	55                   	push   %ebp
  80361d:	89 e5                	mov    %esp,%ebp
  80361f:	57                   	push   %edi
  803620:	56                   	push   %esi
  803621:	53                   	push   %ebx
  803622:	83 ec 2c             	sub    $0x2c,%esp
  803625:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803627:	85 c0                	test   %eax,%eax
  803629:	75 1c                	jne    803647 <dhcp_bind+0x2b>
  80362b:	c7 44 24 08 97 27 81 	movl   $0x812797,0x8(%esp)
  803632:	00 
  803633:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  80363a:	00 
  80363b:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  803642:	e8 f3 b9 00 00       	call   80f03a <_panic>
  dhcp = netif->dhcp;
  803647:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80364a:	85 db                	test   %ebx,%ebx
  80364c:	75 1c                	jne    80366a <dhcp_bind+0x4e>
  80364e:	c7 44 24 08 b0 27 81 	movl   $0x8127b0,0x8(%esp)
  803655:	00 
  803656:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  80365d:	00 
  80365e:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  803665:	e8 d0 b9 00 00       	call   80f03a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80366a:	8b 43 50             	mov    0x50(%ebx),%eax
  80366d:	83 f8 ff             	cmp    $0xffffffff,%eax
  803670:	74 2a                	je     80369c <dhcp_bind+0x80>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803672:	83 c0 1e             	add    $0x1e,%eax
  803675:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80367a:	f7 e2                	mul    %edx
  80367c:	c1 ea 05             	shr    $0x5,%edx
  80367f:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803685:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80368a:	0f 46 c2             	cmovbe %edx,%eax
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80368d:	66 85 c0             	test   %ax,%ax
  803690:	ba 01 00 00 00       	mov    $0x1,%edx
  803695:	0f 44 c2             	cmove  %edx,%eax
  803698:	66 89 43 28          	mov    %ax,0x28(%ebx)
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80369c:	8b 43 54             	mov    0x54(%ebx),%eax
  80369f:	83 f8 ff             	cmp    $0xffffffff,%eax
  8036a2:	74 2a                	je     8036ce <dhcp_bind+0xb2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8036a4:	83 c0 1e             	add    $0x1e,%eax
  8036a7:	ba 89 88 88 88       	mov    $0x88888889,%edx
  8036ac:	f7 e2                	mul    %edx
  8036ae:	c1 ea 05             	shr    $0x5,%edx
  8036b1:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8036b7:	b8 ff ff 00 00       	mov    $0xffff,%eax
  8036bc:	0f 46 c2             	cmovbe %edx,%eax
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  8036bf:	66 85 c0             	test   %ax,%ax
  8036c2:	ba 01 00 00 00       	mov    $0x1,%edx
  8036c7:	0f 44 c2             	cmove  %edx,%eax
  8036ca:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8036ce:	83 fb cc             	cmp    $0xffffffcc,%ebx
  8036d1:	0f 84 be 00 00 00    	je     803795 <dhcp_bind+0x179>
  8036d7:	8b 43 34             	mov    0x34(%ebx),%eax
  8036da:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  8036dd:	85 c0                	test   %eax,%eax
  8036df:	75 48                	jne    803729 <dhcp_bind+0x10d>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  8036e1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8036e8:	e8 ad 48 00 00       	call   807f9a <ntohl>
  8036ed:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  8036f0:	84 c0                	test   %al,%al
  8036f2:	78 11                	js     803705 <dhcp_bind+0xe9>
      sn_mask.addr = htonl(0xff000000);
  8036f4:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  8036fb:	e8 60 46 00 00       	call   807d60 <htonl>
  803700:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803703:	eb 24                	jmp    803729 <dhcp_bind+0x10d>
    } else if (first_octet >= 192) {
  803705:	3c bf                	cmp    $0xbf,%al
  803707:	76 11                	jbe    80371a <dhcp_bind+0xfe>
      sn_mask.addr = htonl(0xffffff00);
  803709:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  803710:	e8 4b 46 00 00       	call   807d60 <htonl>
  803715:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803718:	eb 0f                	jmp    803729 <dhcp_bind+0x10d>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80371a:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  803721:	e8 3a 46 00 00       	call   807d60 <htonl>
  803726:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  803729:	83 fb c8             	cmp    $0xffffffc8,%ebx
  80372c:	74 0a                	je     803738 <dhcp_bind+0x11c>
  80372e:	8b 43 38             	mov    0x38(%ebx),%eax
  803731:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  803734:	85 c0                	test   %eax,%eax
  803736:	75 1a                	jne    803752 <dhcp_bind+0x136>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  803738:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80373b:	23 7b 30             	and    0x30(%ebx),%edi
  80373e:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  803741:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803748:	e8 13 46 00 00       	call   807d60 <htonl>
  80374d:	09 c7                	or     %eax,%edi
  80374f:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  803752:	8d 43 30             	lea    0x30(%ebx),%eax
  803755:	89 44 24 04          	mov    %eax,0x4(%esp)
  803759:	89 34 24             	mov    %esi,(%esp)
  80375c:	e8 96 13 00 00       	call   804af7 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  803761:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803764:	89 44 24 04          	mov    %eax,0x4(%esp)
  803768:	89 34 24             	mov    %esi,(%esp)
  80376b:	e8 f8 14 00 00       	call   804c68 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  803770:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803773:	89 44 24 04          	mov    %eax,0x4(%esp)
  803777:	89 34 24             	mov    %esi,(%esp)
  80377a:	e8 ce 14 00 00       	call   804c4d <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  80377f:	89 34 24             	mov    %esi,(%esp)
  803782:	e8 09 15 00 00       	call   804c90 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  803787:	ba 0a 00 00 00       	mov    $0xa,%edx
  80378c:	89 d8                	mov    %ebx,%eax
  80378e:	e8 ed f3 ff ff       	call   802b80 <dhcp_set_state>
  803793:	eb 0c                	jmp    8037a1 <dhcp_bind+0x185>
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803795:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80379c:	e9 40 ff ff ff       	jmp    8036e1 <dhcp_bind+0xc5>
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
  8037a1:	83 c4 2c             	add    $0x2c,%esp
  8037a4:	5b                   	pop    %ebx
  8037a5:	5e                   	pop    %esi
  8037a6:	5f                   	pop    %edi
  8037a7:	5d                   	pop    %ebp
  8037a8:	c3                   	ret    

008037a9 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  8037a9:	55                   	push   %ebp
  8037aa:	89 e5                	mov    %esp,%ebp
  8037ac:	53                   	push   %ebx
  8037ad:	83 ec 14             	sub    $0x14,%esp
  8037b0:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  8037b2:	8b 40 10             	mov    0x10(%eax),%eax
  8037b5:	85 c0                	test   %eax,%eax
  8037b7:	74 0f                	je     8037c8 <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  8037b9:	89 04 24             	mov    %eax,(%esp)
  8037bc:	e8 04 0d 00 00       	call   8044c5 <mem_free>
    dhcp->msg_in = NULL;
  8037c1:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  8037c8:	8b 43 14             	mov    0x14(%ebx),%eax
  8037cb:	85 c0                	test   %eax,%eax
  8037cd:	74 15                	je     8037e4 <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  8037cf:	89 04 24             	mov    %eax,(%esp)
  8037d2:	e8 ee 0c 00 00       	call   8044c5 <mem_free>
    dhcp->options_in = NULL;
  8037d7:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  8037de:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  8037e4:	83 c4 14             	add    $0x14,%esp
  8037e7:	5b                   	pop    %ebx
  8037e8:	5d                   	pop    %ebp
  8037e9:	c3                   	ret    

008037ea <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  8037ea:	55                   	push   %ebp
  8037eb:	89 e5                	mov    %esp,%ebp
  8037ed:	57                   	push   %edi
  8037ee:	56                   	push   %esi
  8037ef:	53                   	push   %ebx
  8037f0:	83 ec 2c             	sub    $0x2c,%esp
  8037f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8037f6:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  8037f9:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8037fc:	8b 4f 04             	mov    0x4(%edi),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  8037ff:	89 7e 0c             	mov    %edi,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  803802:	80 39 02             	cmpb   $0x2,(%ecx)
  803805:	0f 85 10 04 00 00    	jne    803c1b <dhcp_recv+0x431>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80380b:	0f b6 43 24          	movzbl 0x24(%ebx),%eax
  80380f:	ba 00 00 00 00       	mov    $0x0,%edx
  803814:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  803817:	89 ce                	mov    %ecx,%esi
  803819:	89 c1                	mov    %eax,%ecx
  80381b:	eb 12                	jmp    80382f <dhcp_recv+0x45>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80381d:	0f b6 44 13 25       	movzbl 0x25(%ebx,%edx,1),%eax
  803822:	83 c2 01             	add    $0x1,%edx
  803825:	3a 44 16 1b          	cmp    0x1b(%esi,%edx,1),%al
  803829:	0f 85 e9 03 00 00    	jne    803c18 <dhcp_recv+0x42e>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80382f:	38 d1                	cmp    %dl,%cl
  803831:	77 ea                	ja     80381d <dhcp_recv+0x33>
  803833:	89 f1                	mov    %esi,%ecx
  803835:	8b 75 e4             	mov    -0x1c(%ebp),%esi
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  803838:	8b 41 04             	mov    0x4(%ecx),%eax
  80383b:	89 04 24             	mov    %eax,(%esp)
  80383e:	e8 57 47 00 00       	call   807f9a <ntohl>
  803843:	3b 46 04             	cmp    0x4(%esi),%eax
  803846:	0f 85 cf 03 00 00    	jne    803c1b <dhcp_recv+0x431>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80384c:	85 f6                	test   %esi,%esi
  80384e:	75 1c                	jne    80386c <dhcp_recv+0x82>
  803850:	c7 44 24 08 bb 27 81 	movl   $0x8127bb,0x8(%esp)
  803857:	00 
  803858:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  80385f:	00 
  803860:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  803867:	e8 ce b7 00 00       	call   80f03a <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80386c:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  803870:	75 1c                	jne    80388e <dhcp_recv+0xa4>
  803872:	c7 44 24 08 c8 27 81 	movl   $0x8127c8,0x8(%esp)
  803879:	00 
  80387a:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  803881:	00 
  803882:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  803889:	e8 ac b7 00 00       	call   80f03a <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80388e:	89 f0                	mov    %esi,%eax
  803890:	e8 14 ff ff ff       	call   8037a9 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  803895:	8b 46 0c             	mov    0xc(%esi),%eax
  803898:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80389c:	66 3d f0 00          	cmp    $0xf0,%ax
  8038a0:	76 1e                	jbe    8038c0 <dhcp_recv+0xd6>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8038a2:	66 2d f0 00          	sub    $0xf0,%ax
  8038a6:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8038aa:	0f b7 c0             	movzwl %ax,%eax
  8038ad:	89 04 24             	mov    %eax,(%esp)
  8038b0:	e8 ea 0e 00 00       	call   80479f <mem_malloc>
  8038b5:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  8038b8:	85 c0                	test   %eax,%eax
  8038ba:	0f 84 5b 03 00 00    	je     803c1b <dhcp_recv+0x431>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8038c0:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  8038c7:	e8 d3 0e 00 00       	call   80479f <mem_malloc>
  8038cc:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  8038cf:	85 c0                	test   %eax,%eax
  8038d1:	75 17                	jne    8038ea <dhcp_recv+0x100>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  8038d3:	8b 46 14             	mov    0x14(%esi),%eax
  8038d6:	89 04 24             	mov    %eax,(%esp)
  8038d9:	e8 e7 0b 00 00       	call   8044c5 <mem_free>
    dhcp->options_in = NULL;
  8038de:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  8038e5:	e9 31 03 00 00       	jmp    803c1b <dhcp_recv+0x431>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8038ea:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8038f1:	00 
  8038f2:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  8038f9:	00 
  8038fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  8038fe:	8b 46 0c             	mov    0xc(%esi),%eax
  803901:	89 04 24             	mov    %eax,(%esp)
  803904:	e8 76 1c 00 00       	call   80557f <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803909:	66 3d f0 00          	cmp    $0xf0,%ax
  80390d:	74 1c                	je     80392b <dhcp_recv+0x141>
  80390f:	c7 44 24 08 50 27 81 	movl   $0x812750,0x8(%esp)
  803916:	00 
  803917:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  80391e:	00 
  80391f:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  803926:	e8 0f b7 00 00       	call   80f03a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80392b:	8b 46 14             	mov    0x14(%esi),%eax
  80392e:	85 c0                	test   %eax,%eax
  803930:	0f 84 f6 02 00 00    	je     803c2c <dhcp_recv+0x442>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803936:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  80393d:	00 
  80393e:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  803942:	89 54 24 08          	mov    %edx,0x8(%esp)
  803946:	89 44 24 04          	mov    %eax,0x4(%esp)
  80394a:	8b 46 0c             	mov    0xc(%esi),%eax
  80394d:	89 04 24             	mov    %eax,(%esp)
  803950:	e8 2a 1c 00 00       	call   80557f <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803955:	66 3b 46 18          	cmp    0x18(%esi),%ax
  803959:	0f 84 cd 02 00 00    	je     803c2c <dhcp_recv+0x442>
  80395f:	c7 44 24 08 d8 27 81 	movl   $0x8127d8,0x8(%esp)
  803966:	00 
  803967:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  80396e:	00 
  80396f:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  803976:	e8 bf b6 00 00       	call   80f03a <_panic>
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80397b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80397f:	3c 05                	cmp    $0x5,%al
  803981:	0f 85 c3 01 00 00    	jne    803b4a <dhcp_recv+0x360>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  803987:	0f b6 06             	movzbl (%esi),%eax
  80398a:	3c 01                	cmp    $0x1,%al
  80398c:	0f 85 9b 01 00 00    	jne    803b2d <dhcp_recv+0x343>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803992:	8b 43 20             	mov    0x20(%ebx),%eax
  803995:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  803998:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  dhcp->offered_gw_addr.addr = 0;
  80399f:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  dhcp->offered_bc_addr.addr = 0;
  8039a6:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  8039ad:	ba 33 00 00 00       	mov    $0x33,%edx
  8039b2:	e8 d8 f1 ff ff       	call   802b8f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8039b7:	85 c0                	test   %eax,%eax
  8039b9:	74 0e                	je     8039c9 <dhcp_recv+0x1df>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  8039bb:	83 c0 02             	add    $0x2,%eax
  8039be:	e8 ce f2 ff ff       	call   802c91 <dhcp_get_option_long>
  8039c3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8039c6:	89 41 4c             	mov    %eax,0x4c(%ecx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  8039c9:	ba 3a 00 00 00       	mov    $0x3a,%edx
  8039ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8039d1:	e8 b9 f1 ff ff       	call   802b8f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8039d6:	85 c0                	test   %eax,%eax
  8039d8:	74 10                	je     8039ea <dhcp_recv+0x200>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8039da:	83 c0 02             	add    $0x2,%eax
  8039dd:	e8 af f2 ff ff       	call   802c91 <dhcp_get_option_long>
  8039e2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8039e5:	89 41 50             	mov    %eax,0x50(%ecx)
  8039e8:	eb 0e                	jmp    8039f8 <dhcp_recv+0x20e>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8039ea:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8039ed:	8b 41 4c             	mov    0x4c(%ecx),%eax
  8039f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8039f3:	d1 e8                	shr    %eax
  8039f5:	89 41 50             	mov    %eax,0x50(%ecx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8039f8:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8039fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a00:	e8 8a f1 ff ff       	call   802b8f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a05:	85 c0                	test   %eax,%eax
  803a07:	74 10                	je     803a19 <dhcp_recv+0x22f>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  803a09:	83 c0 02             	add    $0x2,%eax
  803a0c:	e8 80 f2 ff ff       	call   802c91 <dhcp_get_option_long>
  803a11:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a14:	89 41 54             	mov    %eax,0x54(%ecx)
  803a17:	eb 09                	jmp    803a22 <dhcp_recv+0x238>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  803a19:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a1c:	8b 41 4c             	mov    0x4c(%ecx),%eax
  803a1f:	89 41 54             	mov    %eax,0x54(%ecx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803a22:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a25:	8b 40 10             	mov    0x10(%eax),%eax
  803a28:	83 f8 f0             	cmp    $0xfffffff0,%eax
  803a2b:	74 05                	je     803a32 <dhcp_recv+0x248>
  803a2d:	8b 40 10             	mov    0x10(%eax),%eax
  803a30:	eb 05                	jmp    803a37 <dhcp_recv+0x24d>
  803a32:	b8 00 00 00 00       	mov    $0x0,%eax
  803a37:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a3a:	89 41 30             	mov    %eax,0x30(%ecx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  803a3d:	ba 01 00 00 00       	mov    $0x1,%edx
  803a42:	89 c8                	mov    %ecx,%eax
  803a44:	e8 46 f1 ff ff       	call   802b8f <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  803a49:	85 c0                	test   %eax,%eax
  803a4b:	74 16                	je     803a63 <dhcp_recv+0x279>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a4d:	83 c0 02             	add    $0x2,%eax
  803a50:	e8 3c f2 ff ff       	call   802c91 <dhcp_get_option_long>
  803a55:	89 04 24             	mov    %eax,(%esp)
  803a58:	e8 03 43 00 00       	call   807d60 <htonl>
  803a5d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a60:	89 41 34             	mov    %eax,0x34(%ecx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803a63:	ba 03 00 00 00       	mov    $0x3,%edx
  803a68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a6b:	e8 1f f1 ff ff       	call   802b8f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a70:	85 c0                	test   %eax,%eax
  803a72:	74 16                	je     803a8a <dhcp_recv+0x2a0>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a74:	83 c0 02             	add    $0x2,%eax
  803a77:	e8 15 f2 ff ff       	call   802c91 <dhcp_get_option_long>
  803a7c:	89 04 24             	mov    %eax,(%esp)
  803a7f:	e8 dc 42 00 00       	call   807d60 <htonl>
  803a84:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a87:	89 41 38             	mov    %eax,0x38(%ecx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803a8a:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803a8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a92:	e8 f8 f0 ff ff       	call   802b8f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a97:	85 c0                	test   %eax,%eax
  803a99:	74 16                	je     803ab1 <dhcp_recv+0x2c7>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a9b:	83 c0 02             	add    $0x2,%eax
  803a9e:	e8 ee f1 ff ff       	call   802c91 <dhcp_get_option_long>
  803aa3:	89 04 24             	mov    %eax,(%esp)
  803aa6:	e8 b5 42 00 00       	call   807d60 <htonl>
  803aab:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803aae:	89 41 3c             	mov    %eax,0x3c(%ecx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803ab1:	ba 06 00 00 00       	mov    $0x6,%edx
  803ab6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ab9:	e8 d1 f0 ff ff       	call   802b8f <dhcp_get_option_ptr>
  803abe:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (option_ptr != NULL) {
  803ac1:	85 c0                	test   %eax,%eax
  803ac3:	74 56                	je     803b1b <dhcp_recv+0x331>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803ac5:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803ac9:	c0 e8 02             	shr    $0x2,%al
  803acc:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  803acf:	83 f8 03             	cmp    $0x3,%eax
  803ad2:	ba 02 00 00 00       	mov    $0x2,%edx
  803ad7:	0f 43 c2             	cmovae %edx,%eax
  803ada:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803add:	89 41 40             	mov    %eax,0x40(%ecx)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803ae0:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
  803ae4:	89 5d 08             	mov    %ebx,0x8(%ebp)
  803ae7:	eb 23                	jmp    803b0c <dhcp_recv+0x322>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803ae9:	0f b6 5d e0          	movzbl -0x20(%ebp),%ebx
  803aed:	8b 45 dc             	mov    -0x24(%ebp),%eax
  803af0:	8d 44 98 02          	lea    0x2(%eax,%ebx,4),%eax
  803af4:	e8 98 f1 ff ff       	call   802c91 <dhcp_get_option_long>
  803af9:	89 04 24             	mov    %eax,(%esp)
  803afc:	e8 5f 42 00 00       	call   807d60 <htonl>
  803b01:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b04:	89 44 99 44          	mov    %eax,0x44(%ecx,%ebx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  803b08:	80 45 e0 01          	addb   $0x1,-0x20(%ebp)
  803b0c:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  803b10:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b13:	3b 41 40             	cmp    0x40(%ecx),%eax
  803b16:	72 d1                	jb     803ae9 <dhcp_recv+0x2ff>
  803b18:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  803b1b:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  803b21:	89 d8                	mov    %ebx,%eax
  803b23:	e8 b7 fa ff ff       	call   8035df <dhcp_check>
  803b28:	e9 ee 00 00 00       	jmp    803c1b <dhcp_recv+0x431>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803b2d:	83 e8 03             	sub    $0x3,%eax
  803b30:	3c 02                	cmp    $0x2,%al
  803b32:	0f 87 e3 00 00 00    	ja     803c1b <dhcp_recv+0x431>
      dhcp->request_timeout = 0;
  803b38:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  803b3e:	89 d8                	mov    %ebx,%eax
  803b40:	e8 d7 fa ff ff       	call   80361c <dhcp_bind>
  803b45:	e9 d1 00 00 00       	jmp    803c1b <dhcp_recv+0x431>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803b4a:	3c 06                	cmp    $0x6,%al
  803b4c:	75 6d                	jne    803bbb <dhcp_recv+0x3d1>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  803b4e:	0f b6 06             	movzbl (%esi),%eax
  803b51:	8d 50 fd             	lea    -0x3(%eax),%edx
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803b54:	80 fa 02             	cmp    $0x2,%dl
  803b57:	76 08                	jbe    803b61 <dhcp_recv+0x377>
  803b59:	3c 01                	cmp    $0x1,%al
  803b5b:	0f 85 ba 00 00 00    	jne    803c1b <dhcp_recv+0x431>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  803b61:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803b67:	8b 43 20             	mov    0x20(%ebx),%eax
  803b6a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  803b6d:	89 1c 24             	mov    %ebx,(%esp)
  803b70:	e8 51 11 00 00       	call   804cc6 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803b75:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  803b7c:	00 
  803b7d:	89 1c 24             	mov    %ebx,(%esp)
  803b80:	e8 72 0f 00 00       	call   804af7 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803b85:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  803b8c:	00 
  803b8d:	89 1c 24             	mov    %ebx,(%esp)
  803b90:	e8 b8 10 00 00       	call   804c4d <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803b95:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  803b9c:	00 
  803b9d:	89 1c 24             	mov    %ebx,(%esp)
  803ba0:	e8 c3 10 00 00       	call   804c68 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803ba5:	ba 0c 00 00 00       	mov    $0xc,%edx
  803baa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803bad:	e8 ce ef ff ff       	call   802b80 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  803bb2:	89 d8                	mov    %ebx,%eax
  803bb4:	e8 37 f7 ff ff       	call   8032f0 <dhcp_discover>
  803bb9:	eb 60                	jmp    803c1b <dhcp_recv+0x431>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803bbb:	3c 02                	cmp    $0x2,%al
  803bbd:	8d 76 00             	lea    0x0(%esi),%esi
  803bc0:	75 59                	jne    803c1b <dhcp_recv+0x431>
  803bc2:	80 3e 06             	cmpb   $0x6,(%esi)
  803bc5:	75 54                	jne    803c1b <dhcp_recv+0x431>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  803bc7:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803bcd:	8b 43 20             	mov    0x20(%ebx),%eax
  803bd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803bd3:	ba 36 00 00 00       	mov    $0x36,%edx
  803bd8:	e8 b2 ef ff ff       	call   802b8f <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  803bdd:	85 c0                	test   %eax,%eax
  803bdf:	74 3a                	je     803c1b <dhcp_recv+0x431>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803be1:	83 c0 02             	add    $0x2,%eax
  803be4:	e8 a8 f0 ff ff       	call   802c91 <dhcp_get_option_long>
  803be9:	89 04 24             	mov    %eax,(%esp)
  803bec:	e8 6f 41 00 00       	call   807d60 <htonl>
  803bf1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803bf4:	89 41 2c             	mov    %eax,0x2c(%ecx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803bf7:	8b 41 10             	mov    0x10(%ecx),%eax
  803bfa:	83 f8 f0             	cmp    $0xfffffff0,%eax
  803bfd:	74 05                	je     803c04 <dhcp_recv+0x41a>
  803bff:	8b 40 10             	mov    0x10(%eax),%eax
  803c02:	eb 05                	jmp    803c09 <dhcp_recv+0x41f>
  803c04:	b8 00 00 00 00       	mov    $0x0,%eax
  803c09:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803c0c:	89 41 30             	mov    %eax,0x30(%ecx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  803c0f:	89 d8                	mov    %ebx,%eax
  803c11:	e8 33 f8 ff ff       	call   803449 <dhcp_select>
  803c16:	eb 03                	jmp    803c1b <dhcp_recv+0x431>
  803c18:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  803c1b:	89 3c 24             	mov    %edi,(%esp)
  803c1e:	e8 b1 11 00 00       	call   804dd4 <pbuf_free>
  dhcp->p = NULL;
  803c23:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  803c2a:	eb 16                	jmp    803c42 <dhcp_recv+0x458>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803c2c:	ba 35 00 00 00       	mov    $0x35,%edx
  803c31:	89 f0                	mov    %esi,%eax
  803c33:	e8 57 ef ff ff       	call   802b8f <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  803c38:	85 c0                	test   %eax,%eax
  803c3a:	0f 85 3b fd ff ff    	jne    80397b <dhcp_recv+0x191>
  803c40:	eb d9                	jmp    803c1b <dhcp_recv+0x431>
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  dhcp->p = NULL;
}
  803c42:	83 c4 2c             	add    $0x2c,%esp
  803c45:	5b                   	pop    %ebx
  803c46:	5e                   	pop    %esi
  803c47:	5f                   	pop    %edi
  803c48:	5d                   	pop    %ebp
  803c49:	c3                   	ret    

00803c4a <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  803c4a:	55                   	push   %ebp
  803c4b:	89 e5                	mov    %esp,%ebp
  803c4d:	57                   	push   %edi
  803c4e:	56                   	push   %esi
  803c4f:	53                   	push   %ebx
  803c50:	83 ec 2c             	sub    $0x2c,%esp
  803c53:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803c56:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  803c59:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  803c60:	e8 3a 0b 00 00       	call   80479f <mem_malloc>
  803c65:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  803c67:	85 c0                	test   %eax,%eax
  803c69:	0f 84 47 01 00 00    	je     803db6 <dhcp_inform+0x16c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  803c6f:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803c72:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  803c79:	00 
  803c7a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c81:	00 
  803c82:	89 04 24             	mov    %eax,(%esp)
  803c85:	e8 6d bc 00 00       	call   80f8f7 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  803c8a:	e8 65 5b 00 00       	call   8097f4 <udp_new>
  803c8f:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803c92:	85 c0                	test   %eax,%eax
  803c94:	75 0d                	jne    803ca3 <dhcp_inform+0x59>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  803c96:	89 1c 24             	mov    %ebx,(%esp)
  803c99:	e8 27 08 00 00       	call   8044c5 <mem_free>
    return;
  803c9e:	e9 13 01 00 00       	jmp    803db6 <dhcp_inform+0x16c>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803ca3:	89 f0                	mov    %esi,%eax
  803ca5:	e8 97 f2 ff ff       	call   802f41 <dhcp_create_request>
  if (result == ERR_OK) {
  803caa:	84 c0                	test   %al,%al
  803cac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803cb0:	0f 85 f7 00 00 00    	jne    803dad <dhcp_inform+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803cb6:	b9 01 00 00 00       	mov    $0x1,%ecx
  803cbb:	ba 35 00 00 00       	mov    $0x35,%edx
  803cc0:	89 d8                	mov    %ebx,%eax
  803cc2:	e8 38 f0 ff ff       	call   802cff <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803cc7:	ba 08 00 00 00       	mov    $0x8,%edx
  803ccc:	89 d8                	mov    %ebx,%eax
  803cce:	e8 e3 ef ff ff       	call   802cb6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803cd3:	b9 02 00 00 00       	mov    $0x2,%ecx
  803cd8:	ba 39 00 00 00       	mov    $0x39,%edx
  803cdd:	89 d8                	mov    %ebx,%eax
  803cdf:	e8 1b f0 ff ff       	call   802cff <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803ce4:	ba 40 02 00 00       	mov    $0x240,%edx
  803ce9:	89 d8                	mov    %ebx,%eax
  803ceb:	e8 78 f0 ff ff       	call   802d68 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  803cf0:	89 d8                	mov    %ebx,%eax
  803cf2:	e8 dd f0 ff ff       	call   802dd4 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803cf7:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803cfb:	66 05 f0 00          	add    $0xf0,%ax
  803cff:	0f b7 c0             	movzwl %ax,%eax
  803d02:	89 44 24 04          	mov    %eax,0x4(%esp)
  803d06:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803d09:	89 04 24             	mov    %eax,(%esp)
  803d0c:	e8 35 14 00 00       	call   805146 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803d11:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  803d18:	00 
  803d19:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  803d20:	00 
  803d21:	8b 43 08             	mov    0x8(%ebx),%eax
  803d24:	89 04 24             	mov    %eax,(%esp)
  803d27:	e8 e5 56 00 00       	call   809411 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803d2c:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803d33:	00 
  803d34:	c7 44 24 04 3c 30 81 	movl   $0x81303c,0x4(%esp)
  803d3b:	00 
  803d3c:	8b 43 08             	mov    0x8(%ebx),%eax
  803d3f:	89 04 24             	mov    %eax,(%esp)
  803d42:	e8 be 59 00 00       	call   809705 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803d47:	89 74 24 10          	mov    %esi,0x10(%esp)
  803d4b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803d52:	00 
  803d53:	c7 44 24 08 3c 30 81 	movl   $0x81303c,0x8(%esp)
  803d5a:	00 
  803d5b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803d5e:	89 44 24 04          	mov    %eax,0x4(%esp)
  803d62:	8b 43 08             	mov    0x8(%ebx),%eax
  803d65:	89 04 24             	mov    %eax,(%esp)
  803d68:	e8 76 57 00 00       	call   8094e3 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803d6d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803d74:	00 
  803d75:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  803d7c:	00 
  803d7d:	8b 43 08             	mov    0x8(%ebx),%eax
  803d80:	89 04 24             	mov    %eax,(%esp)
  803d83:	e8 7d 59 00 00       	call   809705 <udp_connect>
    dhcp_delete_request(netif);
  803d88:	89 f0                	mov    %esi,%eax
  803d8a:	e8 a9 f3 ff ff       	call   803138 <dhcp_delete_request>
  803d8f:	eb 1c                	jmp    803dad <dhcp_inform+0x163>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
      udp_remove(dhcp->pcb);
  803d91:	89 04 24             	mov    %eax,(%esp)
  803d94:	e8 15 5a 00 00       	call   8097ae <udp_remove>
    }
    dhcp->pcb = NULL;
  803d99:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803da0:	89 1c 24             	mov    %ebx,(%esp)
  803da3:	e8 1d 07 00 00       	call   8044c5 <mem_free>
    netif->dhcp = old_dhcp;
  803da8:	89 7e 20             	mov    %edi,0x20(%esi)
  803dab:	eb 09                	jmp    803db6 <dhcp_inform+0x16c>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  803dad:	8b 43 08             	mov    0x8(%ebx),%eax
  803db0:	85 c0                	test   %eax,%eax
  803db2:	75 dd                	jne    803d91 <dhcp_inform+0x147>
  803db4:	eb e3                	jmp    803d99 <dhcp_inform+0x14f>
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  803db6:	83 c4 2c             	add    $0x2c,%esp
  803db9:	5b                   	pop    %ebx
  803dba:	5e                   	pop    %esi
  803dbb:	5f                   	pop    %edi
  803dbc:	5d                   	pop    %ebp
  803dbd:	c3                   	ret    

00803dbe <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  803dbe:	55                   	push   %ebp
  803dbf:	89 e5                	mov    %esp,%ebp
  803dc1:	56                   	push   %esi
  803dc2:	53                   	push   %ebx
  803dc3:	83 ec 20             	sub    $0x20,%esp
  803dc6:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803dc9:	85 f6                	test   %esi,%esi
  803dcb:	75 1c                	jne    803de9 <dhcp_arp_reply+0x2b>
  803dcd:	c7 44 24 08 a2 27 81 	movl   $0x8127a2,0x8(%esp)
  803dd4:	00 
  803dd5:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  803ddc:	00 
  803ddd:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  803de4:	e8 51 b2 00 00       	call   80f03a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803de9:	8b 5e 20             	mov    0x20(%esi),%ebx
  803dec:	85 db                	test   %ebx,%ebx
  803dee:	0f 84 04 01 00 00    	je     803ef8 <dhcp_arp_reply+0x13a>
  803df4:	80 3b 08             	cmpb   $0x8,(%ebx)
  803df7:	0f 85 fb 00 00 00    	jne    803ef8 <dhcp_arp_reply+0x13a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803dfd:	8b 45 0c             	mov    0xc(%ebp),%eax
  803e00:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803e03:	39 08                	cmp    %ecx,(%eax)
  803e05:	0f 85 ed 00 00 00    	jne    803ef8 <dhcp_arp_reply+0x13a>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803e0b:	ba 0c 00 00 00       	mov    $0xc,%edx
  803e10:	89 d8                	mov    %ebx,%eax
  803e12:	e8 69 ed ff ff       	call   802b80 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803e17:	89 f0                	mov    %esi,%eax
  803e19:	e8 23 f1 ff ff       	call   802f41 <dhcp_create_request>
  if (result == ERR_OK) {
  803e1e:	84 c0                	test   %al,%al
  803e20:	0f 85 c8 00 00 00    	jne    803eee <dhcp_arp_reply+0x130>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803e26:	b9 01 00 00 00       	mov    $0x1,%ecx
  803e2b:	ba 35 00 00 00       	mov    $0x35,%edx
  803e30:	89 d8                	mov    %ebx,%eax
  803e32:	e8 c8 ee ff ff       	call   802cff <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803e37:	ba 04 00 00 00       	mov    $0x4,%edx
  803e3c:	89 d8                	mov    %ebx,%eax
  803e3e:	e8 73 ee ff ff       	call   802cb6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803e43:	b9 02 00 00 00       	mov    $0x2,%ecx
  803e48:	ba 39 00 00 00       	mov    $0x39,%edx
  803e4d:	89 d8                	mov    %ebx,%eax
  803e4f:	e8 ab ee ff ff       	call   802cff <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803e54:	ba 40 02 00 00       	mov    $0x240,%edx
  803e59:	89 d8                	mov    %ebx,%eax
  803e5b:	e8 08 ef ff ff       	call   802d68 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803e60:	b9 04 00 00 00       	mov    $0x4,%ecx
  803e65:	ba 32 00 00 00       	mov    $0x32,%edx
  803e6a:	89 d8                	mov    %ebx,%eax
  803e6c:	e8 8e ee ff ff       	call   802cff <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803e71:	8b 43 30             	mov    0x30(%ebx),%eax
  803e74:	89 04 24             	mov    %eax,(%esp)
  803e77:	e8 1e 41 00 00       	call   807f9a <ntohl>
  803e7c:	89 c2                	mov    %eax,%edx
  803e7e:	89 d8                	mov    %ebx,%eax
  803e80:	e8 19 f0 ff ff       	call   802e9e <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  803e85:	89 d8                	mov    %ebx,%eax
  803e87:	e8 48 ef ff ff       	call   802dd4 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803e8c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803e90:	66 05 f0 00          	add    $0xf0,%ax
  803e94:	0f b7 c0             	movzwl %ax,%eax
  803e97:	89 44 24 04          	mov    %eax,0x4(%esp)
  803e9b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803e9e:	89 04 24             	mov    %eax,(%esp)
  803ea1:	e8 a0 12 00 00       	call   805146 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803ea6:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803ead:	00 
  803eae:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  803eb5:	00 
  803eb6:	8b 43 08             	mov    0x8(%ebx),%eax
  803eb9:	89 04 24             	mov    %eax,(%esp)
  803ebc:	e8 44 58 00 00       	call   809705 <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803ec1:	89 74 24 10          	mov    %esi,0x10(%esp)
  803ec5:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803ecc:	00 
  803ecd:	c7 44 24 08 3c 30 81 	movl   $0x81303c,0x8(%esp)
  803ed4:	00 
  803ed5:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803ed8:	89 44 24 04          	mov    %eax,0x4(%esp)
  803edc:	8b 43 08             	mov    0x8(%ebx),%eax
  803edf:	89 04 24             	mov    %eax,(%esp)
  803ee2:	e8 fc 55 00 00       	call   8094e3 <udp_sendto_if>
    dhcp_delete_request(netif);
  803ee7:	89 f0                	mov    %esi,%eax
  803ee9:	e8 4a f2 ff ff       	call   803138 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803eee:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803ef2:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  803ef8:	83 c4 20             	add    $0x20,%esp
  803efb:	5b                   	pop    %ebx
  803efc:	5e                   	pop    %esi
  803efd:	5d                   	pop    %ebp
  803efe:	c3                   	ret    

00803eff <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  803eff:	55                   	push   %ebp
  803f00:	89 e5                	mov    %esp,%ebp
  803f02:	57                   	push   %edi
  803f03:	56                   	push   %esi
  803f04:	53                   	push   %ebx
  803f05:	83 ec 2c             	sub    $0x2c,%esp
  803f08:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803f0b:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803f0e:	ba 05 00 00 00       	mov    $0x5,%edx
  803f13:	89 d8                	mov    %ebx,%eax
  803f15:	e8 66 ec ff ff       	call   802b80 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803f1a:	89 f0                	mov    %esi,%eax
  803f1c:	e8 20 f0 ff ff       	call   802f41 <dhcp_create_request>
  803f21:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803f23:	84 c0                	test   %al,%al
  803f25:	0f 85 a4 00 00 00    	jne    803fcf <dhcp_renew+0xd0>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803f2b:	b9 01 00 00 00       	mov    $0x1,%ecx
  803f30:	ba 35 00 00 00       	mov    $0x35,%edx
  803f35:	89 d8                	mov    %ebx,%eax
  803f37:	e8 c3 ed ff ff       	call   802cff <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803f3c:	ba 03 00 00 00       	mov    $0x3,%edx
  803f41:	89 d8                	mov    %ebx,%eax
  803f43:	e8 6e ed ff ff       	call   802cb6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803f48:	b9 02 00 00 00       	mov    $0x2,%ecx
  803f4d:	ba 39 00 00 00       	mov    $0x39,%edx
  803f52:	89 d8                	mov    %ebx,%eax
  803f54:	e8 a6 ed ff ff       	call   802cff <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  803f59:	ba 40 02 00 00       	mov    $0x240,%edx
  803f5e:	89 d8                	mov    %ebx,%eax
  803f60:	e8 03 ee ff ff       	call   802d68 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  803f65:	89 d8                	mov    %ebx,%eax
  803f67:	e8 68 ee ff ff       	call   802dd4 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803f6c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803f70:	66 05 f0 00          	add    $0xf0,%ax
  803f74:	0f b7 c0             	movzwl %ax,%eax
  803f77:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f7b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803f7e:	89 04 24             	mov    %eax,(%esp)
  803f81:	e8 c0 11 00 00       	call   805146 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803f86:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803f89:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803f90:	00 
  803f91:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803f94:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f98:	8b 43 08             	mov    0x8(%ebx),%eax
  803f9b:	89 04 24             	mov    %eax,(%esp)
  803f9e:	e8 62 57 00 00       	call   809705 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803fa3:	89 74 24 10          	mov    %esi,0x10(%esp)
  803fa7:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803fae:	00 
  803faf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803fb2:	89 44 24 08          	mov    %eax,0x8(%esp)
  803fb6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803fb9:	89 44 24 04          	mov    %eax,0x4(%esp)
  803fbd:	8b 43 08             	mov    0x8(%ebx),%eax
  803fc0:	89 04 24             	mov    %eax,(%esp)
  803fc3:	e8 1b 55 00 00       	call   8094e3 <udp_sendto_if>
    dhcp_delete_request(netif);
  803fc8:	89 f0                	mov    %esi,%eax
  803fca:	e8 69 f1 ff ff       	call   803138 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803fcf:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803fd3:	8d 48 01             	lea    0x1(%eax),%ecx
  803fd6:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803fd9:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  803fde:	80 f9 09             	cmp    $0x9,%cl
  803fe1:	77 08                	ja     803feb <dhcp_renew+0xec>
  803fe3:	0f b6 c9             	movzbl %cl,%ecx
  803fe6:	66 69 c1 d0 07       	imul   $0x7d0,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803feb:	0f b7 d0             	movzwl %ax,%edx
  803fee:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803ff4:	be d3 4d 62 10       	mov    $0x10624dd3,%esi
  803ff9:	89 d0                	mov    %edx,%eax
  803ffb:	f7 ee                	imul   %esi
  803ffd:	c1 fa 05             	sar    $0x5,%edx
  804000:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  804004:	89 f8                	mov    %edi,%eax
  804006:	83 c4 2c             	add    $0x2c,%esp
  804009:	5b                   	pop    %ebx
  80400a:	5e                   	pop    %esi
  80400b:	5f                   	pop    %edi
  80400c:	5d                   	pop    %ebp
  80400d:	c3                   	ret    

0080400e <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  80400e:	55                   	push   %ebp
  80400f:	89 e5                	mov    %esp,%ebp
  804011:	53                   	push   %ebx
  804012:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  804015:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80401b:	eb 67                	jmp    804084 <dhcp_coarse_tmr+0x76>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80401d:	8b 43 20             	mov    0x20(%ebx),%eax
  804020:	85 c0                	test   %eax,%eax
  804022:	74 5e                	je     804082 <dhcp_coarse_tmr+0x74>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  804024:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  804028:	8d 4a ff             	lea    -0x1(%edx),%ecx
  80402b:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  80402f:	66 83 fa 01          	cmp    $0x1,%dx
  804033:	75 1d                	jne    804052 <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  804035:	8b 43 20             	mov    0x20(%ebx),%eax
  804038:	0f b6 00             	movzbl (%eax),%eax
  80403b:	89 c2                	mov    %eax,%edx
  80403d:	83 e2 fb             	and    $0xfffffffb,%edx
  804040:	80 fa 01             	cmp    $0x1,%dl
  804043:	74 04                	je     804049 <dhcp_coarse_tmr+0x3b>
  804045:	3c 0a                	cmp    $0xa,%al
  804047:	75 39                	jne    804082 <dhcp_coarse_tmr+0x74>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  804049:	89 d8                	mov    %ebx,%eax
  80404b:	e8 93 f1 ff ff       	call   8031e3 <dhcp_rebind>
  804050:	eb 30                	jmp    804082 <dhcp_coarse_tmr+0x74>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  804052:	8b 53 20             	mov    0x20(%ebx),%edx
  804055:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  804059:	8d 48 ff             	lea    -0x1(%eax),%ecx
  80405c:	66 89 4a 28          	mov    %cx,0x28(%edx)
  804060:	66 83 f8 01          	cmp    $0x1,%ax
  804064:	75 1c                	jne    804082 <dhcp_coarse_tmr+0x74>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  804066:	8b 43 20             	mov    0x20(%ebx),%eax
  804069:	0f b6 00             	movzbl (%eax),%eax
  80406c:	89 c2                	mov    %eax,%edx
  80406e:	83 e2 fb             	and    $0xfffffffb,%edx
  804071:	80 fa 01             	cmp    $0x1,%dl
  804074:	74 04                	je     80407a <dhcp_coarse_tmr+0x6c>
  804076:	3c 0a                	cmp    $0xa,%al
  804078:	75 08                	jne    804082 <dhcp_coarse_tmr+0x74>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  80407a:	89 1c 24             	mov    %ebx,(%esp)
  80407d:	e8 7d fe ff ff       	call   803eff <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  804082:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  804084:	85 db                	test   %ebx,%ebx
  804086:	75 95                	jne    80401d <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  804088:	83 c4 14             	add    $0x14,%esp
  80408b:	5b                   	pop    %ebx
  80408c:	5d                   	pop    %ebp
  80408d:	c3                   	ret    

0080408e <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  80408e:	55                   	push   %ebp
  80408f:	89 e5                	mov    %esp,%ebp
  804091:	57                   	push   %edi
  804092:	56                   	push   %esi
  804093:	53                   	push   %ebx
  804094:	83 ec 2c             	sub    $0x2c,%esp
  804097:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  80409a:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  80409d:	ba 0d 00 00 00       	mov    $0xd,%edx
  8040a2:	89 d8                	mov    %ebx,%eax
  8040a4:	e8 d7 ea ff ff       	call   802b80 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  8040a9:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  8040b0:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  8040b7:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  8040be:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  8040c5:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  8040cc:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  8040d3:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  8040da:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  8040e1:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8040e8:	89 f0                	mov    %esi,%eax
  8040ea:	e8 52 ee ff ff       	call   802f41 <dhcp_create_request>
  8040ef:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  8040f1:	84 c0                	test   %al,%al
  8040f3:	0f 85 87 00 00 00    	jne    804180 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8040f9:	b9 01 00 00 00       	mov    $0x1,%ecx
  8040fe:	ba 35 00 00 00       	mov    $0x35,%edx
  804103:	89 d8                	mov    %ebx,%eax
  804105:	e8 f5 eb ff ff       	call   802cff <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80410a:	ba 07 00 00 00       	mov    $0x7,%edx
  80410f:	89 d8                	mov    %ebx,%eax
  804111:	e8 a0 eb ff ff       	call   802cb6 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  804116:	89 d8                	mov    %ebx,%eax
  804118:	e8 b7 ec ff ff       	call   802dd4 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80411d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  804121:	66 05 f0 00          	add    $0xf0,%ax
  804125:	0f b7 c0             	movzwl %ax,%eax
  804128:	89 44 24 04          	mov    %eax,0x4(%esp)
  80412c:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80412f:	89 04 24             	mov    %eax,(%esp)
  804132:	e8 0f 10 00 00       	call   805146 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  804137:	8d 43 2c             	lea    0x2c(%ebx),%eax
  80413a:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  804141:	00 
  804142:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804145:	89 44 24 04          	mov    %eax,0x4(%esp)
  804149:	8b 43 08             	mov    0x8(%ebx),%eax
  80414c:	89 04 24             	mov    %eax,(%esp)
  80414f:	e8 b1 55 00 00       	call   809705 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  804154:	89 74 24 10          	mov    %esi,0x10(%esp)
  804158:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80415f:	00 
  804160:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804163:	89 44 24 08          	mov    %eax,0x8(%esp)
  804167:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80416a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80416e:	8b 43 08             	mov    0x8(%ebx),%eax
  804171:	89 04 24             	mov    %eax,(%esp)
  804174:	e8 6a 53 00 00       	call   8094e3 <udp_sendto_if>
    dhcp_delete_request(netif);
  804179:	89 f0                	mov    %esi,%eax
  80417b:	e8 b8 ef ff ff       	call   803138 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  804180:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  804184:	8d 48 01             	lea    0x1(%eax),%ecx
  804187:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80418a:	b8 10 27 00 00       	mov    $0x2710,%eax
  80418f:	80 f9 09             	cmp    $0x9,%cl
  804192:	77 08                	ja     80419c <dhcp_release+0x10e>
  804194:	0f b6 c9             	movzbl %cl,%ecx
  804197:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80419c:	0f b7 d0             	movzwl %ax,%edx
  80419f:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8041a5:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8041aa:	89 d0                	mov    %edx,%eax
  8041ac:	f7 e9                	imul   %ecx
  8041ae:	c1 fa 05             	sar    $0x5,%edx
  8041b1:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  8041b5:	89 34 24             	mov    %esi,(%esp)
  8041b8:	e8 09 0b 00 00       	call   804cc6 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8041bd:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  8041c4:	00 
  8041c5:	89 34 24             	mov    %esi,(%esp)
  8041c8:	e8 2a 09 00 00       	call   804af7 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8041cd:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  8041d4:	00 
  8041d5:	89 34 24             	mov    %esi,(%esp)
  8041d8:	e8 70 0a 00 00       	call   804c4d <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  8041dd:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  8041e4:	00 
  8041e5:	89 34 24             	mov    %esi,(%esp)
  8041e8:	e8 7b 0a 00 00       	call   804c68 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  8041ed:	89 f8                	mov    %edi,%eax
  8041ef:	83 c4 2c             	add    $0x2c,%esp
  8041f2:	5b                   	pop    %ebx
  8041f3:	5e                   	pop    %esi
  8041f4:	5f                   	pop    %edi
  8041f5:	5d                   	pop    %ebp
  8041f6:	c3                   	ret    

008041f7 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  8041f7:	55                   	push   %ebp
  8041f8:	89 e5                	mov    %esp,%ebp
  8041fa:	53                   	push   %ebx
  8041fb:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  8041fe:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  804204:	e9 c3 00 00 00       	jmp    8042cc <dhcp_fine_tmr+0xd5>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  804209:	8b 43 20             	mov    0x20(%ebx),%eax
  80420c:	85 c0                	test   %eax,%eax
  80420e:	0f 84 b6 00 00 00    	je     8042ca <dhcp_fine_tmr+0xd3>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  804214:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  804218:	66 83 fa 01          	cmp    $0x1,%dx
  80421c:	76 0c                	jbe    80422a <dhcp_fine_tmr+0x33>
        netif->dhcp->request_timeout--;
  80421e:	83 ea 01             	sub    $0x1,%edx
  804221:	66 89 50 26          	mov    %dx,0x26(%eax)
  804225:	e9 a0 00 00 00       	jmp    8042ca <dhcp_fine_tmr+0xd3>
      }
      else if (netif->dhcp->request_timeout == 1) {
  80422a:	66 83 fa 01          	cmp    $0x1,%dx
  80422e:	0f 85 96 00 00 00    	jne    8042ca <dhcp_fine_tmr+0xd3>
        netif->dhcp->request_timeout--;
  804234:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80423a:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  80423d:	0f b6 02             	movzbl (%edx),%eax
  804240:	3c 06                	cmp    $0x6,%al
  804242:	74 04                	je     804248 <dhcp_fine_tmr+0x51>
  804244:	3c 0c                	cmp    $0xc,%al
  804246:	75 0a                	jne    804252 <dhcp_fine_tmr+0x5b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  804248:	89 d8                	mov    %ebx,%eax
  80424a:	e8 a1 f0 ff ff       	call   8032f0 <dhcp_discover>
  80424f:	90                   	nop
  804250:	eb 78                	jmp    8042ca <dhcp_fine_tmr+0xd3>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  804252:	3c 01                	cmp    $0x1,%al
  804254:	75 20                	jne    804276 <dhcp_fine_tmr+0x7f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  804256:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  80425a:	77 09                	ja     804265 <dhcp_fine_tmr+0x6e>
      dhcp_select(netif);
  80425c:	89 d8                	mov    %ebx,%eax
  80425e:	e8 e6 f1 ff ff       	call   803449 <dhcp_select>
  804263:	eb 65                	jmp    8042ca <dhcp_fine_tmr+0xd3>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  804265:	89 1c 24             	mov    %ebx,(%esp)
  804268:	e8 21 fe ff ff       	call   80408e <dhcp_release>
      dhcp_discover(netif);
  80426d:	89 d8                	mov    %ebx,%eax
  80426f:	e8 7c f0 ff ff       	call   8032f0 <dhcp_discover>
  804274:	eb 54                	jmp    8042ca <dhcp_fine_tmr+0xd3>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  804276:	3c 08                	cmp    $0x8,%al
  804278:	75 1a                	jne    804294 <dhcp_fine_tmr+0x9d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  80427a:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  80427e:	66 90                	xchg   %ax,%ax
  804280:	77 09                	ja     80428b <dhcp_fine_tmr+0x94>
      dhcp_check(netif);
  804282:	89 d8                	mov    %ebx,%eax
  804284:	e8 56 f3 ff ff       	call   8035df <dhcp_check>
  804289:	eb 3f                	jmp    8042ca <dhcp_fine_tmr+0xd3>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  80428b:	89 d8                	mov    %ebx,%eax
  80428d:	e8 8a f3 ff ff       	call   80361c <dhcp_bind>
  804292:	eb 36                	jmp    8042ca <dhcp_fine_tmr+0xd3>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  804294:	3c 05                	cmp    $0x5,%al
  804296:	75 0f                	jne    8042a7 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  804298:	89 1c 24             	mov    %ebx,(%esp)
  80429b:	90                   	nop
  80429c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8042a0:	e8 5a fc ff ff       	call   803eff <dhcp_renew>
  8042a5:	eb 23                	jmp    8042ca <dhcp_fine_tmr+0xd3>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  8042a7:	3c 04                	cmp    $0x4,%al
  8042a9:	75 1f                	jne    8042ca <dhcp_fine_tmr+0xd3>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  8042ab:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  8042af:	90                   	nop
  8042b0:	77 09                	ja     8042bb <dhcp_fine_tmr+0xc4>
      dhcp_rebind(netif);
  8042b2:	89 d8                	mov    %ebx,%eax
  8042b4:	e8 2a ef ff ff       	call   8031e3 <dhcp_rebind>
  8042b9:	eb 0f                	jmp    8042ca <dhcp_fine_tmr+0xd3>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  8042bb:	89 1c 24             	mov    %ebx,(%esp)
  8042be:	e8 cb fd ff ff       	call   80408e <dhcp_release>
      dhcp_discover(netif);
  8042c3:	89 d8                	mov    %ebx,%eax
  8042c5:	e8 26 f0 ff ff       	call   8032f0 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  8042ca:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  8042cc:	85 db                	test   %ebx,%ebx
  8042ce:	0f 85 35 ff ff ff    	jne    804209 <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  8042d4:	83 c4 14             	add    $0x14,%esp
  8042d7:	5b                   	pop    %ebx
  8042d8:	5d                   	pop    %ebp
  8042d9:	c3                   	ret    

008042da <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  8042da:	55                   	push   %ebp
  8042db:	89 e5                	mov    %esp,%ebp
  8042dd:	56                   	push   %esi
  8042de:	53                   	push   %ebx
  8042df:	83 ec 10             	sub    $0x10,%esp
  8042e2:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8042e5:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  8042e8:	85 f6                	test   %esi,%esi
  8042ea:	75 1c                	jne    804308 <dhcp_stop+0x2e>
  8042ec:	c7 44 24 08 f4 27 81 	movl   $0x8127f4,0x8(%esp)
  8042f3:	00 
  8042f4:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  8042fb:	00 
  8042fc:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  804303:	e8 32 ad 00 00       	call   80f03a <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  804308:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80430c:	85 db                	test   %ebx,%ebx
  80430e:	74 42                	je     804352 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  804310:	8b 43 08             	mov    0x8(%ebx),%eax
  804313:	85 c0                	test   %eax,%eax
  804315:	74 0f                	je     804326 <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  804317:	89 04 24             	mov    %eax,(%esp)
  80431a:	e8 8f 54 00 00       	call   8097ae <udp_remove>
      dhcp->pcb = NULL;
  80431f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  804326:	8b 43 0c             	mov    0xc(%ebx),%eax
  804329:	85 c0                	test   %eax,%eax
  80432b:	74 0f                	je     80433c <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  80432d:	89 04 24             	mov    %eax,(%esp)
  804330:	e8 9f 0a 00 00       	call   804dd4 <pbuf_free>
      dhcp->p = NULL;
  804335:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80433c:	89 d8                	mov    %ebx,%eax
  80433e:	e8 66 f4 ff ff       	call   8037a9 <dhcp_free_reply>
    mem_free((void *)dhcp);
  804343:	89 1c 24             	mov    %ebx,(%esp)
  804346:	e8 7a 01 00 00       	call   8044c5 <mem_free>
    netif->dhcp = NULL;
  80434b:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  804352:	83 c4 10             	add    $0x10,%esp
  804355:	5b                   	pop    %ebx
  804356:	5e                   	pop    %esi
  804357:	5d                   	pop    %ebp
  804358:	c3                   	ret    

00804359 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  804359:	55                   	push   %ebp
  80435a:	89 e5                	mov    %esp,%ebp
  80435c:	56                   	push   %esi
  80435d:	53                   	push   %ebx
  80435e:	83 ec 10             	sub    $0x10,%esp
  804361:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  804364:	85 db                	test   %ebx,%ebx
  804366:	75 1c                	jne    804384 <dhcp_start+0x2b>
  804368:	c7 44 24 08 a2 27 81 	movl   $0x8127a2,0x8(%esp)
  80436f:	00 
  804370:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  804377:	00 
  804378:	c7 04 24 82 27 81 00 	movl   $0x812782,(%esp)
  80437f:	e8 b6 ac 00 00       	call   80f03a <_panic>
  dhcp = netif->dhcp;
  804384:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  804387:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  80438b:	85 f6                	test   %esi,%esi
  80438d:	75 19                	jne    8043a8 <dhcp_start+0x4f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  80438f:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  804396:	e8 04 04 00 00       	call   80479f <mem_malloc>
  80439b:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  80439d:	85 c0                	test   %eax,%eax
  80439f:	0f 84 ac 00 00 00    	je     804451 <dhcp_start+0xf8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8043a5:	89 43 20             	mov    %eax,0x20(%ebx)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8043a8:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  8043af:	00 
  8043b0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8043b7:	00 
  8043b8:	89 34 24             	mov    %esi,(%esp)
  8043bb:	e8 37 b5 00 00       	call   80f8f7 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  8043c0:	e8 2f 54 00 00       	call   8097f4 <udp_new>
  8043c5:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  8043c8:	85 c0                	test   %eax,%eax
  8043ca:	75 16                	jne    8043e2 <dhcp_start+0x89>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  8043cc:	89 34 24             	mov    %esi,(%esp)
  8043cf:	e8 f1 00 00 00       	call   8044c5 <mem_free>
    netif->dhcp = dhcp = NULL;
  8043d4:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  8043db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8043e0:	eb 74                	jmp    804456 <dhcp_start+0xfd>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  8043e2:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  8043e9:	00 
  8043ea:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  8043f1:	00 
  8043f2:	89 04 24             	mov    %eax,(%esp)
  8043f5:	e8 17 50 00 00       	call   809411 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8043fa:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  804401:	00 
  804402:	c7 44 24 04 40 30 81 	movl   $0x813040,0x4(%esp)
  804409:	00 
  80440a:	8b 46 08             	mov    0x8(%esi),%eax
  80440d:	89 04 24             	mov    %eax,(%esp)
  804410:	e8 f0 52 00 00       	call   809705 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  804415:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  804419:	c7 44 24 04 ea 37 80 	movl   $0x8037ea,0x4(%esp)
  804420:	00 
  804421:	8b 46 08             	mov    0x8(%esi),%eax
  804424:	89 04 24             	mov    %eax,(%esp)
  804427:	e8 6e 53 00 00       	call   80979a <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  80442c:	89 d8                	mov    %ebx,%eax
  80442e:	e8 bd ee ff ff       	call   8032f0 <dhcp_discover>
  if (result != ERR_OK) {
  804433:	84 c0                	test   %al,%al
  804435:	74 0f                	je     804446 <dhcp_start+0xed>
    /* free resources allocated above */
    dhcp_stop(netif);
  804437:	89 1c 24             	mov    %ebx,(%esp)
  80443a:	e8 9b fe ff ff       	call   8042da <dhcp_stop>
    return ERR_MEM;
  80443f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804444:	eb 10                	jmp    804456 <dhcp_start+0xfd>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  804446:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
  return result;
  80444a:	b8 00 00 00 00       	mov    $0x0,%eax
  80444f:	eb 05                	jmp    804456 <dhcp_start+0xfd>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  804451:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  804456:	83 c4 10             	add    $0x10,%esp
  804459:	5b                   	pop    %ebx
  80445a:	5e                   	pop    %esi
  80445b:	5d                   	pop    %ebp
  80445c:	c3                   	ret    

0080445d <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80445d:	55                   	push   %ebp
  80445e:	89 e5                	mov    %esp,%ebp
  804460:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  804463:	b8 43 63 81 00       	mov    $0x816343,%eax
  804468:	83 e0 fc             	and    $0xfffffffc,%eax
  80446b:	a3 2c 63 81 00       	mov    %eax,0x81632c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  804470:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  804476:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  80447d:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  804481:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  804487:	89 15 28 63 81 00    	mov    %edx,0x816328
  ram_end->used = 1;
  80448d:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  804494:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  80449b:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  80449e:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  8044a5:	00 22 00 

  mem_sem = sys_sem_new(1);
  8044a8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8044af:	e8 3a 61 00 00       	call   80a5ee <sys_sem_new>
  8044b4:	a3 20 63 81 00       	mov    %eax,0x816320

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  8044b9:	a1 2c 63 81 00       	mov    0x81632c,%eax
  8044be:	a3 24 63 81 00       	mov    %eax,0x816324

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  8044c3:	c9                   	leave  
  8044c4:	c3                   	ret    

008044c5 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  8044c5:	55                   	push   %ebp
  8044c6:	89 e5                	mov    %esp,%ebp
  8044c8:	56                   	push   %esi
  8044c9:	53                   	push   %ebx
  8044ca:	83 ec 10             	sub    $0x10,%esp
  8044cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  8044d0:	85 db                	test   %ebx,%ebx
  8044d2:	0f 84 6f 01 00 00    	je     804647 <mem_free+0x182>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  8044d8:	f6 c3 03             	test   $0x3,%bl
  8044db:	74 1c                	je     8044f9 <mem_free+0x34>
  8044dd:	c7 44 24 08 10 28 81 	movl   $0x812810,0x8(%esp)
  8044e4:	00 
  8044e5:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  8044ec:	00 
  8044ed:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  8044f4:	e8 41 ab 00 00       	call   80f03a <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8044f9:	3b 1d 2c 63 81 00    	cmp    0x81632c,%ebx
  8044ff:	72 08                	jb     804509 <mem_free+0x44>
  804501:	3b 1d 28 63 81 00    	cmp    0x816328,%ebx
  804507:	72 1c                	jb     804525 <mem_free+0x60>
  804509:	c7 44 24 08 1b 29 81 	movl   $0x81291b,0x8(%esp)
  804510:	00 
  804511:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  804518:	00 
  804519:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  804520:	e8 15 ab 00 00       	call   80f03a <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804525:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80452c:	00 
  80452d:	a1 20 63 81 00       	mov    0x816320,%eax
  804532:	89 04 24             	mov    %eax,(%esp)
  804535:	e8 0b 64 00 00       	call   80a945 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80453a:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80453d:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  804541:	75 1c                	jne    80455f <mem_free+0x9a>
  804543:	c7 44 24 08 32 29 81 	movl   $0x812932,0x8(%esp)
  80454a:	00 
  80454b:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  804552:	00 
  804553:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  80455a:	e8 db aa 00 00       	call   80f03a <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  80455f:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  804563:	3b 05 24 63 81 00    	cmp    0x816324,%eax
  804569:	73 05                	jae    804570 <mem_free+0xab>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80456b:	a3 24 63 81 00       	mov    %eax,0x816324
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804570:	8b 15 2c 63 81 00    	mov    0x81632c,%edx
  804576:	39 d0                	cmp    %edx,%eax
  804578:	73 1c                	jae    804596 <mem_free+0xd1>
  80457a:	c7 44 24 08 46 29 81 	movl   $0x812946,0x8(%esp)
  804581:	00 
  804582:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  804589:	00 
  80458a:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  804591:	e8 a4 aa 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804596:	8b 35 28 63 81 00    	mov    0x816328,%esi
  80459c:	39 f0                	cmp    %esi,%eax
  80459e:	72 1c                	jb     8045bc <mem_free+0xf7>
  8045a0:	c7 44 24 08 5d 29 81 	movl   $0x81295d,0x8(%esp)
  8045a7:	00 
  8045a8:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  8045af:	00 
  8045b0:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  8045b7:	e8 7e aa 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  8045bc:	8b 4b f4             	mov    -0xc(%ebx),%ecx
  8045bf:	81 f9 00 00 22 00    	cmp    $0x220000,%ecx
  8045c5:	76 1c                	jbe    8045e3 <mem_free+0x11e>
  8045c7:	c7 44 24 08 34 28 81 	movl   $0x812834,0x8(%esp)
  8045ce:	00 
  8045cf:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  8045d6:	00 
  8045d7:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  8045de:	e8 57 aa 00 00       	call   80f03a <_panic>

  nmem = (struct mem *)&ram[mem->next];
  8045e3:	01 d1                	add    %edx,%ecx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  8045e5:	39 c8                	cmp    %ecx,%eax
  8045e7:	74 26                	je     80460f <mem_free+0x14a>
  8045e9:	80 79 08 00          	cmpb   $0x0,0x8(%ecx)
  8045ed:	75 20                	jne    80460f <mem_free+0x14a>
  8045ef:	39 ce                	cmp    %ecx,%esi
  8045f1:	74 1c                	je     80460f <mem_free+0x14a>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  8045f3:	3b 0d 24 63 81 00    	cmp    0x816324,%ecx
  8045f9:	75 05                	jne    804600 <mem_free+0x13b>
      lfree = mem;
  8045fb:	a3 24 63 81 00       	mov    %eax,0x816324
    }
    mem->next = nmem->next;
  804600:	8b 31                	mov    (%ecx),%esi
  804602:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  804605:	8b 09                	mov    (%ecx),%ecx
  804607:	89 c6                	mov    %eax,%esi
  804609:	29 d6                	sub    %edx,%esi
  80460b:	89 74 0a 04          	mov    %esi,0x4(%edx,%ecx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80460f:	89 d1                	mov    %edx,%ecx
  804611:	03 4b f8             	add    -0x8(%ebx),%ecx
  if (pmem != mem && pmem->used == 0) {
  804614:	39 c8                	cmp    %ecx,%eax
  804616:	74 22                	je     80463a <mem_free+0x175>
  804618:	80 79 08 00          	cmpb   $0x0,0x8(%ecx)
  80461c:	75 1c                	jne    80463a <mem_free+0x175>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80461e:	3b 05 24 63 81 00    	cmp    0x816324,%eax
  804624:	75 06                	jne    80462c <mem_free+0x167>
      lfree = pmem;
  804626:	89 0d 24 63 81 00    	mov    %ecx,0x816324
    }
    pmem->next = mem->next;
  80462c:	8b 43 f4             	mov    -0xc(%ebx),%eax
  80462f:	89 01                	mov    %eax,(%ecx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  804631:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804634:	29 d1                	sub    %edx,%ecx
  804636:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80463a:	a1 20 63 81 00       	mov    0x816320,%eax
  80463f:	89 04 24             	mov    %eax,(%esp)
  804642:	e8 89 62 00 00       	call   80a8d0 <sys_sem_signal>
}
  804647:	83 c4 10             	add    $0x10,%esp
  80464a:	5b                   	pop    %ebx
  80464b:	5e                   	pop    %esi
  80464c:	5d                   	pop    %ebp
  80464d:	c3                   	ret    

0080464e <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80464e:	55                   	push   %ebp
  80464f:	89 e5                	mov    %esp,%ebp
  804651:	57                   	push   %edi
  804652:	56                   	push   %esi
  804653:	53                   	push   %ebx
  804654:	83 ec 1c             	sub    $0x1c,%esp
  804657:	8b 5d 08             	mov    0x8(%ebp),%ebx
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80465a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80465d:	8d 70 03             	lea    0x3(%eax),%esi
  804660:	83 e6 fc             	and    $0xfffffffc,%esi

  if(newsize < MIN_SIZE_ALIGNED) {
  804663:	83 fe 0b             	cmp    $0xb,%esi
  804666:	76 0d                	jbe    804675 <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  804668:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  80466e:	76 0a                	jbe    80467a <mem_realloc+0x2c>
  804670:	e9 1d 01 00 00       	jmp    804792 <mem_realloc+0x144>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  804675:	be 0c 00 00 00       	mov    $0xc,%esi

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80467a:	a1 2c 63 81 00       	mov    0x81632c,%eax
  80467f:	39 d8                	cmp    %ebx,%eax
  804681:	77 08                	ja     80468b <mem_realloc+0x3d>
  804683:	3b 1d 28 63 81 00    	cmp    0x816328,%ebx
  804689:	72 1c                	jb     8046a7 <mem_realloc+0x59>
  80468b:	c7 44 24 08 77 29 81 	movl   $0x812977,0x8(%esp)
  804692:	00 
  804693:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  80469a:	00 
  80469b:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  8046a2:	e8 93 a9 00 00       	call   80f03a <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8046a7:	8d 53 f4             	lea    -0xc(%ebx),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8046aa:	29 c2                	sub    %eax,%edx
  8046ac:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8046af:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8046b2:	8d 78 f4             	lea    -0xc(%eax),%edi
  8046b5:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8046b7:	39 f7                	cmp    %esi,%edi
  8046b9:	73 1c                	jae    8046d7 <mem_realloc+0x89>
  8046bb:	c7 44 24 08 60 28 81 	movl   $0x812860,0x8(%esp)
  8046c2:	00 
  8046c3:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  8046ca:	00 
  8046cb:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  8046d2:	e8 63 a9 00 00       	call   80f03a <_panic>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    /* No change in size, simply return */
    return rmem;
  8046d7:	89 d8                	mov    %ebx,%eax
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  8046d9:	39 fe                	cmp    %edi,%esi
  8046db:	0f 84 b6 00 00 00    	je     804797 <mem_realloc+0x149>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8046e1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8046e8:	00 
  8046e9:	a1 20 63 81 00       	mov    0x816320,%eax
  8046ee:	89 04 24             	mov    %eax,(%esp)
  8046f1:	e8 4f 62 00 00       	call   80a945 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  8046f6:	a1 2c 63 81 00       	mov    0x81632c,%eax
  8046fb:	89 c2                	mov    %eax,%edx
  8046fd:	03 53 f4             	add    -0xc(%ebx),%edx
  if(mem2->used == 0) {
  804700:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804704:	75 3c                	jne    804742 <mem_realloc+0xf4>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804706:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804708:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80470b:	8d 74 3e 0c          	lea    0xc(%esi,%edi,1),%esi
    if (lfree == mem2) {
  80470f:	39 15 24 63 81 00    	cmp    %edx,0x816324
  804715:	75 09                	jne    804720 <mem_realloc+0xd2>
      lfree = (struct mem *)&ram[ptr2];
  804717:	8d 14 30             	lea    (%eax,%esi,1),%edx
  80471a:	89 15 24 63 81 00    	mov    %edx,0x816324
    }
    mem2 = (struct mem *)&ram[ptr2];
  804720:	8d 14 30             	lea    (%eax,%esi,1),%edx
    mem2->used = 0;
  804723:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804727:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  804729:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80472c:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  80472f:	89 73 f4             	mov    %esi,-0xc(%ebx)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804732:	8b 12                	mov    (%edx),%edx
  804734:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80473a:	74 45                	je     804781 <mem_realloc+0x133>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80473c:	89 74 10 04          	mov    %esi,0x4(%eax,%edx,1)
  804740:	eb 3f                	jmp    804781 <mem_realloc+0x133>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  804742:	8d 56 18             	lea    0x18(%esi),%edx
  804745:	39 d7                	cmp    %edx,%edi
  804747:	72 38                	jb     804781 <mem_realloc+0x133>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804749:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80474c:	8d 4c 0e 0c          	lea    0xc(%esi,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  804750:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  804753:	3b 15 24 63 81 00    	cmp    0x816324,%edx
  804759:	73 06                	jae    804761 <mem_realloc+0x113>
      lfree = mem2;
  80475b:	89 15 24 63 81 00    	mov    %edx,0x816324
    }
    mem2->used = 0;
  804761:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  804765:	8b 73 f4             	mov    -0xc(%ebx),%esi
  804768:	89 32                	mov    %esi,(%edx)
    mem2->prev = ptr;
  80476a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80476d:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  804770:	89 4b f4             	mov    %ecx,-0xc(%ebx)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804773:	8b 12                	mov    (%edx),%edx
  804775:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80477b:	74 04                	je     804781 <mem_realloc+0x133>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80477d:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804781:	a1 20 63 81 00       	mov    0x816320,%eax
  804786:	89 04 24             	mov    %eax,(%esp)
  804789:	e8 42 61 00 00       	call   80a8d0 <sys_sem_signal>
  return rmem;
  80478e:	89 d8                	mov    %ebx,%eax
  804790:	eb 05                	jmp    804797 <mem_realloc+0x149>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  804792:	b8 00 00 00 00       	mov    $0x0,%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  804797:	83 c4 1c             	add    $0x1c,%esp
  80479a:	5b                   	pop    %ebx
  80479b:	5e                   	pop    %esi
  80479c:	5f                   	pop    %edi
  80479d:	5d                   	pop    %ebp
  80479e:	c3                   	ret    

0080479f <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80479f:	55                   	push   %ebp
  8047a0:	89 e5                	mov    %esp,%ebp
  8047a2:	57                   	push   %edi
  8047a3:	56                   	push   %esi
  8047a4:	53                   	push   %ebx
  8047a5:	83 ec 1c             	sub    $0x1c,%esp
  8047a8:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8047ab:	85 f6                	test   %esi,%esi
  8047ad:	0f 84 69 01 00 00    	je     80491c <mem_malloc+0x17d>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  8047b3:	83 c6 03             	add    $0x3,%esi
  8047b6:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  8047b9:	83 fe 0b             	cmp    $0xb,%esi
  8047bc:	76 0d                	jbe    8047cb <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  8047be:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  8047c4:	76 0a                	jbe    8047d0 <mem_malloc+0x31>
  8047c6:	e9 58 01 00 00       	jmp    804923 <mem_malloc+0x184>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  8047cb:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  8047d0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8047d7:	00 
  8047d8:	a1 20 63 81 00       	mov    0x816320,%eax
  8047dd:	89 04 24             	mov    %eax,(%esp)
  8047e0:	e8 60 61 00 00       	call   80a945 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  8047e5:	8b 15 2c 63 81 00    	mov    0x81632c,%edx
  8047eb:	a1 24 63 81 00       	mov    0x816324,%eax
  8047f0:	29 d0                	sub    %edx,%eax
  8047f2:	b9 00 00 22 00       	mov    $0x220000,%ecx
  8047f7:	29 f1                	sub    %esi,%ecx
  8047f9:	e9 02 01 00 00       	jmp    804900 <mem_malloc+0x161>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  8047fe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804801:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804805:	0f 85 f3 00 00 00    	jne    8048fe <mem_malloc+0x15f>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80480b:	8b 3b                	mov    (%ebx),%edi
  80480d:	83 ef 0c             	sub    $0xc,%edi
  804810:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804812:	39 f7                	cmp    %esi,%edi
  804814:	0f 82 e4 00 00 00    	jb     8048fe <mem_malloc+0x15f>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80481a:	8d 4e 18             	lea    0x18(%esi),%ecx
  80481d:	39 f9                	cmp    %edi,%ecx
  80481f:	77 2c                	ja     80484d <mem_malloc+0xae>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  804821:	8d 4c 30 0c          	lea    0xc(%eax,%esi,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  804825:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  804828:	01 d1                	add    %edx,%ecx
          mem2->used = 0;
  80482a:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  80482e:	8b 3b                	mov    (%ebx),%edi
  804830:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  804832:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  804835:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804838:	89 3b                	mov    %edi,(%ebx)
          mem->used = 1;
  80483a:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80483e:	8b 01                	mov    (%ecx),%eax
  804840:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804845:	74 0a                	je     804851 <mem_malloc+0xb2>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804847:	89 7c 02 04          	mov    %edi,0x4(%edx,%eax,1)
  80484b:	eb 04                	jmp    804851 <mem_malloc+0xb2>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80484d:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  804851:	3b 1d 24 63 81 00    	cmp    0x816324,%ebx
  804857:	75 2c                	jne    804885 <mem_malloc+0xe6>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  804859:	8b 15 28 63 81 00    	mov    0x816328,%edx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80485f:	8b 0d 2c 63 81 00    	mov    0x81632c,%ecx
  804865:	89 d8                	mov    %ebx,%eax
  804867:	eb 06                	jmp    80486f <mem_malloc+0xd0>
  804869:	89 cf                	mov    %ecx,%edi
  80486b:	03 38                	add    (%eax),%edi
  80486d:	89 f8                	mov    %edi,%eax
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80486f:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  804873:	75 07                	jne    80487c <mem_malloc+0xdd>
  804875:	a3 24 63 81 00       	mov    %eax,0x816324
  80487a:	eb 09                	jmp    804885 <mem_malloc+0xe6>
  80487c:	39 c2                	cmp    %eax,%edx
  80487e:	75 e9                	jne    804869 <mem_malloc+0xca>
  804880:	a3 24 63 81 00       	mov    %eax,0x816324
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  804885:	a1 20 63 81 00       	mov    0x816320,%eax
  80488a:	89 04 24             	mov    %eax,(%esp)
  80488d:	e8 3e 60 00 00       	call   80a8d0 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804892:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  804896:	39 05 28 63 81 00    	cmp    %eax,0x816328
  80489c:	73 1c                	jae    8048ba <mem_malloc+0x11b>
  80489e:	c7 44 24 08 84 28 81 	movl   $0x812884,0x8(%esp)
  8048a5:	00 
  8048a6:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  8048ad:	00 
  8048ae:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  8048b5:	e8 80 a7 00 00       	call   80f03a <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  8048ba:	8d 43 0c             	lea    0xc(%ebx),%eax
  8048bd:	a8 03                	test   $0x3,%al
  8048bf:	74 1c                	je     8048dd <mem_malloc+0x13e>
  8048c1:	c7 44 24 08 b4 28 81 	movl   $0x8128b4,0x8(%esp)
  8048c8:	00 
  8048c9:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  8048d0:	00 
  8048d1:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  8048d8:	e8 5d a7 00 00       	call   80f03a <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  8048dd:	f6 c3 03             	test   $0x3,%bl
  8048e0:	74 46                	je     804928 <mem_malloc+0x189>
  8048e2:	c7 44 24 08 e4 28 81 	movl   $0x8128e4,0x8(%esp)
  8048e9:	00 
  8048ea:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  8048f1:	00 
  8048f2:	c7 04 24 07 29 81 00 	movl   $0x812907,(%esp)
  8048f9:	e8 3c a7 00 00       	call   80f03a <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  8048fe:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804900:	39 c8                	cmp    %ecx,%eax
  804902:	0f 82 f6 fe ff ff    	jb     8047fe <mem_malloc+0x5f>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  804908:	a1 20 63 81 00       	mov    0x816320,%eax
  80490d:	89 04 24             	mov    %eax,(%esp)
  804910:	e8 bb 5f 00 00       	call   80a8d0 <sys_sem_signal>
  return NULL;
  804915:	b8 00 00 00 00       	mov    $0x0,%eax
  80491a:	eb 0c                	jmp    804928 <mem_malloc+0x189>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  80491c:	b8 00 00 00 00       	mov    $0x0,%eax
  804921:	eb 05                	jmp    804928 <mem_malloc+0x189>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  804923:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  804928:	83 c4 1c             	add    $0x1c,%esp
  80492b:	5b                   	pop    %ebx
  80492c:	5e                   	pop    %esi
  80492d:	5f                   	pop    %edi
  80492e:	5d                   	pop    %ebp
  80492f:	c3                   	ret    

00804930 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  804930:	55                   	push   %ebp
  804931:	89 e5                	mov    %esp,%ebp
  804933:	56                   	push   %esi
  804934:	53                   	push   %ebx
  804935:	83 ec 10             	sub    $0x10,%esp
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  804938:	8b 75 0c             	mov    0xc(%ebp),%esi
  80493b:	0f af 75 08          	imul   0x8(%ebp),%esi
  80493f:	89 34 24             	mov    %esi,(%esp)
  804942:	e8 58 fe ff ff       	call   80479f <mem_malloc>
  804947:	89 c3                	mov    %eax,%ebx
  if (p) {
  804949:	85 c0                	test   %eax,%eax
  80494b:	74 14                	je     804961 <mem_calloc+0x31>
    /* zero the memory */
    memset(p, 0, count * size);
  80494d:	89 74 24 08          	mov    %esi,0x8(%esp)
  804951:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804958:	00 
  804959:	89 04 24             	mov    %eax,(%esp)
  80495c:	e8 96 af 00 00       	call   80f8f7 <memset>
  }
  return p;
}
  804961:	89 d8                	mov    %ebx,%eax
  804963:	83 c4 10             	add    $0x10,%esp
  804966:	5b                   	pop    %ebx
  804967:	5e                   	pop    %esi
  804968:	5d                   	pop    %ebp
  804969:	c3                   	ret    

0080496a <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80496a:	55                   	push   %ebp
  80496b:	89 e5                	mov    %esp,%ebp
  80496d:	56                   	push   %esi
  80496e:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80496f:	b8 63 63 a3 00       	mov    $0xa36363,%eax
  804974:	83 e0 fc             	and    $0xfffffffc,%eax
  804977:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  80497c:	c7 84 12 e0 53 b3 00 	movl   $0x0,0xb353e0(%edx,%edx,1)
  804983:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804987:	0f b7 b2 08 2a 81 00 	movzwl 0x812a08(%edx),%esi
  80498e:	b9 00 00 00 00       	mov    $0x0,%ecx
  804993:	eb 1c                	jmp    8049b1 <memp_init+0x47>
      memp->next = memp_tab[i];
  804995:	8b 9c 12 e0 53 b3 00 	mov    0xb353e0(%edx,%edx,1),%ebx
  80499c:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  80499e:	89 84 12 e0 53 b3 00 	mov    %eax,0xb353e0(%edx,%edx,1)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  8049a5:	0f b7 9a 24 2a 81 00 	movzwl 0x812a24(%edx),%ebx
  8049ac:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8049ae:	83 c1 01             	add    $0x1,%ecx
  8049b1:	66 39 f1             	cmp    %si,%cx
  8049b4:	75 df                	jne    804995 <memp_init+0x2b>
  8049b6:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8049b9:	83 fa 1c             	cmp    $0x1c,%edx
  8049bc:	75 be                	jne    80497c <memp_init+0x12>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8049be:	5b                   	pop    %ebx
  8049bf:	5e                   	pop    %esi
  8049c0:	5d                   	pop    %ebp
  8049c1:	c3                   	ret    

008049c2 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  8049c2:	55                   	push   %ebp
  8049c3:	89 e5                	mov    %esp,%ebp
  8049c5:	83 ec 18             	sub    $0x18,%esp
  8049c8:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  8049cb:	83 fa 0d             	cmp    $0xd,%edx
  8049ce:	76 1c                	jbe    8049ec <memp_malloc+0x2a>
  8049d0:	c7 44 24 08 91 29 81 	movl   $0x812991,0x8(%esp)
  8049d7:	00 
  8049d8:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  8049df:	00 
  8049e0:	c7 04 24 ae 29 81 00 	movl   $0x8129ae,(%esp)
  8049e7:	e8 4e a6 00 00       	call   80f03a <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  8049ec:	8b 04 95 e0 53 b3 00 	mov    0xb353e0(,%edx,4),%eax
  
  if (memp != NULL) {    
  8049f3:	85 c0                	test   %eax,%eax
  8049f5:	74 29                	je     804a20 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  8049f7:	8b 08                	mov    (%eax),%ecx
  8049f9:	89 0c 95 e0 53 b3 00 	mov    %ecx,0xb353e0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804a00:	a8 03                	test   $0x3,%al
  804a02:	74 1c                	je     804a20 <memp_malloc+0x5e>
  804a04:	c7 44 24 08 c4 29 81 	movl   $0x8129c4,0x8(%esp)
  804a0b:	00 
  804a0c:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  804a13:	00 
  804a14:	c7 04 24 ae 29 81 00 	movl   $0x8129ae,(%esp)
  804a1b:	e8 1a a6 00 00       	call   80f03a <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804a20:	c9                   	leave  
  804a21:	c3                   	ret    

00804a22 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  804a22:	55                   	push   %ebp
  804a23:	89 e5                	mov    %esp,%ebp
  804a25:	83 ec 18             	sub    $0x18,%esp
  804a28:	8b 55 08             	mov    0x8(%ebp),%edx
  804a2b:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  804a2e:	85 c0                	test   %eax,%eax
  804a30:	74 30                	je     804a62 <memp_free+0x40>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  804a32:	a8 03                	test   $0x3,%al
  804a34:	74 1c                	je     804a52 <memp_free+0x30>
  804a36:	c7 44 24 08 e8 29 81 	movl   $0x8129e8,0x8(%esp)
  804a3d:	00 
  804a3e:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  804a45:	00 
  804a46:	c7 04 24 ae 29 81 00 	movl   $0x8129ae,(%esp)
  804a4d:	e8 e8 a5 00 00       	call   80f03a <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  804a52:	8b 0c 95 e0 53 b3 00 	mov    0xb353e0(,%edx,4),%ecx
  804a59:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  804a5b:	89 04 95 e0 53 b3 00 	mov    %eax,0xb353e0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  804a62:	c9                   	leave  
  804a63:	c3                   	ret    
  804a64:	66 90                	xchg   %ax,%ax
  804a66:	66 90                	xchg   %ax,%ax
  804a68:	66 90                	xchg   %ax,%ax
  804a6a:	66 90                	xchg   %ax,%ax
  804a6c:	66 90                	xchg   %ax,%ax
  804a6e:	66 90                	xchg   %ax,%ax

00804a70 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  804a70:	55                   	push   %ebp
  804a71:	89 e5                	mov    %esp,%ebp
  804a73:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  804a76:	85 c9                	test   %ecx,%ecx
  804a78:	74 3c                	je     804ab6 <netif_remove+0x46>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  804a7a:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  804a7f:	39 c8                	cmp    %ecx,%eax
  804a81:	75 19                	jne    804a9c <netif_remove+0x2c>
    netif_list = netif->next;
  804a83:	8b 00                	mov    (%eax),%eax
  804a85:	a3 54 c2 b3 00       	mov    %eax,0xb3c254
  804a8a:	eb 18                	jmp    804aa4 <netif_remove+0x34>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  804a8c:	8b 10                	mov    (%eax),%edx
  804a8e:	39 ca                	cmp    %ecx,%edx
  804a90:	74 04                	je     804a96 <netif_remove+0x26>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804a92:	89 d0                	mov    %edx,%eax
  804a94:	eb 06                	jmp    804a9c <netif_remove+0x2c>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
  804a96:	8b 11                	mov    (%ecx),%edx
  804a98:	89 10                	mov    %edx,(%eax)
  804a9a:	eb 08                	jmp    804aa4 <netif_remove+0x34>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804a9c:	85 c0                	test   %eax,%eax
  804a9e:	66 90                	xchg   %ax,%ax
  804aa0:	75 ea                	jne    804a8c <netif_remove+0x1c>
  804aa2:	eb 12                	jmp    804ab6 <netif_remove+0x46>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804aa4:	39 0d 58 c2 b3 00    	cmp    %ecx,0xb3c258
  804aaa:	75 0a                	jne    804ab6 <netif_remove+0x46>
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804aac:	c7 05 58 c2 b3 00 00 	movl   $0x0,0xb3c258
  804ab3:	00 00 00 
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804ab6:	5d                   	pop    %ebp
  804ab7:	c3                   	ret    

00804ab8 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804ab8:	55                   	push   %ebp
  804ab9:	89 e5                	mov    %esp,%ebp
  804abb:	53                   	push   %ebx
  804abc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  804abf:	85 c9                	test   %ecx,%ecx
  804ac1:	74 2c                	je     804aef <netif_find+0x37>
    return NULL;
  }

  num = name[2] - '0';
  804ac3:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804ac7:	8d 50 d0             	lea    -0x30(%eax),%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804aca:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  804acf:	eb 18                	jmp    804ae9 <netif_find+0x31>
    if (num == netif->num &&
  804ad1:	38 50 31             	cmp    %dl,0x31(%eax)
  804ad4:	75 11                	jne    804ae7 <netif_find+0x2f>
  804ad6:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804ada:	38 19                	cmp    %bl,(%ecx)
  804adc:	75 09                	jne    804ae7 <netif_find+0x2f>
       name[0] == netif->name[0] &&
  804ade:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804ae2:	38 59 01             	cmp    %bl,0x1(%ecx)
  804ae5:	74 0d                	je     804af4 <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804ae7:	8b 00                	mov    (%eax),%eax
  804ae9:	85 c0                	test   %eax,%eax
  804aeb:	75 e4                	jne    804ad1 <netif_find+0x19>
  804aed:	eb 05                	jmp    804af4 <netif_find+0x3c>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  804aef:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  804af4:	5b                   	pop    %ebx
  804af5:	5d                   	pop    %ebp
  804af6:	c3                   	ret    

00804af7 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  804af7:	55                   	push   %ebp
  804af8:	89 e5                	mov    %esp,%ebp
  804afa:	57                   	push   %edi
  804afb:	56                   	push   %esi
  804afc:	53                   	push   %ebx
  804afd:	83 ec 1c             	sub    $0x1c,%esp
  804b00:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b03:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804b06:	8b 43 04             	mov    0x4(%ebx),%eax
  804b09:	39 06                	cmp    %eax,(%esi)
  804b0b:	74 53                	je     804b60 <netif_set_ipaddr+0x69>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  804b0d:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
    while (pcb != NULL) {
  804b12:	eb 19                	jmp    804b2d <netif_set_ipaddr+0x36>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804b14:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804b17:	39 08                	cmp    %ecx,(%eax)
  804b19:	75 0f                	jne    804b2a <netif_set_ipaddr+0x33>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  804b1b:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  804b1e:	89 04 24             	mov    %eax,(%esp)
  804b21:	e8 93 16 00 00       	call   8061b9 <tcp_abort>
        pcb = next;
  804b26:	89 f8                	mov    %edi,%eax
  804b28:	eb 03                	jmp    804b2d <netif_set_ipaddr+0x36>
      } else {
        pcb = pcb->next;
  804b2a:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  804b2d:	85 c0                	test   %eax,%eax
  804b2f:	75 e3                	jne    804b14 <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804b31:	a1 64 c2 b3 00       	mov    0xb3c264,%eax
  804b36:	eb 24                	jmp    804b5c <netif_set_ipaddr+0x65>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  804b38:	85 c0                	test   %eax,%eax
  804b3a:	74 1d                	je     804b59 <netif_set_ipaddr+0x62>
  804b3c:	8b 10                	mov    (%eax),%edx
  804b3e:	85 d2                	test   %edx,%edx
  804b40:	74 17                	je     804b59 <netif_set_ipaddr+0x62>
  804b42:	3b 53 04             	cmp    0x4(%ebx),%edx
  804b45:	75 12                	jne    804b59 <netif_set_ipaddr+0x62>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804b47:	85 f6                	test   %esi,%esi
  804b49:	74 07                	je     804b52 <netif_set_ipaddr+0x5b>
  804b4b:	8b 16                	mov    (%esi),%edx
  804b4d:	8d 76 00             	lea    0x0(%esi),%esi
  804b50:	eb 05                	jmp    804b57 <netif_set_ipaddr+0x60>
  804b52:	ba 00 00 00 00       	mov    $0x0,%edx
  804b57:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804b59:	8b 40 0c             	mov    0xc(%eax),%eax
  804b5c:	85 c0                	test   %eax,%eax
  804b5e:	75 d8                	jne    804b38 <netif_set_ipaddr+0x41>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  804b60:	85 f6                	test   %esi,%esi
  804b62:	74 04                	je     804b68 <netif_set_ipaddr+0x71>
  804b64:	8b 06                	mov    (%esi),%eax
  804b66:	eb 05                	jmp    804b6d <netif_set_ipaddr+0x76>
  804b68:	b8 00 00 00 00       	mov    $0x0,%eax
  804b6d:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  804b70:	83 c4 1c             	add    $0x1c,%esp
  804b73:	5b                   	pop    %ebx
  804b74:	5e                   	pop    %esi
  804b75:	5f                   	pop    %edi
  804b76:	5d                   	pop    %ebp
  804b77:	c3                   	ret    

00804b78 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  804b78:	55                   	push   %ebp
  804b79:	89 e5                	mov    %esp,%ebp
  804b7b:	57                   	push   %edi
  804b7c:	56                   	push   %esi
  804b7d:	53                   	push   %ebx
  804b7e:	83 ec 1c             	sub    $0x1c,%esp
  804b81:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b84:	8b 7d 10             	mov    0x10(%ebp),%edi
  804b87:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  804b8a:	8b 45 0c             	mov    0xc(%ebp),%eax
  804b8d:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b91:	89 1c 24             	mov    %ebx,(%esp)
  804b94:	e8 5e ff ff ff       	call   804af7 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804b99:	85 ff                	test   %edi,%edi
  804b9b:	74 04                	je     804ba1 <netif_set_addr+0x29>
  804b9d:	8b 07                	mov    (%edi),%eax
  804b9f:	eb 05                	jmp    804ba6 <netif_set_addr+0x2e>
  804ba1:	b8 00 00 00 00       	mov    $0x0,%eax
  804ba6:	89 43 08             	mov    %eax,0x8(%ebx)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  ip_addr_set(&(netif->gw), gw);
  804ba9:	85 f6                	test   %esi,%esi
  804bab:	74 04                	je     804bb1 <netif_set_addr+0x39>
  804bad:	8b 06                	mov    (%esi),%eax
  804baf:	eb 05                	jmp    804bb6 <netif_set_addr+0x3e>
  804bb1:	b8 00 00 00 00       	mov    $0x0,%eax
  804bb6:	89 43 0c             	mov    %eax,0xc(%ebx)
    struct ip_addr *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
  804bb9:	83 c4 1c             	add    $0x1c,%esp
  804bbc:	5b                   	pop    %ebx
  804bbd:	5e                   	pop    %esi
  804bbe:	5f                   	pop    %edi
  804bbf:	5d                   	pop    %ebp
  804bc0:	c3                   	ret    

00804bc1 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  804bc1:	55                   	push   %ebp
  804bc2:	89 e5                	mov    %esp,%ebp
  804bc4:	53                   	push   %ebx
  804bc5:	83 ec 14             	sub    $0x14,%esp
  804bc8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804bcb:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804bd2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804bd9:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804be0:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  804be4:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  804beb:	8b 45 18             	mov    0x18(%ebp),%eax
  804bee:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804bf1:	0f b6 05 18 54 b3 00 	movzbl 0xb35418,%eax
  804bf8:	8d 50 01             	lea    0x1(%eax),%edx
  804bfb:	88 15 18 54 b3 00    	mov    %dl,0xb35418
  804c01:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804c04:	8b 45 20             	mov    0x20(%ebp),%eax
  804c07:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  804c0a:	8b 45 14             	mov    0x14(%ebp),%eax
  804c0d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804c11:	8b 45 10             	mov    0x10(%ebp),%eax
  804c14:	89 44 24 08          	mov    %eax,0x8(%esp)
  804c18:	8b 45 0c             	mov    0xc(%ebp),%eax
  804c1b:	89 44 24 04          	mov    %eax,0x4(%esp)
  804c1f:	89 1c 24             	mov    %ebx,(%esp)
  804c22:	e8 51 ff ff ff       	call   804b78 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  804c27:	89 1c 24             	mov    %ebx,(%esp)
  804c2a:	ff 55 1c             	call   *0x1c(%ebp)
  804c2d:	84 c0                	test   %al,%al
  804c2f:	75 11                	jne    804c42 <netif_add+0x81>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  804c31:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  804c36:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804c38:	89 1d 54 c2 b3 00    	mov    %ebx,0xb3c254
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  804c3e:	89 d8                	mov    %ebx,%eax
  804c40:	eb 05                	jmp    804c47 <netif_add+0x86>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  804c42:	b8 00 00 00 00       	mov    $0x0,%eax
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  804c47:	83 c4 14             	add    $0x14,%esp
  804c4a:	5b                   	pop    %ebx
  804c4b:	5d                   	pop    %ebp
  804c4c:	c3                   	ret    

00804c4d <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  804c4d:	55                   	push   %ebp
  804c4e:	89 e5                	mov    %esp,%ebp
  804c50:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  804c53:	85 c0                	test   %eax,%eax
  804c55:	74 04                	je     804c5b <netif_set_gw+0xe>
  804c57:	8b 10                	mov    (%eax),%edx
  804c59:	eb 05                	jmp    804c60 <netif_set_gw+0x13>
  804c5b:	ba 00 00 00 00       	mov    $0x0,%edx
  804c60:	8b 45 08             	mov    0x8(%ebp),%eax
  804c63:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  804c66:	5d                   	pop    %ebp
  804c67:	c3                   	ret    

00804c68 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  804c68:	55                   	push   %ebp
  804c69:	89 e5                	mov    %esp,%ebp
  804c6b:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804c6e:	85 c0                	test   %eax,%eax
  804c70:	74 04                	je     804c76 <netif_set_netmask+0xe>
  804c72:	8b 10                	mov    (%eax),%edx
  804c74:	eb 05                	jmp    804c7b <netif_set_netmask+0x13>
  804c76:	ba 00 00 00 00       	mov    $0x0,%edx
  804c7b:	8b 45 08             	mov    0x8(%ebp),%eax
  804c7e:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  804c81:	5d                   	pop    %ebp
  804c82:	c3                   	ret    

00804c83 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  804c83:	55                   	push   %ebp
  804c84:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804c86:	8b 45 08             	mov    0x8(%ebp),%eax
  804c89:	a3 58 c2 b3 00       	mov    %eax,0xb3c258
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  804c8e:	5d                   	pop    %ebp
  804c8f:	c3                   	ret    

00804c90 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804c90:	55                   	push   %ebp
  804c91:	89 e5                	mov    %esp,%ebp
  804c93:	83 ec 18             	sub    $0x18,%esp
  804c96:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  804c99:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804c9d:	a8 01                	test   $0x1,%al
  804c9f:	75 23                	jne    804cc4 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  804ca1:	89 c1                	mov    %eax,%ecx
  804ca3:	83 c9 01             	or     $0x1,%ecx
  804ca6:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804ca9:	a8 20                	test   $0x20,%al
  804cab:	74 17                	je     804cc4 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  804cad:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804cb4:	00 
  804cb5:	8d 42 04             	lea    0x4(%edx),%eax
  804cb8:	89 44 24 04          	mov    %eax,0x4(%esp)
  804cbc:	89 14 24             	mov    %edx,(%esp)
  804cbf:	e8 10 54 00 00       	call   80a0d4 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  804cc4:	c9                   	leave  
  804cc5:	c3                   	ret    

00804cc6 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804cc6:	55                   	push   %ebp
  804cc7:	89 e5                	mov    %esp,%ebp
  804cc9:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  804ccc:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  804cd0:	f6 c2 01             	test   $0x1,%dl
  804cd3:	74 06                	je     804cdb <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804cd5:	83 e2 fe             	and    $0xfffffffe,%edx
  804cd8:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804cdb:	5d                   	pop    %ebp
  804cdc:	c3                   	ret    

00804cdd <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804cdd:	55                   	push   %ebp
  804cde:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804ce0:	8b 45 08             	mov    0x8(%ebp),%eax
  804ce3:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804ce7:	83 e0 01             	and    $0x1,%eax
}
  804cea:	5d                   	pop    %ebp
  804ceb:	c3                   	ret    
  804cec:	66 90                	xchg   %ax,%ax
  804cee:	66 90                	xchg   %ax,%ax

00804cf0 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804cf0:	55                   	push   %ebp
  804cf1:	89 e5                	mov    %esp,%ebp
  804cf3:	56                   	push   %esi
  804cf4:	53                   	push   %ebx
  804cf5:	83 ec 10             	sub    $0x10,%esp
  804cf8:	8b 55 08             	mov    0x8(%ebp),%edx
  804cfb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804cfe:	85 d2                	test   %edx,%edx
  804d00:	75 1c                	jne    804d1e <pbuf_header+0x2e>
  804d02:	c7 44 24 08 04 2b 81 	movl   $0x812b04,0x8(%esp)
  804d09:	00 
  804d0a:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  804d11:	00 
  804d12:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  804d19:	e8 1c a3 00 00       	call   80f03a <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  804d1e:	66 85 c9             	test   %cx,%cx
  804d21:	0f 84 a1 00 00 00    	je     804dc8 <pbuf_header+0xd8>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804d27:	89 cb                	mov    %ecx,%ebx

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  804d29:	66 85 c9             	test   %cx,%cx
  804d2c:	79 24                	jns    804d52 <pbuf_header+0x62>
    increment_magnitude = -header_size_increment;
  804d2e:	f7 db                	neg    %ebx
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804d30:	66 3b 5a 0a          	cmp    0xa(%edx),%bx
  804d34:	76 1c                	jbe    804d52 <pbuf_header+0x62>
  804d36:	c7 44 24 08 55 2a 81 	movl   $0x812a55,0x8(%esp)
  804d3d:	00 
  804d3e:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  804d45:	00 
  804d46:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  804d4d:	e8 e8 a2 00 00       	call   80f03a <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804d52:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  804d56:	8b 72 04             	mov    0x4(%edx),%esi

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804d59:	66 83 f8 03          	cmp    $0x3,%ax
  804d5d:	74 05                	je     804d64 <pbuf_header+0x74>
  804d5f:	66 85 c0             	test   %ax,%ax
  804d62:	75 13                	jne    804d77 <pbuf_header+0x87>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804d64:	0f bf c1             	movswl %cx,%eax
  804d67:	29 c6                	sub    %eax,%esi
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804d69:	8d 5a 10             	lea    0x10(%edx),%ebx
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
  804d6c:	b8 01 00 00 00       	mov    $0x1,%eax
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804d71:	39 de                	cmp    %ebx,%esi
  804d73:	73 41                	jae    804db6 <pbuf_header+0xc6>
  804d75:	eb 56                	jmp    804dcd <pbuf_header+0xdd>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804d77:	83 e8 01             	sub    $0x1,%eax
  804d7a:	66 83 f8 01          	cmp    $0x1,%ax
  804d7e:	77 1a                	ja     804d9a <pbuf_header+0xaa>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  804d80:	b8 01 00 00 00       	mov    $0x1,%eax
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804d85:	66 85 c9             	test   %cx,%cx
  804d88:	79 43                	jns    804dcd <pbuf_header+0xdd>
  804d8a:	66 3b 5a 0a          	cmp    0xa(%edx),%bx
  804d8e:	77 3d                	ja     804dcd <pbuf_header+0xdd>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  804d90:	0f bf c1             	movswl %cx,%eax
  804d93:	29 c6                	sub    %eax,%esi
  804d95:	89 72 04             	mov    %esi,0x4(%edx)
  804d98:	eb 1f                	jmp    804db9 <pbuf_header+0xc9>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  804d9a:	c7 44 24 08 73 2a 81 	movl   $0x812a73,0x8(%esp)
  804da1:	00 
  804da2:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  804da9:	00 
  804daa:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  804db1:	e8 84 a2 00 00       	call   80f03a <_panic>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804db6:	89 72 04             	mov    %esi,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  804db9:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  804dbd:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804dc1:	b8 00 00 00 00       	mov    $0x0,%eax
  804dc6:	eb 05                	jmp    804dcd <pbuf_header+0xdd>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  804dc8:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  804dcd:	83 c4 10             	add    $0x10,%esp
  804dd0:	5b                   	pop    %ebx
  804dd1:	5e                   	pop    %esi
  804dd2:	5d                   	pop    %ebp
  804dd3:	c3                   	ret    

00804dd4 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804dd4:	55                   	push   %ebp
  804dd5:	89 e5                	mov    %esp,%ebp
  804dd7:	56                   	push   %esi
  804dd8:	53                   	push   %ebx
  804dd9:	83 ec 10             	sub    $0x10,%esp
  804ddc:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804ddf:	85 d2                	test   %edx,%edx
  804de1:	75 1c                	jne    804dff <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  804de3:	c7 44 24 08 04 2b 81 	movl   $0x812b04,0x8(%esp)
  804dea:	00 
  804deb:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  804df2:	00 
  804df3:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  804dfa:	e8 3b a2 00 00       	call   80f03a <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804dff:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  804e03:	0f 86 99 00 00 00    	jbe    804ea2 <pbuf_free+0xce>
  804e09:	c7 44 24 08 81 2a 81 	movl   $0x812a81,0x8(%esp)
  804e10:	00 
  804e11:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  804e18:	00 
  804e19:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  804e20:	e8 15 a2 00 00       	call   80f03a <_panic>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  804e25:	89 f2                	mov    %esi,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804e27:	0f b7 4a 0e          	movzwl 0xe(%edx),%ecx
  804e2b:	66 85 c9             	test   %cx,%cx
  804e2e:	75 1c                	jne    804e4c <pbuf_free+0x78>
  804e30:	c7 44 24 08 96 2a 81 	movl   $0x812a96,0x8(%esp)
  804e37:	00 
  804e38:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  804e3f:	00 
  804e40:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  804e47:	e8 ee a1 00 00       	call   80f03a <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  804e4c:	83 e9 01             	sub    $0x1,%ecx
  804e4f:	66 89 4a 0e          	mov    %cx,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  804e53:	66 85 c9             	test   %cx,%cx
  804e56:	75 54                	jne    804eac <pbuf_free+0xd8>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  804e58:	8b 32                	mov    (%edx),%esi
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  804e5a:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  804e5e:	66 83 f8 03          	cmp    $0x3,%ax
  804e62:	75 12                	jne    804e76 <pbuf_free+0xa2>
        memp_free(MEMP_PBUF_POOL, p);
  804e64:	89 54 24 04          	mov    %edx,0x4(%esp)
  804e68:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804e6f:	e8 ae fb ff ff       	call   804a22 <memp_free>
  804e74:	eb 23                	jmp    804e99 <pbuf_free+0xc5>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804e76:	83 e8 01             	sub    $0x1,%eax
  804e79:	66 83 f8 01          	cmp    $0x1,%ax
  804e7d:	77 12                	ja     804e91 <pbuf_free+0xbd>
        memp_free(MEMP_PBUF, p);
  804e7f:	89 54 24 04          	mov    %edx,0x4(%esp)
  804e83:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  804e8a:	e8 93 fb ff ff       	call   804a22 <memp_free>
  804e8f:	eb 08                	jmp    804e99 <pbuf_free+0xc5>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  804e91:	89 14 24             	mov    %edx,(%esp)
  804e94:	e8 2c f6 ff ff       	call   8044c5 <mem_free>
      }
      count++;
  804e99:	83 c3 01             	add    $0x1,%ebx
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  804e9c:	85 f6                	test   %esi,%esi
  804e9e:	75 85                	jne    804e25 <pbuf_free+0x51>
  804ea0:	eb 0a                	jmp    804eac <pbuf_free+0xd8>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804ea2:	bb 00 00 00 00       	mov    $0x0,%ebx
  804ea7:	e9 7b ff ff ff       	jmp    804e27 <pbuf_free+0x53>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804eac:	89 d8                	mov    %ebx,%eax
  804eae:	83 c4 10             	add    $0x10,%esp
  804eb1:	5b                   	pop    %ebx
  804eb2:	5e                   	pop    %esi
  804eb3:	5d                   	pop    %ebp
  804eb4:	c3                   	ret    

00804eb5 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  804eb5:	55                   	push   %ebp
  804eb6:	89 e5                	mov    %esp,%ebp
  804eb8:	57                   	push   %edi
  804eb9:	56                   	push   %esi
  804eba:	53                   	push   %ebx
  804ebb:	83 ec 1c             	sub    $0x1c,%esp
  804ebe:	8b 45 08             	mov    0x8(%ebp),%eax
  804ec1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  804ec4:	83 f8 01             	cmp    $0x1,%eax
  804ec7:	74 11                	je     804eda <pbuf_alloc+0x25>
  804ec9:	83 f8 01             	cmp    $0x1,%eax
  804ecc:	72 14                	jb     804ee2 <pbuf_alloc+0x2d>
  804ece:	83 f8 02             	cmp    $0x2,%eax
  804ed1:	74 19                	je     804eec <pbuf_alloc+0x37>
  804ed3:	83 f8 03             	cmp    $0x3,%eax
  804ed6:	74 3a                	je     804f12 <pbuf_alloc+0x5d>
  804ed8:	eb 1c                	jmp    804ef6 <pbuf_alloc+0x41>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804eda:	bf 00 00 00 00       	mov    $0x0,%edi
  804edf:	90                   	nop
  804ee0:	eb 05                	jmp    804ee7 <pbuf_alloc+0x32>
  switch (layer) {
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  804ee2:	bf 14 00 00 00       	mov    $0x14,%edi
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  804ee7:	83 c7 14             	add    $0x14,%edi
  804eea:	eb 05                	jmp    804ef1 <pbuf_alloc+0x3c>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804eec:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  804ef1:	83 c7 0e             	add    $0xe,%edi
    break;
  804ef4:	eb 21                	jmp    804f17 <pbuf_alloc+0x62>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804ef6:	c7 44 24 08 ac 2a 81 	movl   $0x812aac,0x8(%esp)
  804efd:	00 
  804efe:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  804f05:	00 
  804f06:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  804f0d:	e8 28 a1 00 00       	call   80f03a <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804f12:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  804f17:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  804f1b:	77 0f                	ja     804f2c <pbuf_alloc+0x77>
  804f1d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804f21:	0f 82 6a 01 00 00    	jb     805091 <pbuf_alloc+0x1dc>
  804f27:	e9 a5 01 00 00       	jmp    8050d1 <pbuf_alloc+0x21c>
  804f2c:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  804f30:	0f 85 cb 01 00 00    	jne    805101 <pbuf_alloc+0x24c>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  804f36:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804f3d:	e8 80 fa ff ff       	call   8049c2 <memp_malloc>
  804f42:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  804f44:	85 c0                	test   %eax,%eax
  804f46:	0f 84 df 01 00 00    	je     80512b <pbuf_alloc+0x276>
      return NULL;
    }
    p->type = type;
  804f4c:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804f50:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804f56:	0f b7 ff             	movzwl %di,%edi
  804f59:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  804f5d:	83 e2 fc             	and    $0xfffffffc,%edx
  804f60:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  804f63:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804f67:	0f b7 db             	movzwl %bx,%ebx
  804f6a:	83 c7 03             	add    $0x3,%edi
  804f6d:	83 e7 fc             	and    $0xfffffffc,%edi
  804f70:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804f75:	29 f8                	sub    %edi,%eax
  804f77:	39 d8                	cmp    %ebx,%eax
  804f79:	0f 4f c3             	cmovg  %ebx,%eax
  804f7c:	66 89 46 0a          	mov    %ax,0xa(%esi)
  804f80:	0f b7 c0             	movzwl %ax,%eax
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804f83:	8d be e0 07 00 00    	lea    0x7e0(%esi),%edi
  804f89:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804f8c:	01 c2                	add    %eax,%edx
  804f8e:	39 d7                	cmp    %edx,%edi
  804f90:	73 1c                	jae    804fae <pbuf_alloc+0xf9>
  804f92:	c7 44 24 08 c4 2b 81 	movl   $0x812bc4,0x8(%esp)
  804f99:	00 
  804f9a:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  804fa1:	00 
  804fa2:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  804fa9:	e8 8c a0 00 00       	call   80f03a <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  804fae:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  804fb4:	29 c3                	sub    %eax,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  804fb6:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  804fb8:	e9 c7 00 00 00       	jmp    805084 <pbuf_alloc+0x1cf>
      q = memp_malloc(MEMP_PBUF_POOL);
  804fbd:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804fc4:	e8 f9 f9 ff ff       	call   8049c2 <memp_malloc>
      if (q == NULL) {
  804fc9:	85 c0                	test   %eax,%eax
  804fcb:	75 12                	jne    804fdf <pbuf_alloc+0x12a>
        /* free chain so far allocated */
        pbuf_free(p);
  804fcd:	89 34 24             	mov    %esi,(%esp)
  804fd0:	e8 ff fd ff ff       	call   804dd4 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  804fd5:	b8 00 00 00 00       	mov    $0x0,%eax
  804fda:	e9 5f 01 00 00       	jmp    80513e <pbuf_alloc+0x289>
      }
      q->type = type;
  804fdf:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804fe3:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804fe7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  804fed:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804fef:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  804ff5:	7e 1c                	jle    805013 <pbuf_alloc+0x15e>
  804ff7:	c7 44 24 08 c7 2a 81 	movl   $0x812ac7,0x8(%esp)
  804ffe:	00 
  804fff:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  805006:	00 
  805007:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  80500e:	e8 27 a0 00 00       	call   80f03a <_panic>
      q->tot_len = (u16_t)rem_len;
  805013:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  805017:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  80501c:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  805021:	0f 46 cb             	cmovbe %ebx,%ecx
  805024:	66 89 48 0a          	mov    %cx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  805028:	8d 50 10             	lea    0x10(%eax),%edx
  80502b:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80502e:	f6 c2 03             	test   $0x3,%dl
  805031:	74 1c                	je     80504f <pbuf_alloc+0x19a>
  805033:	c7 44 24 08 f8 2b 81 	movl   $0x812bf8,0x8(%esp)
  80503a:	00 
  80503b:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  805042:	00 
  805043:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  80504a:	e8 eb 9f 00 00       	call   80f03a <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80504f:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  805053:	03 56 04             	add    0x4(%esi),%edx
  805056:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805059:	73 1c                	jae    805077 <pbuf_alloc+0x1c2>
  80505b:	c7 44 24 08 c4 2b 81 	movl   $0x812bc4,0x8(%esp)
  805062:	00 
  805063:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  80506a:	00 
  80506b:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  805072:	e8 c3 9f 00 00       	call   80f03a <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  805077:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80507d:	0f b7 c9             	movzwl %cx,%ecx
  805080:	29 cb                	sub    %ecx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  805082:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  805084:	85 db                	test   %ebx,%ebx
  805086:	0f 8f 31 ff ff ff    	jg     804fbd <pbuf_alloc+0x108>
  80508c:	e9 8c 00 00 00       	jmp    80511d <pbuf_alloc+0x268>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  805091:	0f b7 ff             	movzwl %di,%edi
  805094:	8d 57 13             	lea    0x13(%edi),%edx
  805097:	83 e2 fc             	and    $0xfffffffc,%edx
  80509a:	0f b7 c3             	movzwl %bx,%eax
  80509d:	83 c0 03             	add    $0x3,%eax
  8050a0:	83 e0 fc             	and    $0xfffffffc,%eax
  8050a3:	01 d0                	add    %edx,%eax
  8050a5:	89 04 24             	mov    %eax,(%esp)
  8050a8:	e8 f2 f6 ff ff       	call   80479f <mem_malloc>
  8050ad:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8050af:	85 c0                	test   %eax,%eax
  8050b1:	74 7f                	je     805132 <pbuf_alloc+0x27d>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  8050b3:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  8050b7:	83 e0 fc             	and    $0xfffffffc,%eax
  8050ba:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  8050bd:	66 89 5e 08          	mov    %bx,0x8(%esi)
  8050c1:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  8050c5:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  8050cb:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  8050cf:	eb 4c                	jmp    80511d <pbuf_alloc+0x268>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  8050d1:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8050d8:	e8 e5 f8 ff ff       	call   8049c2 <memp_malloc>
  8050dd:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8050df:	85 c0                	test   %eax,%eax
  8050e1:	74 56                	je     805139 <pbuf_alloc+0x284>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  8050e3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  8050ea:	66 89 58 08          	mov    %bx,0x8(%eax)
  8050ee:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  8050f2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  8050f8:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  8050fc:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  8050ff:	eb 1c                	jmp    80511d <pbuf_alloc+0x268>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  805101:	c7 44 24 08 db 2a 81 	movl   $0x812adb,0x8(%esp)
  805108:	00 
  805109:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  805110:	00 
  805111:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  805118:	e8 1d 9f 00 00       	call   80f03a <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80511d:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  805123:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  805127:	89 f0                	mov    %esi,%eax
  805129:	eb 13                	jmp    80513e <pbuf_alloc+0x289>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      return NULL;
  80512b:	b8 00 00 00 00       	mov    $0x0,%eax
  805130:	eb 0c                	jmp    80513e <pbuf_alloc+0x289>
    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
  805132:	b8 00 00 00 00       	mov    $0x0,%eax
  805137:	eb 05                	jmp    80513e <pbuf_alloc+0x289>
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    if (p == NULL) {
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  805139:	b8 00 00 00 00       	mov    $0x0,%eax
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  80513e:	83 c4 1c             	add    $0x1c,%esp
  805141:	5b                   	pop    %ebx
  805142:	5e                   	pop    %esi
  805143:	5f                   	pop    %edi
  805144:	5d                   	pop    %ebp
  805145:	c3                   	ret    

00805146 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  805146:	55                   	push   %ebp
  805147:	89 e5                	mov    %esp,%ebp
  805149:	56                   	push   %esi
  80514a:	53                   	push   %ebx
  80514b:	83 ec 10             	sub    $0x10,%esp
  80514e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805151:	8b 55 0c             	mov    0xc(%ebp),%edx
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  805154:	85 db                	test   %ebx,%ebx
  805156:	75 1c                	jne    805174 <pbuf_realloc+0x2e>
  805158:	c7 44 24 08 f6 2a 81 	movl   $0x812af6,0x8(%esp)
  80515f:	00 
  805160:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  805167:	00 
  805168:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  80516f:	e8 c6 9e 00 00       	call   80f03a <_panic>
  805174:	89 d6                	mov    %edx,%esi
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  805176:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  80517a:	76 1c                	jbe    805198 <pbuf_realloc+0x52>
  80517c:	c7 44 24 08 0e 2b 81 	movl   $0x812b0e,0x8(%esp)
  805183:	00 
  805184:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  80518b:	00 
  80518c:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  805193:	e8 a2 9e 00 00       	call   80f03a <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  805198:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80519c:	66 39 d0             	cmp    %dx,%ax
  80519f:	0f 86 be 00 00 00    	jbe    805263 <pbuf_realloc+0x11d>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  8051a5:	0f b7 d2             	movzwl %dx,%edx
  8051a8:	0f b7 c0             	movzwl %ax,%eax
  8051ab:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  8051ad:	eb 4c                	jmp    8051fb <pbuf_realloc+0xb5>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  8051af:	29 c6                	sub    %eax,%esi
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  8051b1:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  8051b7:	7e 1c                	jle    8051d5 <pbuf_realloc+0x8f>
  8051b9:	c7 44 24 08 29 2b 81 	movl   $0x812b29,0x8(%esp)
  8051c0:	00 
  8051c1:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  8051c8:	00 
  8051c9:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  8051d0:	e8 65 9e 00 00       	call   80f03a <_panic>
    q->tot_len += (u16_t)grow;
  8051d5:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  8051d9:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  8051db:	85 db                	test   %ebx,%ebx
  8051dd:	75 1c                	jne    8051fb <pbuf_realloc+0xb5>
  8051df:	c7 44 24 08 3a 2b 81 	movl   $0x812b3a,0x8(%esp)
  8051e6:	00 
  8051e7:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  8051ee:	00 
  8051ef:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  8051f6:	e8 3f 9e 00 00       	call   80f03a <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  8051fb:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8051ff:	66 39 c6             	cmp    %ax,%si
  805202:	77 ab                	ja     8051af <pbuf_realloc+0x69>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  805204:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  805208:	75 3d                	jne    805247 <pbuf_realloc+0x101>
  80520a:	66 39 c6             	cmp    %ax,%si
  80520d:	74 38                	je     805247 <pbuf_realloc+0x101>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80520f:	8b 4b 04             	mov    0x4(%ebx),%ecx
  805212:	29 d9                	sub    %ebx,%ecx
  805214:	0f b7 c6             	movzwl %si,%eax
  805217:	01 c8                	add    %ecx,%eax
  805219:	89 44 24 04          	mov    %eax,0x4(%esp)
  80521d:	89 1c 24             	mov    %ebx,(%esp)
  805220:	e8 29 f4 ff ff       	call   80464e <mem_realloc>
  805225:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  805227:	85 c0                	test   %eax,%eax
  805229:	75 1c                	jne    805247 <pbuf_realloc+0x101>
  80522b:	c7 44 24 08 52 2b 81 	movl   $0x812b52,0x8(%esp)
  805232:	00 
  805233:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  80523a:	00 
  80523b:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  805242:	e8 f3 9d 00 00       	call   80f03a <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  805247:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  80524b:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80524f:	8b 03                	mov    (%ebx),%eax
  805251:	85 c0                	test   %eax,%eax
  805253:	74 08                	je     80525d <pbuf_realloc+0x117>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  805255:	89 04 24             	mov    %eax,(%esp)
  805258:	e8 77 fb ff ff       	call   804dd4 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  80525d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  805263:	83 c4 10             	add    $0x10,%esp
  805266:	5b                   	pop    %ebx
  805267:	5e                   	pop    %esi
  805268:	5d                   	pop    %ebp
  805269:	c3                   	ret    

0080526a <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80526a:	55                   	push   %ebp
  80526b:	89 e5                	mov    %esp,%ebp
  80526d:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  805270:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  805275:	eb 05                	jmp    80527c <pbuf_clen+0x12>
    ++len;
  805277:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  80527a:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  80527c:	85 d2                	test   %edx,%edx
  80527e:	75 f7                	jne    805277 <pbuf_clen+0xd>
    ++len;
    p = p->next;
  }
  return len;
}
  805280:	5d                   	pop    %ebp
  805281:	c3                   	ret    

00805282 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  805282:	55                   	push   %ebp
  805283:	89 e5                	mov    %esp,%ebp
  805285:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  805288:	85 c0                	test   %eax,%eax
  80528a:	74 05                	je     805291 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80528c:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  805291:	5d                   	pop    %ebp
  805292:	c3                   	ret    

00805293 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  805293:	55                   	push   %ebp
  805294:	89 e5                	mov    %esp,%ebp
  805296:	53                   	push   %ebx
  805297:	83 ec 14             	sub    $0x14,%esp
  80529a:	8b 45 08             	mov    0x8(%ebp),%eax
  80529d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  8052a0:	85 c0                	test   %eax,%eax
  8052a2:	74 04                	je     8052a8 <pbuf_cat+0x15>
  8052a4:	85 db                	test   %ebx,%ebx
  8052a6:	75 26                	jne    8052ce <pbuf_cat+0x3b>
  8052a8:	c7 44 24 08 28 2c 81 	movl   $0x812c28,0x8(%esp)
  8052af:	00 
  8052b0:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  8052b7:	00 
  8052b8:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  8052bf:	e8 76 9d 00 00       	call   80f03a <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  8052c4:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  8052c8:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  8052cc:	89 d0                	mov    %edx,%eax
  8052ce:	8b 10                	mov    (%eax),%edx
  8052d0:	85 d2                	test   %edx,%edx
  8052d2:	75 f0                	jne    8052c4 <pbuf_cat+0x31>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  8052d4:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  8052d8:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  8052dc:	74 1c                	je     8052fa <pbuf_cat+0x67>
  8052de:	c7 44 24 08 60 2c 81 	movl   $0x812c60,0x8(%esp)
  8052e5:	00 
  8052e6:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  8052ed:	00 
  8052ee:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  8052f5:	e8 40 9d 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  8052fa:	66 03 53 08          	add    0x8(%ebx),%dx
  8052fe:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  805302:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  805304:	83 c4 14             	add    $0x14,%esp
  805307:	5b                   	pop    %ebx
  805308:	5d                   	pop    %ebp
  805309:	c3                   	ret    

0080530a <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80530a:	55                   	push   %ebp
  80530b:	89 e5                	mov    %esp,%ebp
  80530d:	53                   	push   %ebx
  80530e:	83 ec 14             	sub    $0x14,%esp
  805311:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  805314:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805318:	8b 45 08             	mov    0x8(%ebp),%eax
  80531b:	89 04 24             	mov    %eax,(%esp)
  80531e:	e8 70 ff ff ff       	call   805293 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  805323:	89 1c 24             	mov    %ebx,(%esp)
  805326:	e8 57 ff ff ff       	call   805282 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80532b:	83 c4 14             	add    $0x14,%esp
  80532e:	5b                   	pop    %ebx
  80532f:	5d                   	pop    %ebp
  805330:	c3                   	ret    

00805331 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  805331:	55                   	push   %ebp
  805332:	89 e5                	mov    %esp,%ebp
  805334:	57                   	push   %edi
  805335:	56                   	push   %esi
  805336:	53                   	push   %ebx
  805337:	83 ec 1c             	sub    $0x1c,%esp
  80533a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  80533d:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80533f:	85 f6                	test   %esi,%esi
  805341:	0f 84 86 00 00 00    	je     8053cd <pbuf_dechain+0x9c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  805347:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  80534b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80534f:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  805353:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  805356:	0f b7 fa             	movzwl %dx,%edi
  805359:	0f b7 c8             	movzwl %ax,%ecx
  80535c:	29 cf                	sub    %ecx,%edi
  80535e:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  805361:	74 1c                	je     80537f <pbuf_dechain+0x4e>
  805363:	c7 44 24 08 90 2c 81 	movl   $0x812c90,0x8(%esp)
  80536a:	00 
  80536b:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  805372:	00 
  805373:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  80537a:	e8 bb 9c 00 00       	call   80f03a <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80537f:	29 c2                	sub    %eax,%edx
  805381:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  805385:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80538b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80538f:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  805393:	89 34 24             	mov    %esi,(%esp)
  805396:	e8 39 fa ff ff       	call   804dd4 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80539b:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  80539f:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  8053a3:	74 1c                	je     8053c1 <pbuf_dechain+0x90>
  8053a5:	c7 44 24 08 6d 2b 81 	movl   $0x812b6d,0x8(%esp)
  8053ac:	00 
  8053ad:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  8053b4:	00 
  8053b5:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  8053bc:	e8 79 9c 00 00       	call   80f03a <_panic>
  return ((tail_gone > 0) ? NULL : q);
  8053c1:	84 c0                	test   %al,%al
  8053c3:	b8 00 00 00 00       	mov    $0x0,%eax
  8053c8:	0f 44 c6             	cmove  %esi,%eax
  8053cb:	eb 0f                	jmp    8053dc <pbuf_dechain+0xab>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  8053cd:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8053d1:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  8053d5:	75 ce                	jne    8053a5 <pbuf_dechain+0x74>
  return ((tail_gone > 0) ? NULL : q);
  8053d7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8053dc:	83 c4 1c             	add    $0x1c,%esp
  8053df:	5b                   	pop    %ebx
  8053e0:	5e                   	pop    %esi
  8053e1:	5f                   	pop    %edi
  8053e2:	5d                   	pop    %ebp
  8053e3:	c3                   	ret    

008053e4 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  8053e4:	55                   	push   %ebp
  8053e5:	89 e5                	mov    %esp,%ebp
  8053e7:	57                   	push   %edi
  8053e8:	56                   	push   %esi
  8053e9:	53                   	push   %ebx
  8053ea:	83 ec 1c             	sub    $0x1c,%esp
  8053ed:	8b 75 08             	mov    0x8(%ebp),%esi
  8053f0:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  8053f3:	85 f6                	test   %esi,%esi
  8053f5:	74 0e                	je     805405 <pbuf_copy+0x21>
  8053f7:	85 db                	test   %ebx,%ebx
  8053f9:	74 0a                	je     805405 <pbuf_copy+0x21>
  8053fb:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8053ff:	66 39 46 08          	cmp    %ax,0x8(%esi)
  805403:	73 1c                	jae    805421 <pbuf_copy+0x3d>
  805405:	c7 44 24 08 b4 2c 81 	movl   $0x812cb4,0x8(%esp)
  80540c:	00 
  80540d:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  805414:	00 
  805415:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  80541c:	e8 19 9c 00 00       	call   80f03a <_panic>
  805421:	bf 00 00 00 00       	mov    $0x0,%edi
  805426:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  80542c:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  805430:	85 f6                	test   %esi,%esi
  805432:	75 1c                	jne    805450 <pbuf_copy+0x6c>
  805434:	c7 44 24 08 82 2b 81 	movl   $0x812b82,0x8(%esp)
  80543b:	00 
  80543c:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  805443:	00 
  805444:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  80544b:	e8 ea 9b 00 00       	call   80f03a <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  805450:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  805454:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  805458:	29 c1                	sub    %eax,%ecx
  80545a:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80545e:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805462:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  805464:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  805468:	66 2b 45 e6          	sub    -0x1a(%ebp),%ax
  80546c:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  805470:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  805474:	39 d1                	cmp    %edx,%ecx
  805476:	0f 4c c7             	cmovl  %edi,%eax
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  805479:	89 c7                	mov    %eax,%edi
  80547b:	0f b7 c0             	movzwl %ax,%eax
  80547e:	89 44 24 08          	mov    %eax,0x8(%esp)
  805482:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805486:	03 43 04             	add    0x4(%ebx),%eax
  805489:	89 44 24 04          	mov    %eax,0x4(%esp)
  80548d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  805491:	03 46 04             	add    0x4(%esi),%eax
  805494:	89 04 24             	mov    %eax,(%esp)
  805497:	e8 10 a5 00 00       	call   80f9ac <memcpy>
    offset_to += len;
  80549c:	66 01 7d e4          	add    %di,-0x1c(%ebp)
    offset_from += len;
  8054a0:	66 01 7d e6          	add    %di,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  8054a4:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8054a8:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  8054ac:	76 1c                	jbe    8054ca <pbuf_copy+0xe6>
  8054ae:	c7 44 24 08 8f 2b 81 	movl   $0x812b8f,0x8(%esp)
  8054b5:	00 
  8054b6:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  8054bd:	00 
  8054be:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  8054c5:	e8 70 9b 00 00       	call   80f03a <_panic>
    if (offset_to == p_to->len) {
  8054ca:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  8054ce:	75 08                	jne    8054d8 <pbuf_copy+0xf4>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  8054d0:	8b 36                	mov    (%esi),%esi
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  8054d2:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  8054d8:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8054dc:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  8054e0:	76 1c                	jbe    8054fe <pbuf_copy+0x11a>
  8054e2:	c7 44 24 08 a6 2b 81 	movl   $0x812ba6,0x8(%esp)
  8054e9:	00 
  8054ea:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  8054f1:	00 
  8054f2:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  8054f9:	e8 3c 9b 00 00       	call   80f03a <_panic>
    if (offset_from >= p_from->len) {
  8054fe:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  805502:	72 08                	jb     80550c <pbuf_copy+0x128>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  805504:	8b 1b                	mov    (%ebx),%ebx
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  805506:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80550c:	85 db                	test   %ebx,%ebx
  80550e:	74 2b                	je     80553b <pbuf_copy+0x157>
  805510:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805514:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  805518:	75 21                	jne    80553b <pbuf_copy+0x157>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80551a:	83 3b 00             	cmpl   $0x0,(%ebx)
  80551d:	74 1c                	je     80553b <pbuf_copy+0x157>
  80551f:	c7 44 24 08 e4 2c 81 	movl   $0x812ce4,0x8(%esp)
  805526:	00 
  805527:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  80552e:	00 
  80552f:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  805536:	e8 ff 9a 00 00       	call   80f03a <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80553b:	85 f6                	test   %esi,%esi
  80553d:	74 2b                	je     80556a <pbuf_copy+0x186>
  80553f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  805543:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  805547:	75 21                	jne    80556a <pbuf_copy+0x186>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  805549:	83 3e 00             	cmpl   $0x0,(%esi)
  80554c:	74 1c                	je     80556a <pbuf_copy+0x186>
  80554e:	c7 44 24 08 e4 2c 81 	movl   $0x812ce4,0x8(%esp)
  805555:	00 
  805556:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  80555d:	00 
  80555e:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  805565:	e8 d0 9a 00 00       	call   80f03a <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80556a:	85 db                	test   %ebx,%ebx
  80556c:	0f 85 be fe ff ff    	jne    805430 <pbuf_copy+0x4c>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  805572:	b8 00 00 00 00       	mov    $0x0,%eax
  805577:	83 c4 1c             	add    $0x1c,%esp
  80557a:	5b                   	pop    %ebx
  80557b:	5e                   	pop    %esi
  80557c:	5f                   	pop    %edi
  80557d:	5d                   	pop    %ebp
  80557e:	c3                   	ret    

0080557f <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80557f:	55                   	push   %ebp
  805580:	89 e5                	mov    %esp,%ebp
  805582:	57                   	push   %edi
  805583:	56                   	push   %esi
  805584:	53                   	push   %ebx
  805585:	83 ec 1c             	sub    $0x1c,%esp
  805588:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80558b:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  80558f:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  805593:	85 db                	test   %ebx,%ebx
  805595:	75 1c                	jne    8055b3 <pbuf_copy_partial+0x34>
  805597:	c7 44 24 08 10 2d 81 	movl   $0x812d10,0x8(%esp)
  80559e:	00 
  80559f:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  8055a6:	00 
  8055a7:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  8055ae:	e8 87 9a 00 00       	call   80f03a <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8055b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8055b7:	74 0e                	je     8055c7 <pbuf_copy_partial+0x48>
  8055b9:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  8055bf:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  8055c5:	eb 6b                	jmp    805632 <pbuf_copy_partial+0xb3>
  8055c7:	c7 44 24 08 34 2d 81 	movl   $0x812d34,0x8(%esp)
  8055ce:	00 
  8055cf:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  8055d6:	00 
  8055d7:	c7 04 24 40 2a 81 00 	movl   $0x812a40,(%esp)
  8055de:	e8 57 9a 00 00       	call   80f03a <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  8055e3:	66 85 c0             	test   %ax,%ax
  8055e6:	74 0d                	je     8055f5 <pbuf_copy_partial+0x76>
  8055e8:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  8055ec:	66 39 d0             	cmp    %dx,%ax
  8055ef:	72 04                	jb     8055f5 <pbuf_copy_partial+0x76>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  8055f1:	29 d0                	sub    %edx,%eax
  8055f3:	eb 3b                	jmp    805630 <pbuf_copy_partial+0xb1>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  8055f5:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8055f9:	29 c7                	sub    %eax,%edi
  8055fb:	66 39 f7             	cmp    %si,%di
  8055fe:	0f 47 fe             	cmova  %esi,%edi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  805601:	0f b7 d7             	movzwl %di,%edx
  805604:	89 54 24 08          	mov    %edx,0x8(%esp)
  805608:	0f b7 c0             	movzwl %ax,%eax
  80560b:	03 43 04             	add    0x4(%ebx),%eax
  80560e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805612:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805616:	03 45 0c             	add    0xc(%ebp),%eax
  805619:	89 04 24             	mov    %eax,(%esp)
  80561c:	e8 8b a3 00 00       	call   80f9ac <memcpy>
      copied_total += buf_copy_len;
  805621:	66 01 7d e4          	add    %di,-0x1c(%ebp)
      left += buf_copy_len;
  805625:	66 01 7d e6          	add    %di,-0x1a(%ebp)
      len -= buf_copy_len;
  805629:	29 fe                	sub    %edi,%esi
      offset = 0;
  80562b:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  805630:	8b 1b                	mov    (%ebx),%ebx
  805632:	85 db                	test   %ebx,%ebx
  805634:	74 05                	je     80563b <pbuf_copy_partial+0xbc>
  805636:	66 85 f6             	test   %si,%si
  805639:	75 a8                	jne    8055e3 <pbuf_copy_partial+0x64>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  80563b:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80563f:	83 c4 1c             	add    $0x1c,%esp
  805642:	5b                   	pop    %ebx
  805643:	5e                   	pop    %esi
  805644:	5f                   	pop    %edi
  805645:	5d                   	pop    %ebp
  805646:	c3                   	ret    
  805647:	66 90                	xchg   %ax,%ax
  805649:	66 90                	xchg   %ax,%ax
  80564b:	66 90                	xchg   %ax,%ax
  80564d:	66 90                	xchg   %ax,%ax
  80564f:	90                   	nop

00805650 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805650:	55                   	push   %ebp
  805651:	89 e5                	mov    %esp,%ebp
  805653:	83 ec 18             	sub    $0x18,%esp
  805656:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  805659:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80565e:	8b 40 04             	mov    0x4(%eax),%eax
  805661:	8b 00                	mov    (%eax),%eax
  805663:	89 04 24             	mov    %eax,(%esp)
  805666:	e8 65 52 00 00       	call   80a8d0 <sys_sem_signal>
}
  80566b:	c9                   	leave  
  80566c:	c3                   	ret    

0080566d <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80566d:	55                   	push   %ebp
  80566e:	89 e5                	mov    %esp,%ebp
  805670:	57                   	push   %edi
  805671:	56                   	push   %esi
  805672:	53                   	push   %ebx
  805673:	83 ec 1c             	sub    $0x1c,%esp
  805676:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  805679:	e8 be 56 00 00       	call   80ad3c <sys_arch_timeouts>
  80567e:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  805680:	85 c0                	test   %eax,%eax
  805682:	74 06                	je     80568a <sys_mbox_fetch+0x1d>
  805684:	8b 00                	mov    (%eax),%eax
  805686:	85 c0                	test   %eax,%eax
  805688:	75 19                	jne    8056a3 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80568a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805691:	00 
  805692:	89 7c 24 04          	mov    %edi,0x4(%esp)
  805696:	8b 45 08             	mov    0x8(%ebp),%eax
  805699:	89 04 24             	mov    %eax,(%esp)
  80569c:	e8 c7 54 00 00       	call   80ab68 <sys_arch_mbox_fetch>
  8056a1:	eb 5d                	jmp    805700 <sys_mbox_fetch+0x93>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  8056a3:	8b 40 04             	mov    0x4(%eax),%eax
  8056a6:	85 c0                	test   %eax,%eax
  8056a8:	74 18                	je     8056c2 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8056aa:	89 44 24 08          	mov    %eax,0x8(%esp)
  8056ae:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8056b2:	8b 45 08             	mov    0x8(%ebp),%eax
  8056b5:	89 04 24             	mov    %eax,(%esp)
  8056b8:	e8 ab 54 00 00       	call   80ab68 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8056bd:	83 f8 ff             	cmp    $0xffffffff,%eax
  8056c0:	75 27                	jne    8056e9 <sys_mbox_fetch+0x7c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8056c2:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8056c4:	8b 10                	mov    (%eax),%edx
  8056c6:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8056c8:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8056cb:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8056ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  8056d2:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8056d9:	e8 44 f3 ff ff       	call   804a22 <memp_free>
      if (h != NULL) {
  8056de:	85 db                	test   %ebx,%ebx
  8056e0:	74 97                	je     805679 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  8056e2:	89 34 24             	mov    %esi,(%esp)
  8056e5:	ff d3                	call   *%ebx
  8056e7:	eb 90                	jmp    805679 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8056e9:	8b 13                	mov    (%ebx),%edx
  8056eb:	8b 4a 04             	mov    0x4(%edx),%ecx
  8056ee:	39 c8                	cmp    %ecx,%eax
  8056f0:	73 07                	jae    8056f9 <sys_mbox_fetch+0x8c>
        timeouts->next->time -= time_needed;
  8056f2:	29 c1                	sub    %eax,%ecx
  8056f4:	89 4a 04             	mov    %ecx,0x4(%edx)
  8056f7:	eb 07                	jmp    805700 <sys_mbox_fetch+0x93>
      } else {
        timeouts->next->time = 0;
  8056f9:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  805700:	83 c4 1c             	add    $0x1c,%esp
  805703:	5b                   	pop    %ebx
  805704:	5e                   	pop    %esi
  805705:	5f                   	pop    %edi
  805706:	5d                   	pop    %ebp
  805707:	c3                   	ret    

00805708 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  805708:	55                   	push   %ebp
  805709:	89 e5                	mov    %esp,%ebp
  80570b:	57                   	push   %edi
  80570c:	56                   	push   %esi
  80570d:	53                   	push   %ebx
  80570e:	83 ec 1c             	sub    $0x1c,%esp
  805711:	8b 75 08             	mov    0x8(%ebp),%esi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  805714:	e8 23 56 00 00       	call   80ad3c <sys_arch_timeouts>
  805719:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80571b:	85 c0                	test   %eax,%eax
  80571d:	74 06                	je     805725 <sys_sem_wait+0x1d>
  80571f:	8b 00                	mov    (%eax),%eax
  805721:	85 c0                	test   %eax,%eax
  805723:	75 12                	jne    805737 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  805725:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80572c:	00 
  80572d:	89 34 24             	mov    %esi,(%esp)
  805730:	e8 10 52 00 00       	call   80a945 <sys_arch_sem_wait>
  805735:	eb 56                	jmp    80578d <sys_sem_wait+0x85>
  } else {
    if (timeouts->next->time > 0) {
  805737:	8b 40 04             	mov    0x4(%eax),%eax
  80573a:	85 c0                	test   %eax,%eax
  80573c:	74 11                	je     80574f <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80573e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805742:	89 34 24             	mov    %esi,(%esp)
  805745:	e8 fb 51 00 00       	call   80a945 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80574a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80574d:	75 27                	jne    805776 <sys_sem_wait+0x6e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80574f:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805751:	8b 10                	mov    (%eax),%edx
  805753:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  805755:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805758:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80575b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80575f:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  805766:	e8 b7 f2 ff ff       	call   804a22 <memp_free>
      if (h != NULL) {
  80576b:	85 db                	test   %ebx,%ebx
  80576d:	74 a5                	je     805714 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80576f:	89 3c 24             	mov    %edi,(%esp)
  805772:	ff d3                	call   *%ebx
  805774:	eb 9e                	jmp    805714 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805776:	8b 13                	mov    (%ebx),%edx
  805778:	8b 4a 04             	mov    0x4(%edx),%ecx
  80577b:	39 c8                	cmp    %ecx,%eax
  80577d:	73 07                	jae    805786 <sys_sem_wait+0x7e>
        timeouts->next->time -= time_needed;
  80577f:	29 c1                	sub    %eax,%ecx
  805781:	89 4a 04             	mov    %ecx,0x4(%edx)
  805784:	eb 07                	jmp    80578d <sys_sem_wait+0x85>
      } else {
        timeouts->next->time = 0;
  805786:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  80578d:	83 c4 1c             	add    $0x1c,%esp
  805790:	5b                   	pop    %ebx
  805791:	5e                   	pop    %esi
  805792:	5f                   	pop    %edi
  805793:	5d                   	pop    %ebp
  805794:	c3                   	ret    

00805795 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  805795:	55                   	push   %ebp
  805796:	89 e5                	mov    %esp,%ebp
  805798:	56                   	push   %esi
  805799:	53                   	push   %ebx
  80579a:	83 ec 10             	sub    $0x10,%esp
  80579d:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8057a0:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8057a7:	e8 16 f2 ff ff       	call   8049c2 <memp_malloc>
  8057ac:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  8057ae:	85 c0                	test   %eax,%eax
  8057b0:	75 1c                	jne    8057ce <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8057b2:	c7 44 24 08 59 2d 81 	movl   $0x812d59,0x8(%esp)
  8057b9:	00 
  8057ba:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  8057c1:	00 
  8057c2:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  8057c9:	e8 6c 98 00 00       	call   80f03a <_panic>
    return;
  }
  timeout->next = NULL;
  8057ce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8057d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8057d7:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8057da:	8b 45 10             	mov    0x10(%ebp),%eax
  8057dd:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8057e0:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  8057e3:	e8 54 55 00 00       	call   80ad3c <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  8057e8:	85 c0                	test   %eax,%eax
  8057ea:	75 1c                	jne    805808 <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8057ec:	c7 44 24 08 8a 2d 81 	movl   $0x812d8a,0x8(%esp)
  8057f3:	00 
  8057f4:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  8057fb:	00 
  8057fc:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  805803:	e8 32 98 00 00       	call   80f03a <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  805808:	8b 08                	mov    (%eax),%ecx
  80580a:	85 c9                	test   %ecx,%ecx
  80580c:	75 04                	jne    805812 <sys_timeout+0x7d>
    timeouts->next = timeout;
  80580e:	89 18                	mov    %ebx,(%eax)
    return;
  805810:	eb 35                	jmp    805847 <sys_timeout+0xb2>
  }

  if (timeouts->next->time > msecs) {
  805812:	8b 51 04             	mov    0x4(%ecx),%edx
  805815:	39 d6                	cmp    %edx,%esi
  805817:	73 0d                	jae    805826 <sys_timeout+0x91>
    timeouts->next->time -= msecs;
  805819:	29 f2                	sub    %esi,%edx
  80581b:	89 51 04             	mov    %edx,0x4(%ecx)
    timeout->next = timeouts->next;
  80581e:	8b 10                	mov    (%eax),%edx
  805820:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  805822:	89 18                	mov    %ebx,(%eax)
  805824:	eb 21                	jmp    805847 <sys_timeout+0xb2>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  805826:	8b 43 04             	mov    0x4(%ebx),%eax
  805829:	2b 41 04             	sub    0x4(%ecx),%eax
  80582c:	89 43 04             	mov    %eax,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  80582f:	8b 11                	mov    (%ecx),%edx
  805831:	85 d2                	test   %edx,%edx
  805833:	74 0c                	je     805841 <sys_timeout+0xac>
  805835:	3b 42 04             	cmp    0x4(%edx),%eax
  805838:	72 04                	jb     80583e <sys_timeout+0xa9>
  80583a:	89 d1                	mov    %edx,%ecx
  80583c:	eb e8                	jmp    805826 <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80583e:	29 42 04             	sub    %eax,0x4(%edx)
        }
        timeout->next = t->next;
  805841:	8b 01                	mov    (%ecx),%eax
  805843:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  805845:	89 19                	mov    %ebx,(%ecx)
        break;
      }
    }
  }
}
  805847:	83 c4 10             	add    $0x10,%esp
  80584a:	5b                   	pop    %ebx
  80584b:	5e                   	pop    %esi
  80584c:	5d                   	pop    %ebp
  80584d:	c3                   	ret    

0080584e <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80584e:	55                   	push   %ebp
  80584f:	89 e5                	mov    %esp,%ebp
  805851:	57                   	push   %edi
  805852:	56                   	push   %esi
  805853:	53                   	push   %ebx
  805854:	83 ec 1c             	sub    $0x1c,%esp
  805857:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80585a:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80585d:	e8 da 54 00 00       	call   80ad3c <sys_arch_timeouts>

  if (timeouts == NULL) {
  805862:	85 c0                	test   %eax,%eax
  805864:	75 1c                	jne    805882 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805866:	c7 44 24 08 a8 2d 81 	movl   $0x812da8,0x8(%esp)
  80586d:	00 
  80586e:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  805875:	00 
  805876:	c7 04 24 76 2d 81 00 	movl   $0x812d76,(%esp)
  80587d:	e8 b8 97 00 00       	call   80f03a <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  805882:	8b 10                	mov    (%eax),%edx
  805884:	85 d2                	test   %edx,%edx
  805886:	74 4a                	je     8058d2 <sys_untimeout+0x84>
  805888:	bf 00 00 00 00       	mov    $0x0,%edi
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  80588d:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805890:	75 32                	jne    8058c4 <sys_untimeout+0x76>
  805892:	39 72 0c             	cmp    %esi,0xc(%edx)
  805895:	75 2d                	jne    8058c4 <sys_untimeout+0x76>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  805897:	85 ff                	test   %edi,%edi
  805899:	75 07                	jne    8058a2 <sys_untimeout+0x54>
        timeouts->next = t->next;
  80589b:	8b 0a                	mov    (%edx),%ecx
  80589d:	89 08                	mov    %ecx,(%eax)
  80589f:	90                   	nop
  8058a0:	eb 04                	jmp    8058a6 <sys_untimeout+0x58>
      else
        prev_t->next = t->next;
  8058a2:	8b 02                	mov    (%edx),%eax
  8058a4:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  8058a6:	8b 02                	mov    (%edx),%eax
  8058a8:	85 c0                	test   %eax,%eax
  8058aa:	74 06                	je     8058b2 <sys_untimeout+0x64>
        t->next->time += t->time;
  8058ac:	8b 4a 04             	mov    0x4(%edx),%ecx
  8058af:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8058b2:	89 54 24 04          	mov    %edx,0x4(%esp)
  8058b6:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8058bd:	e8 60 f1 ff ff       	call   804a22 <memp_free>
      return;
  8058c2:	eb 0e                	jmp    8058d2 <sys_untimeout+0x84>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8058c4:	8b 0a                	mov    (%edx),%ecx
  8058c6:	85 c9                	test   %ecx,%ecx
  8058c8:	74 08                	je     8058d2 <sys_untimeout+0x84>
  8058ca:	89 d7                	mov    %edx,%edi
  8058cc:	89 ca                	mov    %ecx,%edx
  8058ce:	66 90                	xchg   %ax,%ax
  8058d0:	eb bb                	jmp    80588d <sys_untimeout+0x3f>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  8058d2:	83 c4 1c             	add    $0x1c,%esp
  8058d5:	5b                   	pop    %ebx
  8058d6:	5e                   	pop    %esi
  8058d7:	5f                   	pop    %edi
  8058d8:	5d                   	pop    %ebp
  8058d9:	c3                   	ret    

008058da <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8058da:	55                   	push   %ebp
  8058db:	89 e5                	mov    %esp,%ebp
  8058dd:	83 ec 28             	sub    $0x28,%esp
  8058e0:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8058e3:	8d 4d 08             	lea    0x8(%ebp),%ecx
  8058e6:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8058e9:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8058ef:	85 c0                	test   %eax,%eax
  8058f1:	74 17                	je     80590a <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8058f3:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8058f6:	89 54 24 08          	mov    %edx,0x8(%esp)
  8058fa:	c7 44 24 04 50 56 80 	movl   $0x805650,0x4(%esp)
  805901:	00 
  805902:	89 04 24             	mov    %eax,(%esp)
  805905:	e8 8b fe ff ff       	call   805795 <sys_timeout>
  }
  sys_sem_wait(sem);
  80590a:	8b 45 08             	mov    0x8(%ebp),%eax
  80590d:	89 04 24             	mov    %eax,(%esp)
  805910:	e8 f3 fd ff ff       	call   805708 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
    /* timeout */
    return 0;
  805915:	b8 00 00 00 00       	mov    $0x0,%eax
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80591a:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80591f:	75 18                	jne    805939 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  805921:	8d 45 f0             	lea    -0x10(%ebp),%eax
  805924:	89 44 24 04          	mov    %eax,0x4(%esp)
  805928:	c7 04 24 50 56 80 00 	movl   $0x805650,(%esp)
  80592f:	e8 1a ff ff ff       	call   80584e <sys_untimeout>
    return 1;
  805934:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  805939:	c9                   	leave  
  80593a:	c3                   	ret    

0080593b <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80593b:	55                   	push   %ebp
  80593c:	89 e5                	mov    %esp,%ebp
  80593e:	53                   	push   %ebx
  80593f:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805942:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805949:	e8 a0 4c 00 00       	call   80a5ee <sys_sem_new>
  80594e:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805950:	8b 45 08             	mov    0x8(%ebp),%eax
  805953:	89 44 24 04          	mov    %eax,0x4(%esp)
  805957:	89 1c 24             	mov    %ebx,(%esp)
  80595a:	e8 7b ff ff ff       	call   8058da <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80595f:	89 1c 24             	mov    %ebx,(%esp)
  805962:	e8 10 4d 00 00       	call   80a677 <sys_sem_free>
}
  805967:	83 c4 14             	add    $0x14,%esp
  80596a:	5b                   	pop    %ebx
  80596b:	5d                   	pop    %ebp
  80596c:	c3                   	ret    
  80596d:	66 90                	xchg   %ax,%ax
  80596f:	90                   	nop

00805970 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  805970:	55                   	push   %ebp
  805971:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805973:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  805978:	5d                   	pop    %ebp
  805979:	c3                   	ret    

0080597a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80597a:	55                   	push   %ebp
  80597b:	89 e5                	mov    %esp,%ebp
  80597d:	57                   	push   %edi
  80597e:	56                   	push   %esi
  80597f:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805980:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805986:	8b 35 70 c2 b3 00    	mov    0xb3c270,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80598c:	8b 3d 64 c2 b3 00    	mov    0xb3c264,%edi
  805992:	0f b7 05 0c 50 81 00 	movzwl 0x81500c,%eax
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  805999:	b9 00 10 00 00       	mov    $0x1000,%ecx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80599e:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  8059a2:	0f 48 c1             	cmovs  %ecx,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8059a5:	89 da                	mov    %ebx,%edx
  8059a7:	eb 09                	jmp    8059b2 <tcp_new_port+0x38>
    if (pcb->local_port == port) {
  8059a9:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8059ad:	74 ef                	je     80599e <tcp_new_port+0x24>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8059af:	8b 52 0c             	mov    0xc(%edx),%edx
  8059b2:	85 d2                	test   %edx,%edx
  8059b4:	75 f3                	jne    8059a9 <tcp_new_port+0x2f>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8059b6:	89 f2                	mov    %esi,%edx
  8059b8:	eb 09                	jmp    8059c3 <tcp_new_port+0x49>
    if (pcb->local_port == port) {
  8059ba:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8059be:	74 de                	je     80599e <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8059c0:	8b 52 0c             	mov    0xc(%edx),%edx
  8059c3:	85 d2                	test   %edx,%edx
  8059c5:	75 f3                	jne    8059ba <tcp_new_port+0x40>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8059c7:	89 fa                	mov    %edi,%edx
  8059c9:	eb 09                	jmp    8059d4 <tcp_new_port+0x5a>
    if (pcb->local_port == port) {
  8059cb:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8059cf:	74 cd                	je     80599e <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8059d1:	8b 52 0c             	mov    0xc(%edx),%edx
  8059d4:	85 d2                	test   %edx,%edx
  8059d6:	75 f3                	jne    8059cb <tcp_new_port+0x51>
  8059d8:	66 a3 0c 50 81 00    	mov    %ax,0x81500c
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8059de:	5b                   	pop    %ebx
  8059df:	5e                   	pop    %esi
  8059e0:	5f                   	pop    %edi
  8059e1:	5d                   	pop    %ebp
  8059e2:	c3                   	ret    

008059e3 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8059e3:	55                   	push   %ebp
  8059e4:	89 e5                	mov    %esp,%ebp
  8059e6:	57                   	push   %edi
  8059e7:	56                   	push   %esi
  8059e8:	53                   	push   %ebx
  8059e9:	83 ec 1c             	sub    $0x1c,%esp
  8059ec:	8b 75 08             	mov    0x8(%ebp),%esi
  8059ef:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8059f2:	8b 55 10             	mov    0x10(%ebp),%edx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8059f5:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8059f9:	74 1c                	je     805a17 <tcp_bind+0x34>
  8059fb:	c7 44 24 08 c8 2d 81 	movl   $0x812dc8,0x8(%esp)
  805a02:	00 
  805a03:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  805a0a:	00 
  805a0b:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  805a12:	e8 23 96 00 00       	call   80f03a <_panic>
  805a17:	89 d0                	mov    %edx,%eax

  if (port == 0) {
  805a19:	66 85 d2             	test   %dx,%dx
  805a1c:	75 05                	jne    805a23 <tcp_bind+0x40>
    port = tcp_new_port();
  805a1e:	e8 57 ff ff ff       	call   80597a <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805a23:	8b 15 64 c2 b3 00    	mov    0xb3c264,%edx
  805a29:	eb 35                	jmp    805a60 <tcp_bind+0x7d>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  805a2b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805a2f:	75 2c                	jne    805a5d <tcp_bind+0x7a>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805a31:	85 d2                	test   %edx,%edx
  805a33:	0f 84 f7 00 00 00    	je     805b30 <tcp_bind+0x14d>
  805a39:	8b 0a                	mov    (%edx),%ecx
  805a3b:	85 c9                	test   %ecx,%ecx
  805a3d:	0f 84 f4 00 00 00    	je     805b37 <tcp_bind+0x154>
  805a43:	85 db                	test   %ebx,%ebx
  805a45:	0f 84 f3 00 00 00    	je     805b3e <tcp_bind+0x15b>
          ip_addr_isany(ipaddr) ||
  805a4b:	8b 3b                	mov    (%ebx),%edi
  805a4d:	85 ff                	test   %edi,%edi
  805a4f:	0f 84 f0 00 00 00    	je     805b45 <tcp_bind+0x162>
  805a55:	39 f9                	cmp    %edi,%ecx
  805a57:	0f 84 ef 00 00 00    	je     805b4c <tcp_bind+0x169>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  805a5d:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805a60:	85 d2                	test   %edx,%edx
  805a62:	75 c7                	jne    805a2b <tcp_bind+0x48>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805a64:	8b 15 5c c2 b3 00    	mov    0xb3c25c,%edx
  805a6a:	eb 35                	jmp    805aa1 <tcp_bind+0xbe>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  805a6c:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805a70:	75 2c                	jne    805a9e <tcp_bind+0xbb>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805a72:	85 d2                	test   %edx,%edx
  805a74:	0f 84 d9 00 00 00    	je     805b53 <tcp_bind+0x170>
  805a7a:	8b 0a                	mov    (%edx),%ecx
  805a7c:	85 c9                	test   %ecx,%ecx
  805a7e:	0f 84 d6 00 00 00    	je     805b5a <tcp_bind+0x177>
  805a84:	85 db                	test   %ebx,%ebx
  805a86:	0f 84 d5 00 00 00    	je     805b61 <tcp_bind+0x17e>
          ip_addr_isany(ipaddr) ||
  805a8c:	8b 3b                	mov    (%ebx),%edi
  805a8e:	85 ff                	test   %edi,%edi
  805a90:	0f 84 d2 00 00 00    	je     805b68 <tcp_bind+0x185>
  805a96:	39 f9                	cmp    %edi,%ecx
  805a98:	0f 84 d1 00 00 00    	je     805b6f <tcp_bind+0x18c>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  805a9e:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805aa1:	85 d2                	test   %edx,%edx
  805aa3:	75 c7                	jne    805a6c <tcp_bind+0x89>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805aa5:	8b 15 6c c2 b3 00    	mov    0xb3c26c,%edx
  805aab:	eb 35                	jmp    805ae2 <tcp_bind+0xff>
    if (cpcb->local_port == port) {
  805aad:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805ab1:	75 2c                	jne    805adf <tcp_bind+0xfc>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805ab3:	85 d2                	test   %edx,%edx
  805ab5:	0f 84 bb 00 00 00    	je     805b76 <tcp_bind+0x193>
  805abb:	8b 0a                	mov    (%edx),%ecx
  805abd:	85 c9                	test   %ecx,%ecx
  805abf:	0f 84 b8 00 00 00    	je     805b7d <tcp_bind+0x19a>
  805ac5:	85 db                	test   %ebx,%ebx
  805ac7:	0f 84 b7 00 00 00    	je     805b84 <tcp_bind+0x1a1>
          ip_addr_isany(ipaddr) ||
  805acd:	8b 3b                	mov    (%ebx),%edi
  805acf:	85 ff                	test   %edi,%edi
  805ad1:	0f 84 b4 00 00 00    	je     805b8b <tcp_bind+0x1a8>
  805ad7:	39 f9                	cmp    %edi,%ecx
  805ad9:	0f 84 b3 00 00 00    	je     805b92 <tcp_bind+0x1af>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805adf:	8b 52 0c             	mov    0xc(%edx),%edx
  805ae2:	85 d2                	test   %edx,%edx
  805ae4:	75 c7                	jne    805aad <tcp_bind+0xca>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805ae6:	8b 15 70 c2 b3 00    	mov    0xb3c270,%edx
  805aec:	eb 13                	jmp    805b01 <tcp_bind+0x11e>
    if (cpcb->local_port == port) {
  805aee:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805af2:	75 0a                	jne    805afe <tcp_bind+0x11b>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805af4:	8b 3b                	mov    (%ebx),%edi
  805af6:	39 3a                	cmp    %edi,(%edx)
  805af8:	0f 84 9b 00 00 00    	je     805b99 <tcp_bind+0x1b6>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805afe:	8b 52 0c             	mov    0xc(%edx),%edx
  805b01:	85 d2                	test   %edx,%edx
  805b03:	75 e9                	jne    805aee <tcp_bind+0x10b>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  805b05:	85 db                	test   %ebx,%ebx
  805b07:	74 09                	je     805b12 <tcp_bind+0x12f>
  805b09:	83 3b 00             	cmpl   $0x0,(%ebx)
  805b0c:	74 04                	je     805b12 <tcp_bind+0x12f>
    pcb->local_ip = *ipaddr;
  805b0e:	8b 13                	mov    (%ebx),%edx
  805b10:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  805b12:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805b16:	a1 6c c2 b3 00       	mov    0xb3c26c,%eax
  805b1b:	89 46 0c             	mov    %eax,0xc(%esi)
  805b1e:	89 35 6c c2 b3 00    	mov    %esi,0xb3c26c
  805b24:	e8 29 ca ff ff       	call   802552 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  805b29:	b8 00 00 00 00       	mov    $0x0,%eax
  805b2e:	eb 6e                	jmp    805b9e <tcp_bind+0x1bb>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805b30:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b35:	eb 67                	jmp    805b9e <tcp_bind+0x1bb>
  805b37:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b3c:	eb 60                	jmp    805b9e <tcp_bind+0x1bb>
  805b3e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b43:	eb 59                	jmp    805b9e <tcp_bind+0x1bb>
  805b45:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b4a:	eb 52                	jmp    805b9e <tcp_bind+0x1bb>
  805b4c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b51:	eb 4b                	jmp    805b9e <tcp_bind+0x1bb>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805b53:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b58:	eb 44                	jmp    805b9e <tcp_bind+0x1bb>
  805b5a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b5f:	eb 3d                	jmp    805b9e <tcp_bind+0x1bb>
  805b61:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b66:	eb 36                	jmp    805b9e <tcp_bind+0x1bb>
  805b68:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b6d:	eb 2f                	jmp    805b9e <tcp_bind+0x1bb>
  805b6f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b74:	eb 28                	jmp    805b9e <tcp_bind+0x1bb>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805b76:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b7b:	eb 21                	jmp    805b9e <tcp_bind+0x1bb>
  805b7d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b82:	eb 1a                	jmp    805b9e <tcp_bind+0x1bb>
  805b84:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b89:	eb 13                	jmp    805b9e <tcp_bind+0x1bb>
  805b8b:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b90:	eb 0c                	jmp    805b9e <tcp_bind+0x1bb>
  805b92:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b97:	eb 05                	jmp    805b9e <tcp_bind+0x1bb>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805b99:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  805b9e:	83 c4 1c             	add    $0x1c,%esp
  805ba1:	5b                   	pop    %ebx
  805ba2:	5e                   	pop    %esi
  805ba3:	5f                   	pop    %edi
  805ba4:	5d                   	pop    %ebp
  805ba5:	c3                   	ret    

00805ba6 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805ba6:	55                   	push   %ebp
  805ba7:	89 e5                	mov    %esp,%ebp
  805ba9:	56                   	push   %esi
  805baa:	53                   	push   %ebx
  805bab:	83 ec 10             	sub    $0x10,%esp
  805bae:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805bb1:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805bb5:	74 1c                	je     805bd3 <tcp_listen_with_backlog+0x2d>
  805bb7:	c7 44 24 08 f4 2d 81 	movl   $0x812df4,0x8(%esp)
  805bbe:	00 
  805bbf:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  805bc6:	00 
  805bc7:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  805bce:	e8 67 94 00 00       	call   80f03a <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805bd3:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  805bda:	e8 e3 ed ff ff       	call   8049c2 <memp_malloc>
  805bdf:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805be1:	85 c0                	test   %eax,%eax
  805be3:	0f 84 af 00 00 00    	je     805c98 <tcp_listen_with_backlog+0xf2>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  805be9:	8b 43 18             	mov    0x18(%ebx),%eax
  805bec:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805bef:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805bf3:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805bf7:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  805bfe:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805c02:	83 c8 02             	or     $0x2,%eax
  805c05:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  805c09:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  805c0d:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805c10:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  805c14:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  805c17:	85 db                	test   %ebx,%ebx
  805c19:	74 04                	je     805c1f <tcp_listen_with_backlog+0x79>
  805c1b:	8b 03                	mov    (%ebx),%eax
  805c1d:	eb 05                	jmp    805c24 <tcp_listen_with_backlog+0x7e>
  805c1f:	b8 00 00 00 00       	mov    $0x0,%eax
  805c24:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805c26:	a1 6c c2 b3 00       	mov    0xb3c26c,%eax
  805c2b:	39 d8                	cmp    %ebx,%eax
  805c2d:	75 0a                	jne    805c39 <tcp_listen_with_backlog+0x93>
  805c2f:	8b 40 0c             	mov    0xc(%eax),%eax
  805c32:	a3 6c c2 b3 00       	mov    %eax,0xb3c26c
  805c37:	eb 2a                	jmp    805c63 <tcp_listen_with_backlog+0xbd>
  805c39:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  805c3e:	eb 1a                	jmp    805c5a <tcp_listen_with_backlog+0xb4>
  805c40:	8b 50 0c             	mov    0xc(%eax),%edx
  805c43:	85 d2                	test   %edx,%edx
  805c45:	74 11                	je     805c58 <tcp_listen_with_backlog+0xb2>
  805c47:	39 d3                	cmp    %edx,%ebx
  805c49:	75 0d                	jne    805c58 <tcp_listen_with_backlog+0xb2>
  805c4b:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  805c50:	8b 53 0c             	mov    0xc(%ebx),%edx
  805c53:	89 50 0c             	mov    %edx,0xc(%eax)
  805c56:	eb 0b                	jmp    805c63 <tcp_listen_with_backlog+0xbd>
  805c58:	89 d0                	mov    %edx,%eax
  805c5a:	85 c0                	test   %eax,%eax
  805c5c:	75 e2                	jne    805c40 <tcp_listen_with_backlog+0x9a>
  805c5e:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  805c63:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805c6a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805c6e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  805c75:	e8 a8 ed ff ff       	call   804a22 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  805c7a:	c7 46 20 70 59 80 00 	movl   $0x805970,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805c81:	a1 64 c2 b3 00       	mov    0xb3c264,%eax
  805c86:	89 46 0c             	mov    %eax,0xc(%esi)
  805c89:	89 35 64 c2 b3 00    	mov    %esi,0xb3c264
  805c8f:	e8 be c8 ff ff       	call   802552 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805c94:	89 f0                	mov    %esi,%eax
  805c96:	eb 05                	jmp    805c9d <tcp_listen_with_backlog+0xf7>
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  805c98:	b8 00 00 00 00       	mov    $0x0,%eax
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  return (struct tcp_pcb *)lpcb;
}
  805c9d:	83 c4 10             	add    $0x10,%esp
  805ca0:	5b                   	pop    %ebx
  805ca1:	5e                   	pop    %esi
  805ca2:	5d                   	pop    %ebp
  805ca3:	c3                   	ret    

00805ca4 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  805ca4:	55                   	push   %ebp
  805ca5:	89 e5                	mov    %esp,%ebp
  805ca7:	56                   	push   %esi
  805ca8:	53                   	push   %ebx
  805ca9:	83 ec 10             	sub    $0x10,%esp
  805cac:	8b 45 08             	mov    0x8(%ebp),%eax
  805caf:	8b 55 0c             	mov    0xc(%ebp),%edx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805cb2:	0f b7 48 28          	movzwl 0x28(%eax),%ecx
  805cb6:	0f b7 f2             	movzwl %dx,%esi
  805cb9:	0f b7 d9             	movzwl %cx,%ebx
  805cbc:	01 f3                	add    %esi,%ebx
  805cbe:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  805cc4:	76 0e                	jbe    805cd4 <tcp_recved+0x30>
    pcb->rcv_wnd = TCP_WND;
  805cc6:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805ccc:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805cd2:	eb 10                	jmp    805ce4 <tcp_recved+0x40>
  } else {
    pcb->rcv_wnd += len;
  805cd4:	01 ca                	add    %ecx,%edx
  805cd6:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805cda:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805cde:	72 04                	jb     805ce4 <tcp_recved+0x40>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805ce0:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  805ce4:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  805ce8:	f6 c2 03             	test   $0x3,%dl
  805ceb:	75 20                	jne    805d0d <tcp_recved+0x69>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  805ced:	f6 c2 01             	test   $0x1,%dl
  805cf0:	74 13                	je     805d05 <tcp_recved+0x61>
  805cf2:	83 e2 fe             	and    $0xfffffffe,%edx
  805cf5:	83 ca 02             	or     $0x2,%edx
  805cf8:	88 50 20             	mov    %dl,0x20(%eax)
  805cfb:	89 04 24             	mov    %eax,(%esp)
  805cfe:	e8 2e 2a 00 00       	call   808731 <tcp_output>
  805d03:	eb 23                	jmp    805d28 <tcp_recved+0x84>
  805d05:	83 ca 01             	or     $0x1,%edx
  805d08:	88 50 20             	mov    %dl,0x20(%eax)
  805d0b:	eb 1b                	jmp    805d28 <tcp_recved+0x84>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805d0d:	f6 c2 01             	test   $0x1,%dl
  805d10:	74 16                	je     805d28 <tcp_recved+0x84>
  805d12:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805d18:	76 0e                	jbe    805d28 <tcp_recved+0x84>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  805d1a:	83 ca 02             	or     $0x2,%edx
  805d1d:	88 50 20             	mov    %dl,0x20(%eax)
  805d20:	89 04 24             	mov    %eax,(%esp)
  805d23:	e8 09 2a 00 00       	call   808731 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  805d28:	83 c4 10             	add    $0x10,%esp
  805d2b:	5b                   	pop    %ebx
  805d2c:	5e                   	pop    %esi
  805d2d:	5d                   	pop    %ebp
  805d2e:	c3                   	ret    

00805d2f <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805d2f:	55                   	push   %ebp
  805d30:	89 e5                	mov    %esp,%ebp
  805d32:	53                   	push   %ebx
  805d33:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805d36:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
  805d3c:	eb 61                	jmp    805d9f <tcp_fasttmr+0x70>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  805d3e:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805d44:	85 c0                	test   %eax,%eax
  805d46:	74 3a                	je     805d82 <tcp_fasttmr+0x53>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805d48:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805d4e:	85 d2                	test   %edx,%edx
  805d50:	74 1e                	je     805d70 <tcp_fasttmr+0x41>
  805d52:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  805d59:	00 
  805d5a:	89 44 24 08          	mov    %eax,0x8(%esp)
  805d5e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805d62:	8b 43 18             	mov    0x18(%ebx),%eax
  805d65:	89 04 24             	mov    %eax,(%esp)
  805d68:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805d6a:	84 c0                	test   %al,%al
  805d6c:	75 14                	jne    805d82 <tcp_fasttmr+0x53>
  805d6e:	eb 08                	jmp    805d78 <tcp_fasttmr+0x49>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805d70:	89 04 24             	mov    %eax,(%esp)
  805d73:	e8 5c f0 ff ff       	call   804dd4 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805d78:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805d7f:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805d82:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805d86:	a8 01                	test   $0x1,%al
  805d88:	74 12                	je     805d9c <tcp_fasttmr+0x6d>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805d8a:	83 c8 02             	or     $0x2,%eax
  805d8d:	88 43 20             	mov    %al,0x20(%ebx)
  805d90:	89 1c 24             	mov    %ebx,(%esp)
  805d93:	e8 99 29 00 00       	call   808731 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805d98:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805d9c:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805d9f:	85 db                	test   %ebx,%ebx
  805da1:	75 9b                	jne    805d3e <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  805da3:	83 c4 14             	add    $0x14,%esp
  805da6:	5b                   	pop    %ebx
  805da7:	5d                   	pop    %ebp
  805da8:	c3                   	ret    

00805da9 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805da9:	55                   	push   %ebp
  805daa:	89 e5                	mov    %esp,%ebp
  805dac:	56                   	push   %esi
  805dad:	53                   	push   %ebx
  805dae:	83 ec 10             	sub    $0x10,%esp
  805db1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  805db4:	85 db                	test   %ebx,%ebx
  805db6:	74 28                	je     805de0 <tcp_seg_free+0x37>
    if (seg->p != NULL) {
  805db8:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805dbb:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
    if (seg->p != NULL) {
  805dc0:	85 c0                	test   %eax,%eax
  805dc2:	74 0a                	je     805dce <tcp_seg_free+0x25>
      count = pbuf_free(seg->p);
  805dc4:	89 04 24             	mov    %eax,(%esp)
  805dc7:	e8 08 f0 ff ff       	call   804dd4 <pbuf_free>
  805dcc:	89 c6                	mov    %eax,%esi
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805dce:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805dd2:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805dd9:	e8 44 ec ff ff       	call   804a22 <memp_free>
  805dde:	eb 05                	jmp    805de5 <tcp_seg_free+0x3c>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805de0:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  805de5:	89 f0                	mov    %esi,%eax
  805de7:	83 c4 10             	add    $0x10,%esp
  805dea:	5b                   	pop    %ebx
  805deb:	5e                   	pop    %esi
  805dec:	5d                   	pop    %ebp
  805ded:	c3                   	ret    

00805dee <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  805dee:	55                   	push   %ebp
  805def:	89 e5                	mov    %esp,%ebp
  805df1:	56                   	push   %esi
  805df2:	53                   	push   %ebx
  805df3:	83 ec 10             	sub    $0x10,%esp
  805df6:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t count = 0;
  805df9:	bb 00 00 00 00       	mov    $0x0,%ebx
  struct tcp_seg *next;
  while (seg != NULL) {
  805dfe:	eb 0e                	jmp    805e0e <tcp_segs_free+0x20>
    next = seg->next;
  805e00:	8b 32                	mov    (%edx),%esi
    count += tcp_seg_free(seg);
  805e02:	89 14 24             	mov    %edx,(%esp)
  805e05:	e8 9f ff ff ff       	call   805da9 <tcp_seg_free>
  805e0a:	01 c3                	add    %eax,%ebx
    seg = next;
  805e0c:	89 f2                	mov    %esi,%edx
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  805e0e:	85 d2                	test   %edx,%edx
  805e10:	75 ee                	jne    805e00 <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  805e12:	89 d8                	mov    %ebx,%eax
  805e14:	83 c4 10             	add    $0x10,%esp
  805e17:	5b                   	pop    %ebx
  805e18:	5e                   	pop    %esi
  805e19:	5d                   	pop    %ebp
  805e1a:	c3                   	ret    

00805e1b <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805e1b:	55                   	push   %ebp
  805e1c:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  805e1e:	8b 45 0c             	mov    0xc(%ebp),%eax
  805e21:	8b 55 08             	mov    0x8(%ebp),%edx
  805e24:	88 42 14             	mov    %al,0x14(%edx)
}
  805e27:	5d                   	pop    %ebp
  805e28:	c3                   	ret    

00805e29 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805e29:	55                   	push   %ebp
  805e2a:	89 e5                	mov    %esp,%ebp
  805e2c:	53                   	push   %ebx
  805e2d:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805e30:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805e37:	e8 86 eb ff ff       	call   8049c2 <memp_malloc>
  805e3c:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805e3e:	85 c0                	test   %eax,%eax
  805e40:	74 22                	je     805e64 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805e42:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  805e49:	00 
  805e4a:	8b 45 08             	mov    0x8(%ebp),%eax
  805e4d:	89 44 24 04          	mov    %eax,0x4(%esp)
  805e51:	89 1c 24             	mov    %ebx,(%esp)
  805e54:	e8 53 9b 00 00       	call   80f9ac <memcpy>
  pbuf_ref(cseg->p);
  805e59:	8b 43 04             	mov    0x4(%ebx),%eax
  805e5c:	89 04 24             	mov    %eax,(%esp)
  805e5f:	e8 1e f4 ff ff       	call   805282 <pbuf_ref>
  return cseg;
}
  805e64:	89 d8                	mov    %ebx,%eax
  805e66:	83 c4 14             	add    $0x14,%esp
  805e69:	5b                   	pop    %ebx
  805e6a:	5d                   	pop    %ebp
  805e6b:	c3                   	ret    

00805e6c <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805e6c:	55                   	push   %ebp
  805e6d:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805e6f:	8b 55 0c             	mov    0xc(%ebp),%edx
  805e72:	8b 45 08             	mov    0x8(%ebp),%eax
  805e75:	89 50 18             	mov    %edx,0x18(%eax)
}
  805e78:	5d                   	pop    %ebp
  805e79:	c3                   	ret    

00805e7a <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805e7a:	55                   	push   %ebp
  805e7b:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805e7d:	8b 55 0c             	mov    0xc(%ebp),%edx
  805e80:	8b 45 08             	mov    0x8(%ebp),%eax
  805e83:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805e89:	5d                   	pop    %ebp
  805e8a:	c3                   	ret    

00805e8b <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805e8b:	55                   	push   %ebp
  805e8c:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805e8e:	8b 55 0c             	mov    0xc(%ebp),%edx
  805e91:	8b 45 08             	mov    0x8(%ebp),%eax
  805e94:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805e9a:	5d                   	pop    %ebp
  805e9b:	c3                   	ret    

00805e9c <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805e9c:	55                   	push   %ebp
  805e9d:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805e9f:	8b 55 0c             	mov    0xc(%ebp),%edx
  805ea2:	8b 45 08             	mov    0x8(%ebp),%eax
  805ea5:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805eab:	5d                   	pop    %ebp
  805eac:	c3                   	ret    

00805ead <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805ead:	55                   	push   %ebp
  805eae:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805eb0:	8b 55 0c             	mov    0xc(%ebp),%edx
  805eb3:	8b 45 08             	mov    0x8(%ebp),%eax
  805eb6:	89 50 20             	mov    %edx,0x20(%eax)
}
  805eb9:	5d                   	pop    %ebp
  805eba:	c3                   	ret    

00805ebb <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805ebb:	55                   	push   %ebp
  805ebc:	89 e5                	mov    %esp,%ebp
  805ebe:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805ec1:	8b 55 0c             	mov    0xc(%ebp),%edx
  805ec4:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805eca:	8b 55 10             	mov    0x10(%ebp),%edx
  805ecd:	88 50 31             	mov    %dl,0x31(%eax)
}
  805ed0:	5d                   	pop    %ebp
  805ed1:	c3                   	ret    

00805ed2 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805ed2:	55                   	push   %ebp
  805ed3:	89 e5                	mov    %esp,%ebp
  805ed5:	53                   	push   %ebx
  805ed6:	83 ec 14             	sub    $0x14,%esp
  805ed9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805edc:	8b 43 10             	mov    0x10(%ebx),%eax
  805edf:	83 f8 01             	cmp    $0x1,%eax
  805ee2:	76 5d                	jbe    805f41 <tcp_pcb_purge+0x6f>
  805ee4:	83 f8 0a             	cmp    $0xa,%eax
  805ee7:	74 58                	je     805f41 <tcp_pcb_purge+0x6f>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  805ee9:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805eef:	85 c0                	test   %eax,%eax
  805ef1:	74 12                	je     805f05 <tcp_pcb_purge+0x33>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  805ef3:	89 04 24             	mov    %eax,(%esp)
  805ef6:	e8 d9 ee ff ff       	call   804dd4 <pbuf_free>
      pcb->refused_data = NULL;
  805efb:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805f02:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  805f05:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  805f0b:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805f0e:	89 04 24             	mov    %eax,(%esp)
  805f11:	e8 d8 fe ff ff       	call   805dee <tcp_segs_free>
    pcb->ooseq = NULL;
  805f16:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  805f1d:	8b 43 74             	mov    0x74(%ebx),%eax
  805f20:	89 04 24             	mov    %eax,(%esp)
  805f23:	e8 c6 fe ff ff       	call   805dee <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805f28:	8b 43 78             	mov    0x78(%ebx),%eax
  805f2b:	89 04 24             	mov    %eax,(%esp)
  805f2e:	e8 bb fe ff ff       	call   805dee <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805f33:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805f3a:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  805f41:	83 c4 14             	add    $0x14,%esp
  805f44:	5b                   	pop    %ebx
  805f45:	5d                   	pop    %ebp
  805f46:	c3                   	ret    

00805f47 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805f47:	55                   	push   %ebp
  805f48:	89 e5                	mov    %esp,%ebp
  805f4a:	53                   	push   %ebx
  805f4b:	83 ec 14             	sub    $0x14,%esp
  805f4e:	8b 45 08             	mov    0x8(%ebp),%eax
  805f51:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805f54:	8b 10                	mov    (%eax),%edx
  805f56:	39 da                	cmp    %ebx,%edx
  805f58:	75 07                	jne    805f61 <tcp_pcb_remove+0x1a>
  805f5a:	8b 52 0c             	mov    0xc(%edx),%edx
  805f5d:	89 10                	mov    %edx,(%eax)
  805f5f:	eb 2d                	jmp    805f8e <tcp_pcb_remove+0x47>
  805f61:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  805f67:	eb 1b                	jmp    805f84 <tcp_pcb_remove+0x3d>
  805f69:	8b 42 0c             	mov    0xc(%edx),%eax
  805f6c:	85 c0                	test   %eax,%eax
  805f6e:	74 12                	je     805f82 <tcp_pcb_remove+0x3b>
  805f70:	39 c3                	cmp    %eax,%ebx
  805f72:	75 0e                	jne    805f82 <tcp_pcb_remove+0x3b>
  805f74:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  805f7a:	8b 43 0c             	mov    0xc(%ebx),%eax
  805f7d:	89 42 0c             	mov    %eax,0xc(%edx)
  805f80:	eb 0c                	jmp    805f8e <tcp_pcb_remove+0x47>
  805f82:	89 c2                	mov    %eax,%edx
  805f84:	85 d2                	test   %edx,%edx
  805f86:	75 e1                	jne    805f69 <tcp_pcb_remove+0x22>
  805f88:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  805f8e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805f95:	89 1c 24             	mov    %ebx,(%esp)
  805f98:	e8 35 ff ff ff       	call   805ed2 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805f9d:	8b 43 10             	mov    0x10(%ebx),%eax
  805fa0:	83 f8 01             	cmp    $0x1,%eax
  805fa3:	74 1b                	je     805fc0 <tcp_pcb_remove+0x79>
  805fa5:	83 f8 0a             	cmp    $0xa,%eax
  805fa8:	74 16                	je     805fc0 <tcp_pcb_remove+0x79>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805faa:	0f b6 43 20          	movzbl 0x20(%ebx),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  805fae:	a8 01                	test   $0x1,%al
  805fb0:	74 0e                	je     805fc0 <tcp_pcb_remove+0x79>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  805fb2:	83 c8 02             	or     $0x2,%eax
  805fb5:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805fb8:	89 1c 24             	mov    %ebx,(%esp)
  805fbb:	e8 71 27 00 00       	call   808731 <tcp_output>
  }

  if (pcb->state != LISTEN) {
  805fc0:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805fc4:	74 66                	je     80602c <tcp_pcb_remove+0xe5>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805fc6:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805fca:	74 1c                	je     805fe8 <tcp_pcb_remove+0xa1>
  805fcc:	c7 44 24 08 be 2f 81 	movl   $0x812fbe,0x8(%esp)
  805fd3:	00 
  805fd4:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  805fdb:	00 
  805fdc:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  805fe3:	e8 52 90 00 00       	call   80f03a <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805fe8:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805fec:	74 1c                	je     80600a <tcp_pcb_remove+0xc3>
  805fee:	c7 44 24 08 d6 2f 81 	movl   $0x812fd6,0x8(%esp)
  805ff5:	00 
  805ff6:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  805ffd:	00 
  805ffe:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  806005:	e8 30 90 00 00       	call   80f03a <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  80600a:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  80600e:	74 1c                	je     80602c <tcp_pcb_remove+0xe5>
  806010:	c7 44 24 08 ef 2f 81 	movl   $0x812fef,0x8(%esp)
  806017:	00 
  806018:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  80601f:	00 
  806020:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  806027:	e8 0e 90 00 00       	call   80f03a <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  80602c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  806033:	83 c4 14             	add    $0x14,%esp
  806036:	5b                   	pop    %ebx
  806037:	5d                   	pop    %ebp
  806038:	c3                   	ret    

00806039 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  806039:	55                   	push   %ebp
  80603a:	89 e5                	mov    %esp,%ebp
  80603c:	53                   	push   %ebx
  80603d:	83 ec 14             	sub    $0x14,%esp
  806040:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  806043:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  806047:	0f 87 14 01 00 00    	ja     806161 <tcp_close+0x128>
  80604d:	8b 43 10             	mov    0x10(%ebx),%eax
  806050:	ff 24 85 08 30 81 00 	jmp    *0x813008(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  806057:	8b 15 6c c2 b3 00    	mov    0xb3c26c,%edx
  80605d:	39 da                	cmp    %ebx,%edx
  80605f:	75 0a                	jne    80606b <tcp_close+0x32>
  806061:	8b 42 0c             	mov    0xc(%edx),%eax
  806064:	a3 6c c2 b3 00       	mov    %eax,0xb3c26c
  806069:	eb 2d                	jmp    806098 <tcp_close+0x5f>
  80606b:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  806071:	eb 1b                	jmp    80608e <tcp_close+0x55>
  806073:	8b 42 0c             	mov    0xc(%edx),%eax
  806076:	85 c0                	test   %eax,%eax
  806078:	74 12                	je     80608c <tcp_close+0x53>
  80607a:	39 c3                	cmp    %eax,%ebx
  80607c:	75 0e                	jne    80608c <tcp_close+0x53>
  80607e:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  806084:	8b 43 0c             	mov    0xc(%ebx),%eax
  806087:	89 42 0c             	mov    %eax,0xc(%edx)
  80608a:	eb 0c                	jmp    806098 <tcp_close+0x5f>
  80608c:	89 c2                	mov    %eax,%edx
  80608e:	85 d2                	test   %edx,%edx
  806090:	75 e1                	jne    806073 <tcp_close+0x3a>
  806092:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  806098:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  80609f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8060a3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8060aa:	e8 73 e9 ff ff       	call   804a22 <memp_free>
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  8060af:	b8 00 00 00 00       	mov    $0x0,%eax
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  8060b4:	e9 c5 00 00 00       	jmp    80617e <tcp_close+0x145>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  8060b9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8060bd:	c7 04 24 64 c2 b3 00 	movl   $0xb3c264,(%esp)
  8060c4:	e8 7e fe ff ff       	call   805f47 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  8060c9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8060cd:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  8060d4:	e8 49 e9 ff ff       	call   804a22 <memp_free>
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
  8060d9:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  8060de:	e9 9b 00 00 00       	jmp    80617e <tcp_close+0x145>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8060e3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8060e7:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  8060ee:	e8 54 fe ff ff       	call   805f47 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8060f3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8060f7:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8060fe:	e8 1f e9 ff ff       	call   804a22 <memp_free>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
  806103:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  806108:	eb 74                	jmp    80617e <tcp_close+0x145>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80610a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  806111:	00 
  806112:	89 1c 24             	mov    %ebx,(%esp)
  806115:	e8 68 25 00 00       	call   808682 <tcp_send_ctrl>
    if (err == ERR_OK) {
  80611a:	84 c0                	test   %al,%al
  80611c:	75 60                	jne    80617e <tcp_close+0x145>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80611e:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  806125:	eb 3f                	jmp    806166 <tcp_close+0x12d>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806127:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80612e:	00 
  80612f:	89 1c 24             	mov    %ebx,(%esp)
  806132:	e8 4b 25 00 00       	call   808682 <tcp_send_ctrl>
    if (err == ERR_OK) {
  806137:	84 c0                	test   %al,%al
  806139:	75 43                	jne    80617e <tcp_close+0x145>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80613b:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  806142:	eb 22                	jmp    806166 <tcp_close+0x12d>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806144:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80614b:	00 
  80614c:	89 1c 24             	mov    %ebx,(%esp)
  80614f:	e8 2e 25 00 00       	call   808682 <tcp_send_ctrl>
    if (err == ERR_OK) {
  806154:	84 c0                	test   %al,%al
  806156:	75 26                	jne    80617e <tcp_close+0x145>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  806158:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  80615f:	eb 05                	jmp    806166 <tcp_close+0x12d>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    pcb = NULL;
  806161:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  806166:	85 db                	test   %ebx,%ebx
  806168:	74 0f                	je     806179 <tcp_close+0x140>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80616a:	89 1c 24             	mov    %ebx,(%esp)
  80616d:	e8 bf 25 00 00       	call   808731 <tcp_output>
  806172:	b8 00 00 00 00       	mov    $0x0,%eax
  806177:	eb 05                	jmp    80617e <tcp_close+0x145>
  806179:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  80617e:	83 c4 14             	add    $0x14,%esp
  806181:	5b                   	pop    %ebx
  806182:	5d                   	pop    %ebp
  806183:	c3                   	ret    

00806184 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  806184:	55                   	push   %ebp
  806185:	89 e5                	mov    %esp,%ebp
  806187:	83 ec 18             	sub    $0x18,%esp
  80618a:	8b 45 10             	mov    0x10(%ebp),%eax
  80618d:	8b 55 14             	mov    0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  806190:	85 c0                	test   %eax,%eax
  806192:	74 0f                	je     8061a3 <tcp_recv_null+0x1f>
    pbuf_free(p);
  806194:	89 04 24             	mov    %eax,(%esp)
  806197:	e8 38 ec ff ff       	call   804dd4 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  80619c:	b8 00 00 00 00       	mov    $0x0,%eax
  8061a1:	eb 14                	jmp    8061b7 <tcp_recv_null+0x33>
  8061a3:	b8 00 00 00 00       	mov    $0x0,%eax
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  8061a8:	84 d2                	test   %dl,%dl
  8061aa:	75 0b                	jne    8061b7 <tcp_recv_null+0x33>
    return tcp_close(pcb);
  8061ac:	8b 45 0c             	mov    0xc(%ebp),%eax
  8061af:	89 04 24             	mov    %eax,(%esp)
  8061b2:	e8 82 fe ff ff       	call   806039 <tcp_close>
  }
  return ERR_OK;
}
  8061b7:	c9                   	leave  
  8061b8:	c3                   	ret    

008061b9 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  8061b9:	55                   	push   %ebp
  8061ba:	89 e5                	mov    %esp,%ebp
  8061bc:	57                   	push   %edi
  8061bd:	56                   	push   %esi
  8061be:	53                   	push   %ebx
  8061bf:	83 ec 4c             	sub    $0x4c,%esp
  8061c2:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  8061c5:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8061c9:	75 25                	jne    8061f0 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  8061cb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8061cf:	c7 04 24 70 c2 b3 00 	movl   $0xb3c270,(%esp)
  8061d6:	e8 6c fd ff ff       	call   805f47 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8061db:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8061df:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8061e6:	e8 37 e8 ff ff       	call   804a22 <memp_free>
  8061eb:	e9 d5 00 00 00       	jmp    8062c5 <tcp_abort+0x10c>
  } else {
    seqno = pcb->snd_nxt;
  8061f0:	8b 43 54             	mov    0x54(%ebx),%eax
  8061f3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  8061f6:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  8061f9:	85 db                	test   %ebx,%ebx
  8061fb:	74 04                	je     806201 <tcp_abort+0x48>
  8061fd:	8b 03                	mov    (%ebx),%eax
  8061ff:	eb 05                	jmp    806206 <tcp_abort+0x4d>
  806201:	b8 00 00 00 00       	mov    $0x0,%eax
  806206:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  806209:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80620c:	74 05                	je     806213 <tcp_abort+0x5a>
  80620e:	8b 43 04             	mov    0x4(%ebx),%eax
  806211:	eb 05                	jmp    806218 <tcp_abort+0x5f>
  806213:	b8 00 00 00 00       	mov    $0x0,%eax
  806218:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  80621b:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  80621f:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  806223:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  806227:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80622b:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  806231:	8b 43 18             	mov    0x18(%ebx),%eax
  806234:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  806237:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80623b:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  806242:	e8 00 fd ff ff       	call   805f47 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  806247:	8b 43 78             	mov    0x78(%ebx),%eax
  80624a:	85 c0                	test   %eax,%eax
  80624c:	74 08                	je     806256 <tcp_abort+0x9d>
      tcp_segs_free(pcb->unacked);
  80624e:	89 04 24             	mov    %eax,(%esp)
  806251:	e8 98 fb ff ff       	call   805dee <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  806256:	8b 43 74             	mov    0x74(%ebx),%eax
  806259:	85 c0                	test   %eax,%eax
  80625b:	74 08                	je     806265 <tcp_abort+0xac>
      tcp_segs_free(pcb->unsent);
  80625d:	89 04 24             	mov    %eax,(%esp)
  806260:	e8 89 fb ff ff       	call   805dee <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  806265:	8b 43 7c             	mov    0x7c(%ebx),%eax
  806268:	85 c0                	test   %eax,%eax
  80626a:	74 08                	je     806274 <tcp_abort+0xbb>
      tcp_segs_free(pcb->ooseq);
  80626c:	89 04 24             	mov    %eax,(%esp)
  80626f:	e8 7a fb ff ff       	call   805dee <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  806274:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806278:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80627f:	e8 9e e7 ff ff       	call   804a22 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  806284:	85 f6                	test   %esi,%esi
  806286:	74 10                	je     806298 <tcp_abort+0xdf>
  806288:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  80628f:	ff 
  806290:	8b 45 cc             	mov    -0x34(%ebp),%eax
  806293:	89 04 24             	mov    %eax,(%esp)
  806296:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  806298:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  80629c:	89 44 24 14          	mov    %eax,0x14(%esp)
  8062a0:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  8062a4:	89 44 24 10          	mov    %eax,0x10(%esp)
  8062a8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8062ab:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8062af:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8062b2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8062b6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8062ba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8062bd:	89 04 24             	mov    %eax,(%esp)
  8062c0:	e8 00 29 00 00       	call   808bc5 <tcp_rst>
  }
}
  8062c5:	83 c4 4c             	add    $0x4c,%esp
  8062c8:	5b                   	pop    %ebx
  8062c9:	5e                   	pop    %esi
  8062ca:	5f                   	pop    %edi
  8062cb:	5d                   	pop    %ebp
  8062cc:	c3                   	ret    

008062cd <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  8062cd:	55                   	push   %ebp
  8062ce:	89 e5                	mov    %esp,%ebp
  8062d0:	57                   	push   %edi
  8062d1:	56                   	push   %esi
  8062d2:	53                   	push   %ebx
  8062d3:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  8062d6:	83 05 60 c2 b3 00 01 	addl   $0x1,0xb3c260

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  8062dd:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  8062e3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  8062e7:	bf 00 00 00 00       	mov    $0x0,%edi
  8062ec:	e9 3a 03 00 00       	jmp    80662b <tcp_slowtmr+0x35e>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  8062f1:	8b 43 10             	mov    0x10(%ebx),%eax
  8062f4:	85 c0                	test   %eax,%eax
  8062f6:	75 1c                	jne    806314 <tcp_slowtmr+0x47>
  8062f8:	c7 44 24 08 18 2e 81 	movl   $0x812e18,0x8(%esp)
  8062ff:	00 
  806300:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  806307:	00 
  806308:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  80630f:	e8 26 8d 00 00       	call   80f03a <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  806314:	83 f8 01             	cmp    $0x1,%eax
  806317:	75 1c                	jne    806335 <tcp_slowtmr+0x68>
  806319:	c7 44 24 08 44 2e 81 	movl   $0x812e44,0x8(%esp)
  806320:	00 
  806321:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  806328:	00 
  806329:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  806330:	e8 05 8d 00 00       	call   80f03a <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  806335:	83 f8 0a             	cmp    $0xa,%eax
  806338:	75 1c                	jne    806356 <tcp_slowtmr+0x89>
  80633a:	c7 44 24 08 70 2e 81 	movl   $0x812e70,0x8(%esp)
  806341:	00 
  806342:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  806349:	00 
  80634a:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  806351:	e8 e4 8c 00 00       	call   80f03a <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  806356:	83 f8 02             	cmp    $0x2,%eax
  806359:	75 0f                	jne    80636a <tcp_slowtmr+0x9d>
      ++pcb_remove;
  80635b:	be 01 00 00 00       	mov    $0x1,%esi
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  806360:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  806364:	0f 84 16 01 00 00    	je     806480 <tcp_slowtmr+0x1b3>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80636a:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  80636e:	be 01 00 00 00       	mov    $0x1,%esi

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  806373:	80 fa 0c             	cmp    $0xc,%dl
  806376:	0f 84 e9 00 00 00    	je     806465 <tcp_slowtmr+0x198>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80637c:	0f b6 8b a4 00 00 00 	movzbl 0xa4(%ebx),%ecx
  806383:	84 c9                	test   %cl,%cl
  806385:	74 50                	je     8063d7 <tcp_slowtmr+0x10a>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  806387:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  80638d:	83 c0 01             	add    $0x1,%eax
  806390:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  806396:	0f b6 d1             	movzbl %cl,%edx
  806399:	0f b6 92 27 30 81 00 	movzbl 0x813027(%edx),%edx
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  8063a0:	be 00 00 00 00       	mov    $0x0,%esi
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  8063a5:	39 d0                	cmp    %edx,%eax
  8063a7:	0f 82 b8 00 00 00    	jb     806465 <tcp_slowtmr+0x198>
          pcb->persist_cnt = 0;
  8063ad:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  8063b4:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  8063b7:	80 f9 06             	cmp    $0x6,%cl
  8063ba:	77 09                	ja     8063c5 <tcp_slowtmr+0xf8>
            pcb->persist_backoff++;
  8063bc:	83 c1 01             	add    $0x1,%ecx
  8063bf:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  8063c5:	89 1c 24             	mov    %ebx,(%esp)
  8063c8:	e8 48 2b 00 00       	call   808f15 <tcp_zero_window_probe>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  8063cd:	be 00 00 00 00       	mov    $0x0,%esi
  8063d2:	e9 8e 00 00 00       	jmp    806465 <tcp_slowtmr+0x198>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  8063d7:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  8063db:	66 85 c9             	test   %cx,%cx
  8063de:	78 07                	js     8063e7 <tcp_slowtmr+0x11a>
          ++pcb->rtime;
  8063e0:	83 c1 01             	add    $0x1,%ecx
  8063e3:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  8063e7:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8063eb:	74 73                	je     806460 <tcp_slowtmr+0x193>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  8063ed:	be 00 00 00 00       	mov    $0x0,%esi
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  8063f2:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  8063f6:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  8063fa:	7c 69                	jl     806465 <tcp_slowtmr+0x198>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  8063fc:	83 f8 02             	cmp    $0x2,%eax
  8063ff:	74 1f                	je     806420 <tcp_slowtmr+0x153>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  806401:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  806405:	66 c1 f8 03          	sar    $0x3,%ax
  806409:	98                   	cwtl   
  80640a:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  80640e:	01 c8                	add    %ecx,%eax
  806410:	0f b6 d2             	movzbl %dl,%edx
  806413:	0f b6 8a 2f 30 81 00 	movzbl 0x81302f(%edx),%ecx
  80641a:	d3 e0                	shl    %cl,%eax
  80641c:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  806420:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  806426:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80642a:	66 39 43 4e          	cmp    %ax,0x4e(%ebx)
  80642e:	66 0f 46 43 4e       	cmovbe 0x4e(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  806433:	66 d1 e8             	shr    %ax
  806436:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  80643a:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80643e:	66 39 d0             	cmp    %dx,%ax
  806441:	73 06                	jae    806449 <tcp_slowtmr+0x17c>
            pcb->ssthresh = pcb->mss * 2;
  806443:	01 d2                	add    %edx,%edx
  806445:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  806449:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80644d:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  806451:	89 1c 24             	mov    %ebx,(%esp)
  806454:	e8 c6 28 00 00       	call   808d1f <tcp_rexmit_rto>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  806459:	be 00 00 00 00       	mov    $0x0,%esi
  80645e:	eb 05                	jmp    806465 <tcp_slowtmr+0x198>
  806460:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  806465:	8b 43 10             	mov    0x10(%ebx),%eax
  806468:	83 f8 06             	cmp    $0x6,%eax
  80646b:	75 13                	jne    806480 <tcp_slowtmr+0x1b3>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80646d:	8b 15 60 c2 b3 00    	mov    0xb3c260,%edx
  806473:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  806476:	83 fa 29             	cmp    $0x29,%edx
  806479:	89 f1                	mov    %esi,%ecx
  80647b:	80 d9 ff             	sbb    $0xff,%cl
  80647e:	89 ce                	mov    %ecx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  806480:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  806484:	74 67                	je     8064ed <tcp_slowtmr+0x220>
  806486:	83 f8 07             	cmp    $0x7,%eax
  806489:	74 05                	je     806490 <tcp_slowtmr+0x1c3>
  80648b:	83 f8 04             	cmp    $0x4,%eax
  80648e:	75 5d                	jne    8064ed <tcp_slowtmr+0x220>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  806490:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  806495:	2b 43 2c             	sub    0x2c(%ebx),%eax
  806498:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80649b:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
  8064a1:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  8064a7:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8064ac:	f7 e2                	mul    %edx
  8064ae:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  8064b1:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8064b4:	76 0a                	jbe    8064c0 <tcp_slowtmr+0x1f3>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  8064b6:	89 1c 24             	mov    %ebx,(%esp)
  8064b9:	e8 fb fc ff ff       	call   8061b9 <tcp_abort>
  8064be:	eb 2d                	jmp    8064ed <tcp_slowtmr+0x220>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  8064c0:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  8064c7:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  8064cd:	01 d1                	add    %edx,%ecx
              / TCP_SLOW_INTERVAL)
  8064cf:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8064d4:	f7 e1                	mul    %ecx
  8064d6:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  8064d9:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8064dc:	76 0f                	jbe    8064ed <tcp_slowtmr+0x220>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  8064de:	89 1c 24             	mov    %ebx,(%esp)
  8064e1:	e8 db 28 00 00       	call   808dc1 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  8064e6:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  8064ed:	8b 53 7c             	mov    0x7c(%ebx),%edx
  8064f0:	85 d2                	test   %edx,%edx
  8064f2:	74 25                	je     806519 <tcp_slowtmr+0x24c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  8064f4:	8b 0d 60 c2 b3 00    	mov    0xb3c260,%ecx
  8064fa:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  8064fd:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  806501:	8d 04 40             	lea    (%eax,%eax,2),%eax
  806504:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  806506:	39 c1                	cmp    %eax,%ecx
  806508:	72 0f                	jb     806519 <tcp_slowtmr+0x24c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80650a:	89 14 24             	mov    %edx,(%esp)
  80650d:	e8 dc f8 ff ff       	call   805dee <tcp_segs_free>
      pcb->ooseq = NULL;
  806512:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  806519:	8b 43 10             	mov    0x10(%ebx),%eax
  80651c:	83 f8 03             	cmp    $0x3,%eax
  80651f:	75 13                	jne    806534 <tcp_slowtmr+0x267>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806521:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  806526:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  806529:	83 f8 29             	cmp    $0x29,%eax
  80652c:	89 f0                	mov    %esi,%eax
  80652e:	1c ff                	sbb    $0xff,%al
  806530:	89 c6                	mov    %eax,%esi
  806532:	eb 18                	jmp    80654c <tcp_slowtmr+0x27f>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  806534:	83 f8 09             	cmp    $0x9,%eax
  806537:	75 13                	jne    80654c <tcp_slowtmr+0x27f>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806539:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  80653e:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  806541:	3d f1 00 00 00       	cmp    $0xf1,%eax
  806546:	89 f0                	mov    %esi,%eax
  806548:	1c ff                	sbb    $0xff,%al
  80654a:	89 c6                	mov    %eax,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80654c:	89 f0                	mov    %esi,%eax
  80654e:	84 c0                	test   %al,%al
  806550:	0f 84 96 00 00 00    	je     8065ec <tcp_slowtmr+0x31f>
      tcp_pcb_purge(pcb);      
  806556:	89 1c 24             	mov    %ebx,(%esp)
  806559:	e8 74 f9 ff ff       	call   805ed2 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80655e:	85 ff                	test   %edi,%edi
  806560:	74 2c                	je     80658e <tcp_slowtmr+0x2c1>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  806562:	3b 1d 5c c2 b3 00    	cmp    0xb3c25c,%ebx
  806568:	75 1c                	jne    806586 <tcp_slowtmr+0x2b9>
  80656a:	c7 44 24 08 a0 2e 81 	movl   $0x812ea0,0x8(%esp)
  806571:	00 
  806572:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  806579:	00 
  80657a:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  806581:	e8 b4 8a 00 00       	call   80f03a <_panic>
        prev->next = pcb->next;
  806586:	8b 43 0c             	mov    0xc(%ebx),%eax
  806589:	89 47 0c             	mov    %eax,0xc(%edi)
  80658c:	eb 2d                	jmp    8065bb <tcp_slowtmr+0x2ee>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80658e:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  806593:	39 d8                	cmp    %ebx,%eax
  806595:	74 1c                	je     8065b3 <tcp_slowtmr+0x2e6>
  806597:	c7 44 24 08 cc 2e 81 	movl   $0x812ecc,0x8(%esp)
  80659e:	00 
  80659f:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  8065a6:	00 
  8065a7:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  8065ae:	e8 87 8a 00 00       	call   80f03a <_panic>
        tcp_active_pcbs = pcb->next;
  8065b3:	8b 40 0c             	mov    0xc(%eax),%eax
  8065b6:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  8065bb:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  8065c1:	85 c0                	test   %eax,%eax
  8065c3:	74 10                	je     8065d5 <tcp_slowtmr+0x308>
  8065c5:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  8065cc:	ff 
  8065cd:	8b 53 18             	mov    0x18(%ebx),%edx
  8065d0:	89 14 24             	mov    %edx,(%esp)
  8065d3:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  8065d5:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  8065d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8065dc:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8065e3:	e8 3a e4 ff ff       	call   804a22 <memp_free>
      pcb = pcb2;
  8065e8:	89 f3                	mov    %esi,%ebx
  8065ea:	eb 3f                	jmp    80662b <tcp_slowtmr+0x35e>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  8065ec:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  8065f0:	83 c0 01             	add    $0x1,%eax
  8065f3:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  8065f6:	3a 43 31             	cmp    0x31(%ebx),%al
  8065f9:	72 2b                	jb     806626 <tcp_slowtmr+0x359>
        pcb->polltmr = 0;
  8065fb:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  8065ff:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  806605:	85 c0                	test   %eax,%eax
  806607:	74 0f                	je     806618 <tcp_slowtmr+0x34b>
  806609:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80660d:	8b 53 18             	mov    0x18(%ebx),%edx
  806610:	89 14 24             	mov    %edx,(%esp)
  806613:	ff d0                	call   *%eax
  806615:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  806618:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80661c:	75 08                	jne    806626 <tcp_slowtmr+0x359>
          tcp_output(pcb);
  80661e:	89 1c 24             	mov    %ebx,(%esp)
  806621:	e8 0b 21 00 00       	call   808731 <tcp_output>
        }
      }
      
      prev = pcb;
  806626:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  806628:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80662b:	85 db                	test   %ebx,%ebx
  80662d:	0f 85 be fc ff ff    	jne    8062f1 <tcp_slowtmr+0x24>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  806633:	8b 35 70 c2 b3 00    	mov    0xb3c270,%esi
  while (pcb != NULL) {
  806639:	e9 b2 00 00 00       	jmp    8066f0 <tcp_slowtmr+0x423>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80663e:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  806642:	74 1c                	je     806660 <tcp_slowtmr+0x393>
  806644:	c7 44 24 08 f8 2e 81 	movl   $0x812ef8,0x8(%esp)
  80664b:	00 
  80664c:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  806653:	00 
  806654:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  80665b:	e8 da 89 00 00       	call   80f03a <_panic>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806660:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  806665:	2b 46 2c             	sub    0x2c(%esi),%eax
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  806668:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80666d:	76 7c                	jbe    8066eb <tcp_slowtmr+0x41e>
      tcp_pcb_purge(pcb);      
  80666f:	89 34 24             	mov    %esi,(%esp)
  806672:	e8 5b f8 ff ff       	call   805ed2 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  806677:	85 db                	test   %ebx,%ebx
  806679:	74 2c                	je     8066a7 <tcp_slowtmr+0x3da>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80667b:	3b 35 70 c2 b3 00    	cmp    0xb3c270,%esi
  806681:	75 1c                	jne    80669f <tcp_slowtmr+0x3d2>
  806683:	c7 44 24 08 28 2f 81 	movl   $0x812f28,0x8(%esp)
  80668a:	00 
  80668b:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  806692:	00 
  806693:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  80669a:	e8 9b 89 00 00       	call   80f03a <_panic>
        prev->next = pcb->next;
  80669f:	8b 46 0c             	mov    0xc(%esi),%eax
  8066a2:	89 43 0c             	mov    %eax,0xc(%ebx)
  8066a5:	eb 2d                	jmp    8066d4 <tcp_slowtmr+0x407>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8066a7:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  8066ac:	39 f0                	cmp    %esi,%eax
  8066ae:	74 1c                	je     8066cc <tcp_slowtmr+0x3ff>
  8066b0:	c7 44 24 08 50 2f 81 	movl   $0x812f50,0x8(%esp)
  8066b7:	00 
  8066b8:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  8066bf:	00 
  8066c0:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  8066c7:	e8 6e 89 00 00       	call   80f03a <_panic>
        tcp_tw_pcbs = pcb->next;
  8066cc:	8b 40 0c             	mov    0xc(%eax),%eax
  8066cf:	a3 70 c2 b3 00       	mov    %eax,0xb3c270
      }
      pcb2 = pcb->next;
  8066d4:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  8066d7:	89 74 24 04          	mov    %esi,0x4(%esp)
  8066db:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8066e2:	e8 3b e3 ff ff       	call   804a22 <memp_free>
      pcb = pcb2;
  8066e7:	89 fe                	mov    %edi,%esi
  8066e9:	eb 05                	jmp    8066f0 <tcp_slowtmr+0x423>
    } else {
      prev = pcb;
  8066eb:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  8066ed:	8b 76 0c             	mov    0xc(%esi),%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8066f0:	85 f6                	test   %esi,%esi
  8066f2:	0f 85 46 ff ff ff    	jne    80663e <tcp_slowtmr+0x371>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8066f8:	83 c4 2c             	add    $0x2c,%esp
  8066fb:	5b                   	pop    %ebx
  8066fc:	5e                   	pop    %esi
  8066fd:	5f                   	pop    %edi
  8066fe:	5d                   	pop    %ebp
  8066ff:	c3                   	ret    

00806700 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  806700:	55                   	push   %ebp
  806701:	89 e5                	mov    %esp,%ebp
  806703:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  806706:	e8 24 f6 ff ff       	call   805d2f <tcp_fasttmr>

  if (++tcp_timer & 1) {
  80670b:	0f b6 05 19 54 b3 00 	movzbl 0xb35419,%eax
  806712:	83 c0 01             	add    $0x1,%eax
  806715:	a2 19 54 b3 00       	mov    %al,0xb35419
  80671a:	a8 01                	test   $0x1,%al
  80671c:	74 05                	je     806723 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80671e:	e8 aa fb ff ff       	call   8062cd <tcp_slowtmr>
  }
}
  806723:	c9                   	leave  
  806724:	c3                   	ret    

00806725 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  806725:	55                   	push   %ebp
  806726:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806728:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  80672d:	03 05 08 50 81 00    	add    0x815008,%eax
  806733:	a3 08 50 81 00       	mov    %eax,0x815008
  return iss;
}
  806738:	5d                   	pop    %ebp
  806739:	c3                   	ret    

0080673a <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  80673a:	55                   	push   %ebp
  80673b:	89 e5                	mov    %esp,%ebp
  80673d:	57                   	push   %edi
  80673e:	56                   	push   %esi
  80673f:	53                   	push   %ebx
  806740:	83 ec 2c             	sub    $0x2c,%esp
  806743:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  806747:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80674e:	e8 6f e2 ff ff       	call   8049c2 <memp_malloc>
  806753:	89 c6                	mov    %eax,%esi
  if (pcb == NULL) {
  806755:	85 c0                	test   %eax,%eax
  806757:	0f 85 b3 00 00 00    	jne    806810 <tcp_alloc+0xd6>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80675d:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806762:	8b 35 60 c2 b3 00    	mov    0xb3c260,%esi
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  806768:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  80676d:	bf 00 00 00 00       	mov    $0x0,%edi
  806772:	eb 10                	jmp    806784 <tcp_alloc+0x4a>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806774:	89 f2                	mov    %esi,%edx
  806776:	2b 50 2c             	sub    0x2c(%eax),%edx
  806779:	39 ca                	cmp    %ecx,%edx
  80677b:	72 04                	jb     806781 <tcp_alloc+0x47>
      inactivity = tcp_ticks - pcb->tmr;
  80677d:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  80677f:	89 c7                	mov    %eax,%edi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806781:	8b 40 0c             	mov    0xc(%eax),%eax
  806784:	85 c0                	test   %eax,%eax
  806786:	75 ec                	jne    806774 <tcp_alloc+0x3a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  806788:	85 ff                	test   %edi,%edi
  80678a:	74 08                	je     806794 <tcp_alloc+0x5a>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80678c:	89 3c 24             	mov    %edi,(%esp)
  80678f:	e8 25 fa ff ff       	call   8061b9 <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  806794:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80679b:	e8 22 e2 ff ff       	call   8049c2 <memp_malloc>
  8067a0:	89 c6                	mov    %eax,%esi
    if (pcb == NULL) {
  8067a2:	85 c0                	test   %eax,%eax
  8067a4:	75 6a                	jne    806810 <tcp_alloc+0xd6>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8067a6:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8067ab:	8b 3d 60 c2 b3 00    	mov    0xb3c260,%edi
  8067b1:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8067b4:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  8067b9:	bf 00 00 00 00       	mov    $0x0,%edi
  inactive = NULL;
  8067be:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8067c5:	eb 20                	jmp    8067e7 <tcp_alloc+0xad>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  8067c7:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  8067cb:	38 d3                	cmp    %dl,%bl
  8067cd:	72 15                	jb     8067e4 <tcp_alloc+0xaa>
  8067cf:	38 ca                	cmp    %cl,%dl
  8067d1:	77 11                	ja     8067e4 <tcp_alloc+0xaa>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8067d3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8067d6:	2b 70 2c             	sub    0x2c(%eax),%esi
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  8067d9:	39 fe                	cmp    %edi,%esi
  8067db:	72 07                	jb     8067e4 <tcp_alloc+0xaa>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  8067dd:	89 d1                	mov    %edx,%ecx
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  8067df:	89 f7                	mov    %esi,%edi
      inactive = pcb;
  8067e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8067e4:	8b 40 0c             	mov    0xc(%eax),%eax
  8067e7:	85 c0                	test   %eax,%eax
  8067e9:	75 dc                	jne    8067c7 <tcp_alloc+0x8d>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  8067eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8067ee:	85 c0                	test   %eax,%eax
  8067f0:	74 08                	je     8067fa <tcp_alloc+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8067f2:	89 04 24             	mov    %eax,(%esp)
  8067f5:	e8 bf f9 ff ff       	call   8061b9 <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  8067fa:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806801:	e8 bc e1 ff ff       	call   8049c2 <memp_malloc>
  806806:	89 c6                	mov    %eax,%esi
    }
  }
  if (pcb != NULL) {
  806808:	85 c0                	test   %eax,%eax
  80680a:	0f 84 9b 00 00 00    	je     8068ab <tcp_alloc+0x171>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806810:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  806817:	00 
  806818:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80681f:	00 
  806820:	89 34 24             	mov    %esi,(%esp)
  806823:	e8 cf 90 00 00       	call   80f8f7 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806828:	c6 46 14 40          	movb   $0x40,0x14(%esi)
    pcb->snd_buf = TCP_SND_BUF;
  80682c:	66 c7 46 6e 40 5b    	movw   $0x5b40,0x6e(%esi)
    pcb->snd_queuelen = 0;
  806832:	66 c7 46 70 00 00    	movw   $0x0,0x70(%esi)
    pcb->rcv_wnd = TCP_WND;
  806838:	66 c7 46 28 c0 5d    	movw   $0x5dc0,0x28(%esi)
    pcb->rcv_ann_wnd = TCP_WND;
  80683e:	66 c7 46 2a c0 5d    	movw   $0x5dc0,0x2a(%esi)
    pcb->tos = 0;
  806844:	c6 46 0a 00          	movb   $0x0,0xa(%esi)
    pcb->ttl = TCP_TTL;
  806848:	c6 46 0b ff          	movb   $0xff,0xb(%esi)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80684c:	66 c7 46 34 18 02    	movw   $0x218,0x34(%esi)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  806852:	66 c7 46 44 06 00    	movw   $0x6,0x44(%esi)
    pcb->sa = 0;
  806858:	66 c7 46 40 00 00    	movw   $0x0,0x40(%esi)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80685e:	66 c7 46 42 06 00    	movw   $0x6,0x42(%esi)
    pcb->rtime = -1;
  806864:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
    pcb->cwnd = 1;
  80686a:	66 c7 46 4e 01 00    	movw   $0x1,0x4e(%esi)
    iss = tcp_next_iss();
  806870:	e8 b0 fe ff ff       	call   806725 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  806875:	89 46 64             	mov    %eax,0x64(%esi)
    pcb->snd_nxt = iss;
  806878:	89 46 54             	mov    %eax,0x54(%esi)
    pcb->snd_max = iss;
  80687b:	89 46 58             	mov    %eax,0x58(%esi)
    pcb->lastack = iss;
  80687e:	89 46 48             	mov    %eax,0x48(%esi)
    pcb->snd_lbb = iss;   
  806881:	89 46 68             	mov    %eax,0x68(%esi)
    pcb->tmr = tcp_ticks;
  806884:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  806889:	89 46 2c             	mov    %eax,0x2c(%esi)

    pcb->polltmr = 0;
  80688c:	c6 46 30 00          	movb   $0x0,0x30(%esi)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  806890:	c7 86 88 00 00 00 84 	movl   $0x806184,0x88(%esi)
  806897:	61 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80689a:	c7 86 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%esi)
  8068a1:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8068a4:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)
  }
  return pcb;
}
  8068ab:	89 f0                	mov    %esi,%eax
  8068ad:	83 c4 2c             	add    $0x2c,%esp
  8068b0:	5b                   	pop    %ebx
  8068b1:	5e                   	pop    %esi
  8068b2:	5f                   	pop    %edi
  8068b3:	5d                   	pop    %ebp
  8068b4:	c3                   	ret    

008068b5 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8068b5:	55                   	push   %ebp
  8068b6:	89 e5                	mov    %esp,%ebp
  8068b8:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8068bb:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8068c2:	e8 73 fe ff ff       	call   80673a <tcp_alloc>
}
  8068c7:	c9                   	leave  
  8068c8:	c3                   	ret    

008068c9 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  8068c9:	55                   	push   %ebp
  8068ca:	89 e5                	mov    %esp,%ebp
  8068cc:	56                   	push   %esi
  8068cd:	53                   	push   %ebx
  8068ce:	83 ec 10             	sub    $0x10,%esp
  8068d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8068d4:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  8068d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8068d9:	89 04 24             	mov    %eax,(%esp)
  8068dc:	e8 df 01 00 00       	call   806ac0 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  8068e1:	85 c0                	test   %eax,%eax
  8068e3:	74 12                	je     8068f7 <tcp_eff_send_mss+0x2e>
  8068e5:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8068e9:	66 85 c0             	test   %ax,%ax
  8068ec:	74 09                	je     8068f7 <tcp_eff_send_mss+0x2e>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  8068ee:	8d 70 d8             	lea    -0x28(%eax),%esi
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  8068f1:	66 39 f3             	cmp    %si,%bx
  8068f4:	0f 46 f3             	cmovbe %ebx,%esi
  }
  return sendmss;
}
  8068f7:	89 f0                	mov    %esi,%eax
  8068f9:	83 c4 10             	add    $0x10,%esp
  8068fc:	5b                   	pop    %ebx
  8068fd:	5e                   	pop    %esi
  8068fe:	5d                   	pop    %ebp
  8068ff:	c3                   	ret    

00806900 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  806900:	55                   	push   %ebp
  806901:	89 e5                	mov    %esp,%ebp
  806903:	56                   	push   %esi
  806904:	53                   	push   %ebx
  806905:	83 ec 30             	sub    $0x30,%esp
  806908:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80690b:	8b 75 0c             	mov    0xc(%ebp),%esi
  80690e:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806911:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  806915:	74 1c                	je     806933 <tcp_connect+0x33>
  806917:	c7 44 24 08 78 2f 81 	movl   $0x812f78,0x8(%esp)
  80691e:	00 
  80691f:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  806926:	00 
  806927:	c7 04 24 aa 2f 81 00 	movl   $0x812faa,(%esp)
  80692e:	e8 07 87 00 00       	call   80f03a <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  806933:	85 f6                	test   %esi,%esi
  806935:	0f 84 2a 01 00 00    	je     806a65 <tcp_connect+0x165>
    pcb->remote_ip = *ipaddr;
  80693b:	8b 16                	mov    (%esi),%edx
  80693d:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  806940:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  806944:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  806949:	75 09                	jne    806954 <tcp_connect+0x54>
    pcb->local_port = tcp_new_port();
  80694b:	e8 2a f0 ff ff       	call   80597a <tcp_new_port>
  806950:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  806954:	e8 cc fd ff ff       	call   806725 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806959:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  806960:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  806963:	83 e8 01             	sub    $0x1,%eax
  806966:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  806969:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  80696c:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  806972:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  806978:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80697e:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  806984:	89 74 24 04          	mov    %esi,0x4(%esp)
  806988:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  80698f:	e8 35 ff ff ff       	call   8068c9 <tcp_eff_send_mss>
  806994:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  806998:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  80699e:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8069a1:	01 c0                	add    %eax,%eax
  8069a3:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8069a7:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8069ae:	8b 45 14             	mov    0x14(%ebp),%eax
  8069b1:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8069b7:	8b 15 6c c2 b3 00    	mov    0xb3c26c,%edx
  8069bd:	39 da                	cmp    %ebx,%edx
  8069bf:	75 0a                	jne    8069cb <tcp_connect+0xcb>
  8069c1:	8b 42 0c             	mov    0xc(%edx),%eax
  8069c4:	a3 6c c2 b3 00       	mov    %eax,0xb3c26c
  8069c9:	eb 2d                	jmp    8069f8 <tcp_connect+0xf8>
  8069cb:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  8069d1:	eb 1b                	jmp    8069ee <tcp_connect+0xee>
  8069d3:	8b 42 0c             	mov    0xc(%edx),%eax
  8069d6:	85 c0                	test   %eax,%eax
  8069d8:	74 12                	je     8069ec <tcp_connect+0xec>
  8069da:	39 c3                	cmp    %eax,%ebx
  8069dc:	75 0e                	jne    8069ec <tcp_connect+0xec>
  8069de:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  8069e4:	8b 43 0c             	mov    0xc(%ebx),%eax
  8069e7:	89 42 0c             	mov    %eax,0xc(%edx)
  8069ea:	eb 0c                	jmp    8069f8 <tcp_connect+0xf8>
  8069ec:	89 c2                	mov    %eax,%edx
  8069ee:	85 d2                	test   %edx,%edx
  8069f0:	75 e1                	jne    8069d3 <tcp_connect+0xd3>
  8069f2:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  TCP_REG(&tcp_active_pcbs, pcb);
  8069f8:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  8069fd:	89 43 0c             	mov    %eax,0xc(%ebx)
  806a00:	89 1d 5c c2 b3 00    	mov    %ebx,0xb3c25c
  806a06:	e8 47 bb ff ff       	call   802552 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  806a0b:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  806a12:	e8 49 13 00 00       	call   807d60 <htonl>
  806a17:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806a1a:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  806a21:	00 
  806a22:	8d 45 f4             	lea    -0xc(%ebp),%eax
  806a25:	89 44 24 14          	mov    %eax,0x14(%esp)
  806a29:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  806a30:	00 
  806a31:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  806a38:	00 
  806a39:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806a40:	00 
  806a41:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806a48:	00 
  806a49:	89 1c 24             	mov    %ebx,(%esp)
  806a4c:	e8 5f 15 00 00       	call   807fb0 <tcp_enqueue>
  806a51:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  806a53:	89 f1                	mov    %esi,%ecx
  806a55:	84 c9                	test   %cl,%cl
  806a57:	75 11                	jne    806a6a <tcp_connect+0x16a>
    tcp_output(pcb);
  806a59:	89 1c 24             	mov    %ebx,(%esp)
  806a5c:	e8 d0 1c 00 00       	call   808731 <tcp_output>
  }
  return ret;
  806a61:	89 f0                	mov    %esi,%eax
  806a63:	eb 05                	jmp    806a6a <tcp_connect+0x16a>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  806a65:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  806a6a:	83 c4 30             	add    $0x30,%esp
  806a6d:	5b                   	pop    %ebx
  806a6e:	5e                   	pop    %esi
  806a6f:	5d                   	pop    %ebp
  806a70:	c3                   	ret    

00806a71 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  806a71:	55                   	push   %ebp
  806a72:	89 e5                	mov    %esp,%ebp
  806a74:	53                   	push   %ebx
  806a75:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806a78:	8b 45 08             	mov    0x8(%ebp),%eax
  806a7b:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806a7d:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  806a80:	b8 01 00 00 00       	mov    $0x1,%eax
{
  u32_t addr2test;

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806a85:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806a88:	77 32                	ja     806abc <ip_addr_isbroadcast+0x4b>
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  806a8a:	b8 00 00 00 00       	mov    $0x0,%eax
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806a8f:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  806a93:	74 27                	je     806abc <ip_addr_isbroadcast+0x4b>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  806a95:	8b 41 04             	mov    0x4(%ecx),%eax
  806a98:	39 d0                	cmp    %edx,%eax
  806a9a:	74 1b                	je     806ab7 <ip_addr_isbroadcast+0x46>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806a9c:	8b 49 08             	mov    0x8(%ecx),%ecx
  806a9f:	31 d0                	xor    %edx,%eax
  806aa1:	89 c3                	mov    %eax,%ebx
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  806aa3:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806aa8:	85 cb                	test   %ecx,%ebx
  806aaa:	75 10                	jne    806abc <ip_addr_isbroadcast+0x4b>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806aac:	f7 d1                	not    %ecx
  806aae:	21 ca                	and    %ecx,%edx
  806ab0:	39 d1                	cmp    %edx,%ecx
  806ab2:	0f 94 c0             	sete   %al
  806ab5:	eb 05                	jmp    806abc <ip_addr_isbroadcast+0x4b>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  806ab7:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806abc:	5b                   	pop    %ebx
  806abd:	5d                   	pop    %ebp
  806abe:	c3                   	ret    
  806abf:	90                   	nop

00806ac0 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  806ac0:	55                   	push   %ebp
  806ac1:	89 e5                	mov    %esp,%ebp
  806ac3:	56                   	push   %esi
  806ac4:	53                   	push   %ebx
  806ac5:	83 ec 10             	sub    $0x10,%esp
  806ac8:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806acb:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  806ad1:	eb 18                	jmp    806aeb <ip_route+0x2b>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806ad3:	89 1c 24             	mov    %ebx,(%esp)
  806ad6:	e8 02 e2 ff ff       	call   804cdd <netif_is_up>
  806adb:	84 c0                	test   %al,%al
  806add:	74 0a                	je     806ae9 <ip_route+0x29>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  806adf:	8b 43 04             	mov    0x4(%ebx),%eax
  806ae2:	33 06                	xor    (%esi),%eax
  806ae4:	85 43 08             	test   %eax,0x8(%ebx)
  806ae7:	74 27                	je     806b10 <ip_route+0x50>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806ae9:	8b 1b                	mov    (%ebx),%ebx
  806aeb:	85 db                	test   %ebx,%ebx
  806aed:	75 e4                	jne    806ad3 <ip_route+0x13>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806aef:	a1 58 c2 b3 00       	mov    0xb3c258,%eax
  806af4:	85 c0                	test   %eax,%eax
  806af6:	74 1c                	je     806b14 <ip_route+0x54>
  806af8:	89 04 24             	mov    %eax,(%esp)
  806afb:	e8 dd e1 ff ff       	call   804cdd <netif_is_up>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806b00:	84 c0                	test   %al,%al
  806b02:	b8 00 00 00 00       	mov    $0x0,%eax
  806b07:	0f 45 05 58 c2 b3 00 	cmovne 0xb3c258,%eax
  806b0e:	eb 09                	jmp    806b19 <ip_route+0x59>
  806b10:	89 d8                	mov    %ebx,%eax
  806b12:	eb 05                	jmp    806b19 <ip_route+0x59>
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  806b14:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
  806b19:	83 c4 10             	add    $0x10,%esp
  806b1c:	5b                   	pop    %ebx
  806b1d:	5e                   	pop    %esi
  806b1e:	5d                   	pop    %ebp
  806b1f:	c3                   	ret    

00806b20 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  806b20:	55                   	push   %ebp
  806b21:	89 e5                	mov    %esp,%ebp
  806b23:	57                   	push   %edi
  806b24:	56                   	push   %esi
  806b25:	53                   	push   %ebx
  806b26:	83 ec 2c             	sub    $0x2c,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806b29:	8b 45 08             	mov    0x8(%ebp),%eax
  806b2c:	8b 70 04             	mov    0x4(%eax),%esi
  if (IPH_V(iphdr) != 4) {
  806b2f:	0f b7 06             	movzwl (%esi),%eax
  806b32:	89 04 24             	mov    %eax,(%esp)
  806b35:	e8 19 12 00 00       	call   807d53 <ntohs>
  806b3a:	66 c1 e8 0c          	shr    $0xc,%ax
  806b3e:	66 83 f8 04          	cmp    $0x4,%ax
  806b42:	74 10                	je     806b54 <ip_input+0x34>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806b44:	8b 45 08             	mov    0x8(%ebp),%eax
  806b47:	89 04 24             	mov    %eax,(%esp)
  806b4a:	e8 85 e2 ff ff       	call   804dd4 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806b4f:	e9 9d 02 00 00       	jmp    806df1 <ip_input+0x2d1>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  806b54:	0f b7 06             	movzwl (%esi),%eax
  806b57:	89 04 24             	mov    %eax,(%esp)
  806b5a:	e8 f4 11 00 00       	call   807d53 <ntohs>
  806b5f:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  806b63:	83 e0 3c             	and    $0x3c,%eax
  806b66:	89 c7                	mov    %eax,%edi
  806b68:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806b6c:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806b70:	89 04 24             	mov    %eax,(%esp)
  806b73:	e8 db 11 00 00       	call   807d53 <ntohs>
  806b78:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806b7a:	8b 55 08             	mov    0x8(%ebp),%edx
  806b7d:	66 3b 7a 0a          	cmp    0xa(%edx),%di
  806b81:	77 06                	ja     806b89 <ip_input+0x69>
  806b83:	66 3b 5a 08          	cmp    0x8(%edx),%bx
  806b87:	76 10                	jbe    806b99 <ip_input+0x79>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  806b89:	8b 45 08             	mov    0x8(%ebp),%eax
  806b8c:	89 04 24             	mov    %eax,(%esp)
  806b8f:	e8 40 e2 ff ff       	call   804dd4 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  806b94:	e9 58 02 00 00       	jmp    806df1 <ip_input+0x2d1>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806b99:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806b9d:	89 44 24 04          	mov    %eax,0x4(%esp)
  806ba1:	89 34 24             	mov    %esi,(%esp)
  806ba4:	e8 4f 10 00 00       	call   807bf8 <inet_chksum>
  806ba9:	66 85 c0             	test   %ax,%ax
  806bac:	74 10                	je     806bbe <ip_input+0x9e>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806bae:	8b 45 08             	mov    0x8(%ebp),%eax
  806bb1:	89 04 24             	mov    %eax,(%esp)
  806bb4:	e8 1b e2 ff ff       	call   804dd4 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806bb9:	e9 33 02 00 00       	jmp    806df1 <ip_input+0x2d1>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806bbe:	0f b7 db             	movzwl %bx,%ebx
  806bc1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806bc5:	8b 45 08             	mov    0x8(%ebp),%eax
  806bc8:	89 04 24             	mov    %eax,(%esp)
  806bcb:	e8 76 e5 ff ff       	call   805146 <pbuf_realloc>
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  806bd0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  806bd3:	bf 01 00 00 00       	mov    $0x1,%edi
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806bd8:	8d 46 10             	lea    0x10(%esi),%eax
  806bdb:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806bde:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  806be1:	89 de                	mov    %ebx,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806be3:	89 1c 24             	mov    %ebx,(%esp)
  806be6:	e8 f2 e0 ff ff       	call   804cdd <netif_is_up>
  806beb:	84 c0                	test   %al,%al
  806bed:	74 27                	je     806c16 <ip_input+0xf6>
  806bef:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806bf2:	74 22                	je     806c16 <ip_input+0xf6>
  806bf4:	8b 43 04             	mov    0x4(%ebx),%eax
  806bf7:	85 c0                	test   %eax,%eax
  806bf9:	74 1b                	je     806c16 <ip_input+0xf6>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806bfb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806bfe:	3b 41 10             	cmp    0x10(%ecx),%eax
  806c01:	74 32                	je     806c35 <ip_input+0x115>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806c03:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806c07:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806c0a:	89 04 24             	mov    %eax,(%esp)
  806c0d:	e8 5f fe ff ff       	call   806a71 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806c12:	84 c0                	test   %al,%al
  806c14:	75 26                	jne    806c3c <ip_input+0x11c>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  806c16:	85 ff                	test   %edi,%edi
  806c18:	74 08                	je     806c22 <ip_input+0x102>
        first = 0;
        netif = netif_list;
  806c1a:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  806c20:	eb 02                	jmp    806c24 <ip_input+0x104>
      } else {
        netif = netif->next;
  806c22:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  806c24:	39 f3                	cmp    %esi,%ebx
  806c26:	75 02                	jne    806c2a <ip_input+0x10a>
        netif = netif->next;
  806c28:	8b 1e                	mov    (%esi),%ebx
      }
    } while(netif != NULL);
  806c2a:	85 db                	test   %ebx,%ebx
  806c2c:	74 1d                	je     806c4b <ip_input+0x12b>
  806c2e:	bf 00 00 00 00       	mov    $0x0,%edi
  806c33:	eb ae                	jmp    806be3 <ip_input+0xc3>
  806c35:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  806c38:	89 d8                	mov    %ebx,%eax
  806c3a:	eb 05                	jmp    806c41 <ip_input+0x121>
  806c3c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  806c3f:	89 d8                	mov    %ebx,%eax
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  806c41:	85 c0                	test   %eax,%eax
  806c43:	0f 85 89 01 00 00    	jne    806dd2 <ip_input+0x2b2>
  806c49:	eb 03                	jmp    806c4e <ip_input+0x12e>
  806c4b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806c4e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806c52:	89 04 24             	mov    %eax,(%esp)
  806c55:	e8 f9 10 00 00       	call   807d53 <ntohs>
  806c5a:	bb 00 00 00 00       	mov    $0x0,%ebx
  806c5f:	3c 11                	cmp    $0x11,%al
  806c61:	0f 85 6b 01 00 00    	jne    806dd2 <ip_input+0x2b2>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806c67:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806c6b:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  806c70:	89 04 24             	mov    %eax,(%esp)
  806c73:	e8 db 10 00 00       	call   807d53 <ntohs>
  806c78:	66 83 f8 44          	cmp    $0x44,%ax
  806c7c:	74 36                	je     806cb4 <ip_input+0x194>
  806c7e:	e9 4f 01 00 00       	jmp    806dd2 <ip_input+0x2b2>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806c83:	8b 7e 0c             	mov    0xc(%esi),%edi
  806c86:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806c8d:	e8 08 13 00 00       	call   807f9a <ntohl>
  806c92:	21 c7                	and    %eax,%edi
  806c94:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806c9b:	e8 fa 12 00 00       	call   807f9a <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806ca0:	39 c7                	cmp    %eax,%edi
  806ca2:	75 13                	jne    806cb7 <ip_input+0x197>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806ca4:	8b 45 08             	mov    0x8(%ebp),%eax
  806ca7:	89 04 24             	mov    %eax,(%esp)
  806caa:	e8 25 e1 ff ff       	call   804dd4 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  806caf:	e9 3d 01 00 00       	jmp    806df1 <ip_input+0x2d1>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  806cb4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  806cb7:	85 db                	test   %ebx,%ebx
  806cb9:	75 10                	jne    806ccb <ip_input+0x1ab>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  806cbb:	8b 45 08             	mov    0x8(%ebp),%eax
  806cbe:	89 04 24             	mov    %eax,(%esp)
  806cc1:	e8 0e e1 ff ff       	call   804dd4 <pbuf_free>
    return ERR_OK;
  806cc6:	e9 26 01 00 00       	jmp    806df1 <ip_input+0x2d1>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806ccb:	0f b7 5e 06          	movzwl 0x6(%esi),%ebx
  806ccf:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  806cd6:	e8 6b 10 00 00       	call   807d46 <htons>
  806cdb:	66 85 d8             	test   %bx,%ax
  806cde:	74 19                	je     806cf9 <ip_input+0x1d9>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  806ce0:	8b 45 08             	mov    0x8(%ebp),%eax
  806ce3:	89 04 24             	mov    %eax,(%esp)
  806ce6:	e8 52 05 00 00       	call   80723d <ip_reass>
  806ceb:	89 45 08             	mov    %eax,0x8(%ebp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  806cee:	85 c0                	test   %eax,%eax
  806cf0:	0f 84 fb 00 00 00    	je     806df1 <ip_input+0x2d1>
      return ERR_OK;
    }
    iphdr = p->payload;
  806cf6:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  806cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
  806cfc:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d00:	8b 45 08             	mov    0x8(%ebp),%eax
  806d03:	89 04 24             	mov    %eax,(%esp)
  806d06:	e8 6e 7a 00 00       	call   80e779 <raw_input>
  806d0b:	84 c0                	test   %al,%al
  806d0d:	0f 85 de 00 00 00    	jne    806df1 <ip_input+0x2d1>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  806d13:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806d17:	89 04 24             	mov    %eax,(%esp)
  806d1a:	e8 34 10 00 00       	call   807d53 <ntohs>
  806d1f:	0f b6 c0             	movzbl %al,%eax
  806d22:	66 83 f8 06          	cmp    $0x6,%ax
  806d26:	74 25                	je     806d4d <ip_input+0x22d>
  806d28:	66 83 f8 11          	cmp    $0x11,%ax
  806d2c:	74 08                	je     806d36 <ip_input+0x216>
  806d2e:	66 83 f8 01          	cmp    $0x1,%ax
  806d32:	75 44                	jne    806d78 <ip_input+0x258>
  806d34:	eb 2e                	jmp    806d64 <ip_input+0x244>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  806d36:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d39:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d3d:	8b 45 08             	mov    0x8(%ebp),%eax
  806d40:	89 04 24             	mov    %eax,(%esp)
  806d43:	e8 48 23 00 00       	call   809090 <udp_input>
      break;
  806d48:	e9 a4 00 00 00       	jmp    806df1 <ip_input+0x2d1>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  806d4d:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d50:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d54:	8b 45 08             	mov    0x8(%ebp),%eax
  806d57:	89 04 24             	mov    %eax,(%esp)
  806d5a:	e8 d9 6c 00 00       	call   80da38 <tcp_input>
      break;
  806d5f:	e9 8d 00 00 00       	jmp    806df1 <ip_input+0x2d1>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  806d64:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d67:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d6b:	8b 45 08             	mov    0x8(%ebp),%eax
  806d6e:	89 04 24             	mov    %eax,(%esp)
  806d71:	e8 fa 7c 00 00       	call   80ea70 <icmp_input>
      break;
  806d76:	eb 79                	jmp    806df1 <ip_input+0x2d1>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806d78:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d7b:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d7f:	8d 46 10             	lea    0x10(%esi),%eax
  806d82:	89 04 24             	mov    %eax,(%esp)
  806d85:	e8 e7 fc ff ff       	call   806a71 <ip_addr_isbroadcast>
  806d8a:	84 c0                	test   %al,%al
  806d8c:	75 37                	jne    806dc5 <ip_input+0x2a5>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806d8e:	8b 5e 10             	mov    0x10(%esi),%ebx
  806d91:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806d98:	e8 fd 11 00 00       	call   807f9a <ntohl>
  806d9d:	21 c3                	and    %eax,%ebx
  806d9f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806da6:	e8 ef 11 00 00       	call   807f9a <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806dab:	39 c3                	cmp    %eax,%ebx
  806dad:	74 16                	je     806dc5 <ip_input+0x2a5>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  806daf:	8b 45 08             	mov    0x8(%ebp),%eax
  806db2:	89 70 04             	mov    %esi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806db5:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  806dbc:	00 
  806dbd:	89 04 24             	mov    %eax,(%esp)
  806dc0:	e8 f0 7f 00 00       	call   80edb5 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  806dc5:	8b 45 08             	mov    0x8(%ebp),%eax
  806dc8:	89 04 24             	mov    %eax,(%esp)
  806dcb:	e8 04 e0 ff ff       	call   804dd4 <pbuf_free>
  806dd0:	eb 1f                	jmp    806df1 <ip_input+0x2d1>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806dd2:	8b 45 0c             	mov    0xc(%ebp),%eax
  806dd5:	89 44 24 04          	mov    %eax,0x4(%esp)
  806dd9:	8d 46 0c             	lea    0xc(%esi),%eax
  806ddc:	89 04 24             	mov    %eax,(%esp)
  806ddf:	e8 8d fc ff ff       	call   806a71 <ip_addr_isbroadcast>
  806de4:	84 c0                	test   %al,%al
  806de6:	0f 84 97 fe ff ff    	je     806c83 <ip_input+0x163>
  806dec:	e9 b3 fe ff ff       	jmp    806ca4 <ip_input+0x184>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  806df1:	b8 00 00 00 00       	mov    $0x0,%eax
  806df6:	83 c4 2c             	add    $0x2c,%esp
  806df9:	5b                   	pop    %ebx
  806dfa:	5e                   	pop    %esi
  806dfb:	5f                   	pop    %edi
  806dfc:	5d                   	pop    %ebp
  806dfd:	c3                   	ret    

00806dfe <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806dfe:	55                   	push   %ebp
  806dff:	89 e5                	mov    %esp,%ebp
  806e01:	57                   	push   %edi
  806e02:	56                   	push   %esi
  806e03:	53                   	push   %ebx
  806e04:	83 ec 2c             	sub    $0x2c,%esp
  806e07:	8b 75 08             	mov    0x8(%ebp),%esi
  806e0a:	8b 7d 14             	mov    0x14(%ebp),%edi
  806e0d:	8b 45 18             	mov    0x18(%ebp),%eax
  806e10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806e13:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806e16:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806e19:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806e1d:	0f 84 17 01 00 00    	je     806f3a <ip_output_if+0x13c>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806e23:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806e2a:	00 
  806e2b:	89 34 24             	mov    %esi,(%esp)
  806e2e:	e8 bd de ff ff       	call   804cf0 <pbuf_header>
  806e33:	84 c0                	test   %al,%al
  806e35:	0f 85 48 01 00 00    	jne    806f83 <ip_output_if+0x185>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806e3b:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806e3e:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806e43:	77 1c                	ja     806e61 <ip_output_if+0x63>
  806e45:	c7 44 24 08 44 30 81 	movl   $0x813044,0x8(%esp)
  806e4c:	00 
  806e4d:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  806e54:	00 
  806e55:	c7 04 24 71 30 81 00 	movl   $0x813071,(%esp)
  806e5c:	e8 d9 81 00 00       	call   80f03a <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806e61:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806e65:	89 04 24             	mov    %eax,(%esp)
  806e68:	e8 e6 0e 00 00       	call   807d53 <ntohs>
  806e6d:	0f b6 c0             	movzbl %al,%eax
  806e70:	c1 e7 08             	shl    $0x8,%edi
  806e73:	09 c7                	or     %eax,%edi
  806e75:	0f b7 ff             	movzwl %di,%edi
  806e78:	89 3c 24             	mov    %edi,(%esp)
  806e7b:	e8 c6 0e 00 00       	call   807d46 <htons>
  806e80:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806e84:	0f b7 c0             	movzwl %ax,%eax
  806e87:	89 04 24             	mov    %eax,(%esp)
  806e8a:	e8 c4 0e 00 00       	call   807d53 <ntohs>
  806e8f:	25 00 ff 00 00       	and    $0xff00,%eax
  806e94:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  806e98:	09 d0                	or     %edx,%eax
  806e9a:	0f b7 c0             	movzwl %ax,%eax
  806e9d:	89 04 24             	mov    %eax,(%esp)
  806ea0:	e8 a1 0e 00 00       	call   807d46 <htons>
  806ea5:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806ea9:	8b 45 10             	mov    0x10(%ebp),%eax
  806eac:	8b 00                	mov    (%eax),%eax
  806eae:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806eb1:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806eb5:	80 cc 45             	or     $0x45,%ah
  806eb8:	89 04 24             	mov    %eax,(%esp)
  806ebb:	e8 86 0e 00 00       	call   807d46 <htons>
  806ec0:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806ec3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806ec7:	89 04 24             	mov    %eax,(%esp)
  806eca:	e8 77 0e 00 00       	call   807d46 <htons>
  806ecf:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806ed3:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806ed9:	0f b7 05 1a 54 b3 00 	movzwl 0xb3541a,%eax
  806ee0:	89 04 24             	mov    %eax,(%esp)
  806ee3:	e8 5e 0e 00 00       	call   807d46 <htons>
  806ee8:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806eec:	66 83 05 1a 54 b3 00 	addw   $0x1,0xb3541a
  806ef3:	01 

    if (ip_addr_isany(src)) {
  806ef4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806ef8:	74 09                	je     806f03 <ip_output_if+0x105>
  806efa:	8b 45 0c             	mov    0xc(%ebp),%eax
  806efd:	8b 00                	mov    (%eax),%eax
  806eff:	85 c0                	test   %eax,%eax
  806f01:	75 18                	jne    806f1b <ip_output_if+0x11d>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806f03:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806f07:	74 08                	je     806f11 <ip_output_if+0x113>
  806f09:	8b 45 20             	mov    0x20(%ebp),%eax
  806f0c:	8b 40 04             	mov    0x4(%eax),%eax
  806f0f:	eb 05                	jmp    806f16 <ip_output_if+0x118>
  806f11:	b8 00 00 00 00       	mov    $0x0,%eax
  806f16:	89 43 0c             	mov    %eax,0xc(%ebx)
  806f19:	eb 03                	jmp    806f1e <ip_output_if+0x120>
    } else {
      ip_addr_set(&(iphdr->src), src);
  806f1b:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806f1e:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806f24:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806f2b:	00 
  806f2c:	89 1c 24             	mov    %ebx,(%esp)
  806f2f:	e8 c4 0c 00 00       	call   807bf8 <inet_chksum>
  806f34:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806f38:	eb 09                	jmp    806f43 <ip_output_if+0x145>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  806f3a:	8b 46 04             	mov    0x4(%esi),%eax
  806f3d:	83 c0 10             	add    $0x10,%eax
  806f40:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806f43:	8b 45 20             	mov    0x20(%ebp),%eax
  806f46:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806f4a:	66 85 c0             	test   %ax,%ax
  806f4d:	74 1e                	je     806f6d <ip_output_if+0x16f>
  806f4f:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806f53:	73 18                	jae    806f6d <ip_output_if+0x16f>
    return ip_frag(p,netif,dest);
  806f55:	8b 45 10             	mov    0x10(%ebp),%eax
  806f58:	89 44 24 08          	mov    %eax,0x8(%esp)
  806f5c:	8b 45 20             	mov    0x20(%ebp),%eax
  806f5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  806f63:	89 34 24             	mov    %esi,(%esp)
  806f66:	e8 07 08 00 00       	call   807772 <ip_frag>
  806f6b:	eb 1b                	jmp    806f88 <ip_output_if+0x18a>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806f6d:	8b 45 10             	mov    0x10(%ebp),%eax
  806f70:	89 44 24 08          	mov    %eax,0x8(%esp)
  806f74:	89 74 24 04          	mov    %esi,0x4(%esp)
  806f78:	8b 45 20             	mov    0x20(%ebp),%eax
  806f7b:	89 04 24             	mov    %eax,(%esp)
  806f7e:	ff 50 14             	call   *0x14(%eax)
  806f81:	eb 05                	jmp    806f88 <ip_output_if+0x18a>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  806f83:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  806f88:	83 c4 2c             	add    $0x2c,%esp
  806f8b:	5b                   	pop    %ebx
  806f8c:	5e                   	pop    %esi
  806f8d:	5f                   	pop    %edi
  806f8e:	5d                   	pop    %ebp
  806f8f:	c3                   	ret    

00806f90 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806f90:	55                   	push   %ebp
  806f91:	89 e5                	mov    %esp,%ebp
  806f93:	57                   	push   %edi
  806f94:	56                   	push   %esi
  806f95:	53                   	push   %ebx
  806f96:	83 ec 2c             	sub    $0x2c,%esp
  806f99:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806f9c:	8b 75 18             	mov    0x18(%ebp),%esi
  806f9f:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806fa2:	8b 45 10             	mov    0x10(%ebp),%eax
  806fa5:	89 04 24             	mov    %eax,(%esp)
  806fa8:	e8 13 fb ff ff       	call   806ac0 <ip_route>
  806fad:	85 c0                	test   %eax,%eax
  806faf:	74 38                	je     806fe9 <ip_output+0x59>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806fb1:	89 44 24 18          	mov    %eax,0x18(%esp)
  806fb5:	89 f8                	mov    %edi,%eax
  806fb7:	0f b6 f8             	movzbl %al,%edi
  806fba:	89 7c 24 14          	mov    %edi,0x14(%esp)
  806fbe:	89 f0                	mov    %esi,%eax
  806fc0:	0f b6 f0             	movzbl %al,%esi
  806fc3:	89 74 24 10          	mov    %esi,0x10(%esp)
  806fc7:	0f b6 db             	movzbl %bl,%ebx
  806fca:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  806fce:	8b 45 10             	mov    0x10(%ebp),%eax
  806fd1:	89 44 24 08          	mov    %eax,0x8(%esp)
  806fd5:	8b 45 0c             	mov    0xc(%ebp),%eax
  806fd8:	89 44 24 04          	mov    %eax,0x4(%esp)
  806fdc:	8b 45 08             	mov    0x8(%ebp),%eax
  806fdf:	89 04 24             	mov    %eax,(%esp)
  806fe2:	e8 17 fe ff ff       	call   806dfe <ip_output_if>
  806fe7:	eb 05                	jmp    806fee <ip_output+0x5e>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  806fe9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  806fee:	83 c4 2c             	add    $0x2c,%esp
  806ff1:	5b                   	pop    %ebx
  806ff2:	5e                   	pop    %esi
  806ff3:	5f                   	pop    %edi
  806ff4:	5d                   	pop    %ebp
  806ff5:	c3                   	ret    
  806ff6:	66 90                	xchg   %ax,%ax
  806ff8:	66 90                	xchg   %ax,%ax
  806ffa:	66 90                	xchg   %ax,%ax
  806ffc:	66 90                	xchg   %ax,%ax
  806ffe:	66 90                	xchg   %ax,%ax

00807000 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  807000:	55                   	push   %ebp
  807001:	89 e5                	mov    %esp,%ebp
  807003:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  807006:	8b 0d 00 5a b3 00    	mov    0xb35a00,%ecx
  80700c:	39 c1                	cmp    %eax,%ecx
  80700e:	75 0a                	jne    80701a <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  807010:	8b 11                	mov    (%ecx),%edx
  807012:	89 15 00 5a b3 00    	mov    %edx,0xb35a00
  807018:	eb 24                	jmp    80703e <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  80701a:	85 d2                	test   %edx,%edx
  80701c:	75 1c                	jne    80703a <ip_reass_dequeue_datagram+0x3a>
  80701e:	c7 44 24 08 89 30 81 	movl   $0x813089,0x8(%esp)
  807025:	00 
  807026:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  80702d:	00 
  80702e:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  807035:	e8 00 80 00 00       	call   80f03a <_panic>
    prev->next = ipr->next;
  80703a:	8b 08                	mov    (%eax),%ecx
  80703c:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  80703e:	89 44 24 04          	mov    %eax,0x4(%esp)
  807042:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807049:	e8 d4 d9 ff ff       	call   804a22 <memp_free>
}
  80704e:	c9                   	leave  
  80704f:	c3                   	ret    

00807050 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  807050:	55                   	push   %ebp
  807051:	89 e5                	mov    %esp,%ebp
  807053:	57                   	push   %edi
  807054:	56                   	push   %esi
  807055:	53                   	push   %ebx
  807056:	83 ec 2c             	sub    $0x2c,%esp
  807059:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80705c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  80705f:	39 c2                	cmp    %eax,%edx
  807061:	75 1c                	jne    80707f <ip_reass_free_complete_datagram+0x2f>
  807063:	c7 44 24 08 bf 30 81 	movl   $0x8130bf,0x8(%esp)
  80706a:	00 
  80706b:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  807072:	00 
  807073:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  80707a:	e8 bb 7f 00 00       	call   80f03a <_panic>
  if (prev != NULL) {
  80707f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807082:	85 c0                	test   %eax,%eax
  807084:	74 23                	je     8070a9 <ip_reass_free_complete_datagram+0x59>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  807086:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807089:	39 08                	cmp    %ecx,(%eax)
  80708b:	74 1c                	je     8070a9 <ip_reass_free_complete_datagram+0x59>
  80708d:	c7 44 24 08 cb 30 81 	movl   $0x8130cb,0x8(%esp)
  807094:	00 
  807095:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  80709c:	00 
  80709d:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  8070a4:	e8 91 7f 00 00       	call   80f03a <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  8070a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8070ac:	8b 58 04             	mov    0x4(%eax),%ebx
  8070af:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  8070b2:	be 00 00 00 00       	mov    $0x0,%esi
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
  8070b7:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  8070bc:	75 45                	jne    807103 <ip_reass_free_complete_datagram+0xb3>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  8070be:	8b 00                	mov    (%eax),%eax
  8070c0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8070c3:	89 41 04             	mov    %eax,0x4(%ecx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  8070c6:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8070cd:	00 
  8070ce:	8d 41 08             	lea    0x8(%ecx),%eax
  8070d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8070d5:	8b 43 04             	mov    0x4(%ebx),%eax
  8070d8:	89 04 24             	mov    %eax,(%esp)
  8070db:	e8 cc 88 00 00       	call   80f9ac <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  8070e0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8070e7:	00 
  8070e8:	89 1c 24             	mov    %ebx,(%esp)
  8070eb:	e8 d7 7d 00 00       	call   80eec7 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  8070f0:	89 1c 24             	mov    %ebx,(%esp)
  8070f3:	e8 72 e1 ff ff       	call   80526a <pbuf_clen>
  8070f8:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  8070fb:	89 1c 24             	mov    %ebx,(%esp)
  8070fe:	e8 d1 dc ff ff       	call   804dd4 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  807103:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807106:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  807109:	eb 1c                	jmp    807127 <ip_reass_free_complete_datagram+0xd7>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  80710b:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  80710e:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  807110:	89 1c 24             	mov    %ebx,(%esp)
  807113:	e8 52 e1 ff ff       	call   80526a <pbuf_clen>
  807118:	0f b6 c0             	movzbl %al,%eax
  80711b:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  80711d:	89 1c 24             	mov    %ebx,(%esp)
  807120:	e8 af dc ff ff       	call   804dd4 <pbuf_free>
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  807125:	89 fb                	mov    %edi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  807127:	85 db                	test   %ebx,%ebx
  807129:	75 e0                	jne    80710b <ip_reass_free_complete_datagram+0xbb>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  80712b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80712e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807131:	e8 ca fe ff ff       	call   807000 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  807136:	0f b7 05 fc 59 b3 00 	movzwl 0xb359fc,%eax
  80713d:	0f b7 d0             	movzwl %ax,%edx
  807140:	39 f2                	cmp    %esi,%edx
  807142:	7d 1c                	jge    807160 <ip_reass_free_complete_datagram+0x110>
  807144:	c7 44 24 08 dd 30 81 	movl   $0x8130dd,0x8(%esp)
  80714b:	00 
  80714c:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  807153:	00 
  807154:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  80715b:	e8 da 7e 00 00       	call   80f03a <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  807160:	29 f0                	sub    %esi,%eax
  807162:	66 a3 fc 59 b3 00    	mov    %ax,0xb359fc

  return pbufs_freed;
}
  807168:	89 f0                	mov    %esi,%eax
  80716a:	83 c4 2c             	add    $0x2c,%esp
  80716d:	5b                   	pop    %ebx
  80716e:	5e                   	pop    %esi
  80716f:	5f                   	pop    %edi
  807170:	5d                   	pop    %ebp
  807171:	c3                   	ret    

00807172 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  807172:	55                   	push   %ebp
  807173:	89 e5                	mov    %esp,%ebp
  807175:	57                   	push   %edi
  807176:	56                   	push   %esi
  807177:	53                   	push   %ebx
  807178:	83 ec 1c             	sub    $0x1c,%esp
  80717b:	89 c6                	mov    %eax,%esi
  80717d:	89 55 dc             	mov    %edx,-0x24(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  807180:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  807187:	8b 0d 00 5a b3 00    	mov    0xb35a00,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  80718d:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  807192:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  807197:	b8 00 00 00 00       	mov    $0x0,%eax
  80719c:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  80719f:	eb 39                	jmp    8071da <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  8071a1:	8b 5e 0c             	mov    0xc(%esi),%ebx
  8071a4:	39 59 14             	cmp    %ebx,0x14(%ecx)
  8071a7:	75 12                	jne    8071bb <ip_reass_remove_oldest_datagram+0x49>
  8071a9:	8b 7e 10             	mov    0x10(%esi),%edi
  8071ac:	39 79 18             	cmp    %edi,0x18(%ecx)
  8071af:	75 0a                	jne    8071bb <ip_reass_remove_oldest_datagram+0x49>
  8071b1:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  8071b5:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  8071b9:	74 16                	je     8071d1 <ip_reass_remove_oldest_datagram+0x5f>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  8071bb:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  8071bf:	85 c0                	test   %eax,%eax
  8071c1:	74 0c                	je     8071cf <ip_reass_remove_oldest_datagram+0x5d>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  8071c3:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  8071c7:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  8071ca:	0f 46 c1             	cmovbe %ecx,%eax
  8071cd:	eb 02                	jmp    8071d1 <ip_reass_remove_oldest_datagram+0x5f>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  8071cf:	89 c8                	mov    %ecx,%eax
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  8071d1:	8b 39                	mov    (%ecx),%edi
  8071d3:	85 ff                	test   %edi,%edi
  8071d5:	0f 45 d1             	cmovne %ecx,%edx
  8071d8:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8071da:	85 c9                	test   %ecx,%ecx
  8071dc:	75 c3                	jne    8071a1 <ip_reass_remove_oldest_datagram+0x2f>
  8071de:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  8071e1:	85 c0                	test   %eax,%eax
  8071e3:	74 08                	je     8071ed <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  8071e5:	e8 66 fe ff ff       	call   807050 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  8071ea:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  8071ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8071f0:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  8071f3:	7d 05                	jge    8071fa <ip_reass_remove_oldest_datagram+0x88>
  8071f5:	83 fb 01             	cmp    $0x1,%ebx
  8071f8:	7f 8d                	jg     807187 <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  8071fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8071fd:	83 c4 1c             	add    $0x1c,%esp
  807200:	5b                   	pop    %ebx
  807201:	5e                   	pop    %esi
  807202:	5f                   	pop    %edi
  807203:	5d                   	pop    %ebp
  807204:	c3                   	ret    

00807205 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  807205:	55                   	push   %ebp
  807206:	89 e5                	mov    %esp,%ebp
  807208:	56                   	push   %esi
  807209:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  80720a:	a1 00 5a b3 00       	mov    0xb35a00,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  80720f:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  807214:	eb 1f                	jmp    807235 <ip_reass_tmr+0x30>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  807216:	0f b6 48 1f          	movzbl 0x1f(%eax),%ecx
  80721a:	84 c9                	test   %cl,%cl
  80721c:	74 0c                	je     80722a <ip_reass_tmr+0x25>
      r->timer--;
  80721e:	83 e9 01             	sub    $0x1,%ecx
  807221:	88 48 1f             	mov    %cl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  807224:	89 c3                	mov    %eax,%ebx
      r = r->next;
  807226:	8b 00                	mov    (%eax),%eax
  807228:	eb 0b                	jmp    807235 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80722a:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  80722c:	89 da                	mov    %ebx,%edx
  80722e:	e8 1d fe ff ff       	call   807050 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  807233:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  807235:	85 c0                	test   %eax,%eax
  807237:	75 dd                	jne    807216 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  807239:	5b                   	pop    %ebx
  80723a:	5e                   	pop    %esi
  80723b:	5d                   	pop    %ebp
  80723c:	c3                   	ret    

0080723d <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  80723d:	55                   	push   %ebp
  80723e:	89 e5                	mov    %esp,%ebp
  807240:	57                   	push   %edi
  807241:	56                   	push   %esi
  807242:	53                   	push   %ebx
  807243:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  807246:	8b 45 08             	mov    0x8(%ebp),%eax
  807249:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  80724c:	0f b7 03             	movzwl (%ebx),%eax
  80724f:	89 04 24             	mov    %eax,(%esp)
  807252:	e8 fc 0a 00 00       	call   807d53 <ntohs>
  807257:	66 c1 e8 08          	shr    $0x8,%ax
  80725b:	83 e0 0f             	and    $0xf,%eax
  80725e:	83 f8 05             	cmp    $0x5,%eax
  807261:	0f 85 14 04 00 00    	jne    80767b <ip_reass+0x43e>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  807267:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80726b:	89 04 24             	mov    %eax,(%esp)
  80726e:	e8 e0 0a 00 00       	call   807d53 <ntohs>
  807273:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  807277:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80727b:	89 04 24             	mov    %eax,(%esp)
  80727e:	e8 d0 0a 00 00       	call   807d53 <ntohs>
  807283:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  807287:	0f b7 03             	movzwl (%ebx),%eax
  80728a:	89 04 24             	mov    %eax,(%esp)
  80728d:	e8 c1 0a 00 00       	call   807d53 <ntohs>
  807292:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  807296:	8b 45 08             	mov    0x8(%ebp),%eax
  807299:	89 04 24             	mov    %eax,(%esp)
  80729c:	e8 c9 df ff ff       	call   80526a <pbuf_clen>
  8072a1:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  8072a4:	0f b6 f0             	movzbl %al,%esi
  8072a7:	0f b7 05 fc 59 b3 00 	movzwl 0xb359fc,%eax
  8072ae:	01 f0                	add    %esi,%eax
  8072b0:	83 f8 0a             	cmp    $0xa,%eax
  8072b3:	7e 23                	jle    8072d8 <ip_reass+0x9b>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8072b5:	89 f2                	mov    %esi,%edx
  8072b7:	89 d8                	mov    %ebx,%eax
  8072b9:	e8 b4 fe ff ff       	call   807172 <ip_reass_remove_oldest_datagram>
  8072be:	85 c0                	test   %eax,%eax
  8072c0:	0f 84 b5 03 00 00    	je     80767b <ip_reass+0x43e>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  8072c6:	0f b7 05 fc 59 b3 00 	movzwl 0xb359fc,%eax
  8072cd:	01 f0                	add    %esi,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8072cf:	83 f8 0a             	cmp    $0xa,%eax
  8072d2:	0f 8f a3 03 00 00    	jg     80767b <ip_reass+0x43e>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8072d8:	8b 3d 00 5a b3 00    	mov    0xb35a00,%edi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  8072de:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8072e3:	eb 1e                	jmp    807303 <ip_reass+0xc6>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  8072e5:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  8072e8:	39 4f 14             	cmp    %ecx,0x14(%edi)
  8072eb:	75 12                	jne    8072ff <ip_reass+0xc2>
  8072ed:	8b 53 10             	mov    0x10(%ebx),%edx
  8072f0:	39 57 18             	cmp    %edx,0x18(%edi)
  8072f3:	75 0a                	jne    8072ff <ip_reass+0xc2>
  8072f5:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  8072f9:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  8072fd:	74 4d                	je     80734c <ip_reass+0x10f>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8072ff:	89 f8                	mov    %edi,%eax
  807301:	8b 3f                	mov    (%edi),%edi
  807303:	85 ff                	test   %edi,%edi
  807305:	75 de                	jne    8072e5 <ip_reass+0xa8>
  807307:	89 45 e0             	mov    %eax,-0x20(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  80730a:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807311:	e8 ac d6 ff ff       	call   8049c2 <memp_malloc>
  807316:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  807318:	85 c0                	test   %eax,%eax
  80731a:	0f 85 05 04 00 00    	jne    807725 <ip_reass+0x4e8>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  807320:	89 f2                	mov    %esi,%edx
  807322:	89 d8                	mov    %ebx,%eax
  807324:	e8 49 fe ff ff       	call   807172 <ip_reass_remove_oldest_datagram>
  807329:	39 c6                	cmp    %eax,%esi
  80732b:	0f 8f 4a 03 00 00    	jg     80767b <ip_reass+0x43e>
      ipr = memp_malloc(MEMP_REASSDATA);
  807331:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807338:	e8 85 d6 ff ff       	call   8049c2 <memp_malloc>
  80733d:	89 c7                	mov    %eax,%edi
    }
    if (ipr == NULL)
  80733f:	85 c0                	test   %eax,%eax
  807341:	0f 85 de 03 00 00    	jne    807725 <ip_reass+0x4e8>
  807347:	e9 2f 03 00 00       	jmp    80767b <ip_reass+0x43e>
  80734c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80734f:	89 fe                	mov    %edi,%esi
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  807351:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807355:	89 04 24             	mov    %eax,(%esp)
  807358:	e8 f6 09 00 00       	call   807d53 <ntohs>
  80735d:	66 a9 ff 1f          	test   $0x1fff,%ax
  807361:	75 29                	jne    80738c <ip_reass+0x14f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  807363:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  807367:	89 04 24             	mov    %eax,(%esp)
  80736a:	e8 e4 09 00 00       	call   807d53 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80736f:	66 a9 ff 1f          	test   $0x1fff,%ax
  807373:	74 17                	je     80738c <ip_reass+0x14f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  807375:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80737c:	00 
  80737d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  807381:	83 c6 08             	add    $0x8,%esi
  807384:	89 34 24             	mov    %esi,(%esp)
  807387:	e8 20 86 00 00       	call   80f9ac <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  80738c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807390:	66 01 05 fc 59 b3 00 	add    %ax,0xb359fc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  807397:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80739b:	89 04 24             	mov    %eax,(%esp)
  80739e:	e8 b0 09 00 00       	call   807d53 <ntohs>
  8073a3:	f6 c4 20             	test   $0x20,%ah
  8073a6:	75 20                	jne    8073c8 <ip_reass+0x18b>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  8073a8:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8073ac:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  8073b0:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  8073b4:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  8073b7:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  8073bb:	66 c1 ea 06          	shr    $0x6,%dx
  8073bf:	83 e2 3c             	and    $0x3c,%edx
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
  8073c2:	29 d0                	sub    %edx,%eax
  8073c4:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  8073c8:	8b 45 08             	mov    0x8(%ebp),%eax
  8073cb:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8073ce:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  8073d2:	89 04 24             	mov    %eax,(%esp)
  8073d5:	e8 79 09 00 00       	call   807d53 <ntohs>
  8073da:	89 c6                	mov    %eax,%esi
  8073dc:	0f b7 03             	movzwl (%ebx),%eax
  8073df:	89 04 24             	mov    %eax,(%esp)
  8073e2:	e8 6c 09 00 00       	call   807d53 <ntohs>
  8073e7:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  8073eb:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8073ef:	89 04 24             	mov    %eax,(%esp)
  8073f2:	e8 5c 09 00 00       	call   807d53 <ntohs>
  8073f7:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  8073fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807401:	8b 51 04             	mov    0x4(%ecx),%edx
  807404:	89 55 dc             	mov    %edx,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  807407:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  80740d:	66 89 5a 04          	mov    %bx,0x4(%edx)
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  807411:	01 de                	add    %ebx,%esi
  807413:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807417:	66 c1 e8 06          	shr    $0x6,%ax
  80741b:	83 e0 3c             	and    $0x3c,%eax
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
  80741e:	29 c6                	sub    %eax,%esi
  807420:	66 89 75 da          	mov    %si,-0x26(%ebp)
  807424:	66 89 72 06          	mov    %si,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  807428:	8b 47 04             	mov    0x4(%edi),%eax
  80742b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  80742e:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  807433:	be 00 00 00 00       	mov    $0x0,%esi
  807438:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80743b:	89 cf                	mov    %ecx,%edi
  80743d:	eb 6f                	jmp    8074ae <ip_reass+0x271>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80743f:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  807442:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  807446:	66 39 cb             	cmp    %cx,%bx
  807449:	73 3c                	jae    807487 <ip_reass+0x24a>
  80744b:	89 7d d0             	mov    %edi,-0x30(%ebp)
  80744e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  807451:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  807454:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  807456:	85 f6                	test   %esi,%esi
  807458:	74 22                	je     80747c <ip_reass+0x23f>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80745a:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  80745e:	0f 82 92 01 00 00    	jb     8075f6 <ip_reass+0x3b9>
  807464:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  807468:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80746c:	0f 87 84 01 00 00    	ja     8075f6 <ip_reass+0x3b9>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  807472:	8b 45 08             	mov    0x8(%ebp),%eax
  807475:	89 06                	mov    %eax,(%esi)
  807477:	e9 a0 00 00 00       	jmp    80751c <ip_reass+0x2df>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80747c:	8b 45 08             	mov    0x8(%ebp),%eax
  80747f:	89 47 04             	mov    %eax,0x4(%edi)
  807482:	e9 95 00 00 00       	jmp    80751c <ip_reass+0x2df>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  807487:	66 39 cb             	cmp    %cx,%bx
  80748a:	0f 84 66 01 00 00    	je     8075f6 <ip_reass+0x3b9>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  807490:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  807494:	0f 82 5c 01 00 00    	jb     8075f6 <ip_reass+0x3b9>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  80749a:	85 f6                	test   %esi,%esi
  80749c:	74 0c                	je     8074aa <ip_reass+0x26d>
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  80749e:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  8074a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8074a7:	0f 45 f8             	cmovne %eax,%edi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  8074aa:	8b 02                	mov    (%edx),%eax
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  8074ac:	89 d6                	mov    %edx,%esi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  8074ae:	85 c0                	test   %eax,%eax
  8074b0:	75 8d                	jne    80743f <ip_reass+0x202>
  8074b2:	e9 d9 01 00 00       	jmp    807690 <ip_reass+0x453>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8074b7:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  8074bb:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  8074be:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  8074c2:	76 1c                	jbe    8074e0 <ip_reass+0x2a3>
  8074c4:	c7 44 24 08 f8 30 81 	movl   $0x8130f8,0x8(%esp)
  8074cb:	00 
  8074cc:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  8074d3:	00 
  8074d4:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  8074db:	e8 5a 7b 00 00       	call   80f03a <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  8074e0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8074e3:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  8074e5:	8b 75 dc             	mov    -0x24(%ebp),%esi
  8074e8:	66 3b 46 04          	cmp    0x4(%esi),%ax
  8074ec:	0f 85 c3 01 00 00    	jne    8076b5 <ip_reass+0x478>
  8074f2:	eb 28                	jmp    80751c <ip_reass+0x2df>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  8074f4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  8074f8:	74 1c                	je     807516 <ip_reass+0x2d9>
  8074fa:	c7 44 24 08 24 31 81 	movl   $0x813124,0x8(%esp)
  807501:	00 
  807502:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  807509:	00 
  80750a:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  807511:	e8 24 7b 00 00       	call   80f03a <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  807516:	8b 45 08             	mov    0x8(%ebp),%eax
  807519:	89 47 04             	mov    %eax,0x4(%edi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80751c:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  807520:	0f 84 8f 01 00 00    	je     8076b5 <ip_reass+0x478>
    /* and had no wholes so far */
    if (valid) {
  807526:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80752a:	0f 84 85 01 00 00    	je     8076b5 <ip_reass+0x478>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  807530:	8b 4f 04             	mov    0x4(%edi),%ecx
  807533:	8b 59 04             	mov    0x4(%ecx),%ebx
  807536:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  80753b:	0f 85 74 01 00 00    	jne    8076b5 <ip_reass+0x478>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  807541:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807544:	8b 10                	mov    (%eax),%edx
  807546:	89 c6                	mov    %eax,%esi
  807548:	eb 15                	jmp    80755f <ip_reass+0x322>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80754a:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  80754d:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  807551:	66 39 56 06          	cmp    %dx,0x6(%esi)
  807555:	0f 85 5a 01 00 00    	jne    8076b5 <ip_reass+0x478>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80755b:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80755d:	89 c6                	mov    %eax,%esi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80755f:	85 d2                	test   %edx,%edx
  807561:	75 e7                	jne    80754a <ip_reass+0x30d>
  807563:	e9 3b 01 00 00       	jmp    8076a3 <ip_reass+0x466>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  807568:	c7 44 24 08 16 31 81 	movl   $0x813116,0x8(%esp)
  80756f:	00 
  807570:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  807577:	00 
  807578:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  80757f:	e8 b6 7a 00 00       	call   80f03a <_panic>
          LWIP_ASSERT("sanity check",
  807584:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  807587:	75 1c                	jne    8075a5 <ip_reass+0x368>
  807589:	c7 44 24 08 16 31 81 	movl   $0x813116,0x8(%esp)
  807590:	00 
  807591:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  807598:	00 
  807599:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  8075a0:	e8 95 7a 00 00       	call   80f03a <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8075a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8075a8:	83 38 00             	cmpl   $0x0,(%eax)
  8075ab:	74 1c                	je     8075c9 <ip_reass+0x38c>
  8075ad:	c7 44 24 08 5c 31 81 	movl   $0x81315c,0x8(%esp)
  8075b4:	00 
  8075b5:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  8075bc:	00 
  8075bd:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  8075c4:	e8 71 7a 00 00       	call   80f03a <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8075c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8075cc:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  8075d0:	66 3b 47 1c          	cmp    0x1c(%edi),%ax
  8075d4:	0f 84 e5 00 00 00    	je     8076bf <ip_reass+0x482>
  8075da:	c7 44 24 08 80 31 81 	movl   $0x813180,0x8(%esp)
  8075e1:	00 
  8075e2:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  8075e9:	00 
  8075ea:	c7 04 24 a2 30 81 00 	movl   $0x8130a2,(%esp)
  8075f1:	e8 44 7a 00 00       	call   80f03a <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  8075f6:	0f b7 1d fc 59 b3 00 	movzwl 0xb359fc,%ebx
  8075fd:	8b 45 08             	mov    0x8(%ebp),%eax
  807600:	89 04 24             	mov    %eax,(%esp)
  807603:	e8 62 dc ff ff       	call   80526a <pbuf_clen>
  807608:	0f b6 c0             	movzbl %al,%eax
  80760b:	29 c3                	sub    %eax,%ebx
  80760d:	66 89 1d fc 59 b3 00 	mov    %bx,0xb359fc
  pbuf_free(new_p);
  807614:	8b 45 08             	mov    0x8(%ebp),%eax
  807617:	89 04 24             	mov    %eax,(%esp)
  80761a:	e8 b5 d7 ff ff       	call   804dd4 <pbuf_free>
  80761f:	e9 91 00 00 00       	jmp    8076b5 <ip_reass+0x478>

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  807624:	8b 73 04             	mov    0x4(%ebx),%esi

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  807627:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80762e:	ff 
  80762f:	89 1c 24             	mov    %ebx,(%esp)
  807632:	e8 b9 d6 ff ff       	call   804cf0 <pbuf_header>
      pbuf_cat(p, r);
  807637:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80763b:	89 3c 24             	mov    %edi,(%esp)
  80763e:	e8 50 dc ff ff       	call   805293 <pbuf_cat>
      r = iprh->next_pbuf;
  807643:	8b 1e                	mov    (%esi),%ebx
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807645:	85 db                	test   %ebx,%ebx
  807647:	75 db                	jne    807624 <ip_reass+0x3e7>
  807649:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80764c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80764f:	89 f8                	mov    %edi,%eax
  807651:	e8 aa f9 ff ff       	call   807000 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  807656:	0f b7 1d fc 59 b3 00 	movzwl 0xb359fc,%ebx
  80765d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  807660:	89 34 24             	mov    %esi,(%esp)
  807663:	e8 02 dc ff ff       	call   80526a <pbuf_clen>
  807668:	0f b6 c0             	movzbl %al,%eax
  80766b:	29 c3                	sub    %eax,%ebx
  80766d:	66 89 1d fc 59 b3 00 	mov    %bx,0xb359fc

    /* Return the pbuf chain */
    return p;
  807674:	89 f0                	mov    %esi,%eax
  807676:	e9 ef 00 00 00       	jmp    80776a <ip_reass+0x52d>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80767b:	8b 45 08             	mov    0x8(%ebp),%eax
  80767e:	89 04 24             	mov    %eax,(%esp)
  807681:	e8 4e d7 ff ff       	call   804dd4 <pbuf_free>
  return NULL;
  807686:	b8 00 00 00 00       	mov    $0x0,%eax
  80768b:	e9 da 00 00 00       	jmp    80776a <ip_reass+0x52d>
  807690:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807693:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  807696:	85 f6                	test   %esi,%esi
  807698:	0f 85 19 fe ff ff    	jne    8074b7 <ip_reass+0x27a>
  80769e:	e9 51 fe ff ff       	jmp    8074f4 <ip_reass+0x2b7>
  8076a3:	89 75 dc             	mov    %esi,-0x24(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  8076a6:	85 c9                	test   %ecx,%ecx
  8076a8:	0f 85 d6 fe ff ff    	jne    807584 <ip_reass+0x347>
  8076ae:	66 90                	xchg   %ax,%ax
  8076b0:	e9 b3 fe ff ff       	jmp    807568 <ip_reass+0x32b>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  8076b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8076ba:	e9 ab 00 00 00       	jmp    80776a <ip_reass+0x52d>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  8076bf:	83 c0 14             	add    $0x14,%eax
  8076c2:	66 89 47 1c          	mov    %ax,0x1c(%edi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  8076c6:	8b 47 04             	mov    0x4(%edi),%eax
  8076c9:	8b 70 04             	mov    0x4(%eax),%esi
  8076cc:	8b 1e                	mov    (%esi),%ebx

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  8076ce:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8076d5:	00 
  8076d6:	8d 47 08             	lea    0x8(%edi),%eax
  8076d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8076dd:	89 34 24             	mov    %esi,(%esp)
  8076e0:	e8 c7 82 00 00       	call   80f9ac <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  8076e5:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8076e9:	89 04 24             	mov    %eax,(%esp)
  8076ec:	e8 55 06 00 00       	call   807d46 <htons>
  8076f1:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  8076f5:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  8076fb:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807701:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  807708:	00 
  807709:	89 34 24             	mov    %esi,(%esp)
  80770c:	e8 e7 04 00 00       	call   807bf8 <inet_chksum>
  807711:	66 89 46 0a          	mov    %ax,0xa(%esi)

    p = ipr->p;
  807715:	8b 47 04             	mov    0x4(%edi),%eax
  807718:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80771b:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80771e:	89 c7                	mov    %eax,%edi

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807720:	e9 20 ff ff ff       	jmp    807645 <ip_reass+0x408>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  807725:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80772c:	00 
  80772d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807734:	00 
  807735:	89 3c 24             	mov    %edi,(%esp)
  807738:	e8 ba 81 00 00       	call   80f8f7 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80773d:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  807741:	a1 00 5a b3 00       	mov    0xb35a00,%eax
  807746:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  807748:	89 3d 00 5a b3 00    	mov    %edi,0xb35a00
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80774e:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807755:	00 
  807756:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80775a:	8d 47 08             	lea    0x8(%edi),%eax
  80775d:	89 04 24             	mov    %eax,(%esp)
  807760:	e8 47 82 00 00       	call   80f9ac <memcpy>
  807765:	e9 22 fc ff ff       	jmp    80738c <ip_reass+0x14f>
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  80776a:	83 c4 3c             	add    $0x3c,%esp
  80776d:	5b                   	pop    %ebx
  80776e:	5e                   	pop    %esi
  80776f:	5f                   	pop    %edi
  807770:	5d                   	pop    %ebp
  807771:	c3                   	ret    

00807772 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807772:	55                   	push   %ebp
  807773:	89 e5                	mov    %esp,%ebp
  807775:	57                   	push   %edi
  807776:	56                   	push   %esi
  807777:	53                   	push   %ebx
  807778:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  80777b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80777e:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807782:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  807789:	00 
  80778a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807791:	00 
  807792:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  807799:	e8 17 d7 ff ff       	call   804eb5 <pbuf_alloc>
  80779e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  8077a1:	89 c1                	mov    %eax,%ecx
  8077a3:	85 c0                	test   %eax,%eax
  8077a5:	0f 84 d2 01 00 00    	je     80797d <ip_frag+0x20b>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8077ab:	66 89 70 0a          	mov    %si,0xa(%eax)
  8077af:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8077b3:	b8 23 54 b3 00       	mov    $0xb35423,%eax
  8077b8:	83 e0 fc             	and    $0xfffffffc,%eax
  8077bb:	89 c3                	mov    %eax,%ebx
  8077bd:	89 59 04             	mov    %ebx,0x4(%ecx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8077c0:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8077c7:	00 
  8077c8:	8b 45 08             	mov    0x8(%ebp),%eax
  8077cb:	8b 40 04             	mov    0x4(%eax),%eax
  8077ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  8077d2:	89 1c 24             	mov    %ebx,(%esp)
  8077d5:	e8 d2 81 00 00       	call   80f9ac <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8077da:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8077de:	89 04 24             	mov    %eax,(%esp)
  8077e1:	e8 6d 05 00 00       	call   807d53 <ntohs>
  ofo = tmp & IP_OFFMASK;
  8077e6:	89 c1                	mov    %eax,%ecx
  8077e8:	66 81 e1 ff 1f       	and    $0x1fff,%cx
  8077ed:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  omf = tmp & IP_MF;
  8077f1:	66 25 00 20          	and    $0x2000,%ax
  8077f5:	66 89 45 da          	mov    %ax,-0x26(%ebp)

  left = p->tot_len - IP_HLEN;
  8077f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8077fc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807800:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  807804:	83 e8 14             	sub    $0x14,%eax
  807807:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)

  nfb = (mtu - IP_HLEN) / 8;
  80780b:	0f b7 d6             	movzwl %si,%edx
  80780e:	8d 42 f3             	lea    -0xd(%edx),%eax
  807811:	83 ea 14             	sub    $0x14,%edx
  807814:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  807817:	0f 49 c2             	cmovns %edx,%eax
  80781a:	c1 f8 03             	sar    $0x3,%eax
  80781d:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  807821:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807827:	c1 e0 03             	shl    $0x3,%eax
  80782a:	66 89 45 ce          	mov    %ax,-0x32(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80782e:	8d 43 14             	lea    0x14(%ebx),%eax
  807831:	89 45 d0             	mov    %eax,-0x30(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807834:	e9 27 01 00 00       	jmp    807960 <ip_frag+0x1ee>
    last = (left <= mtu - IP_HLEN);
  807839:	0f b7 4d e4          	movzwl -0x1c(%ebp),%ecx
  80783d:	0f b7 c1             	movzwl %cx,%eax
  807840:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  807843:	0f 9d c0             	setge  %al
  807846:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807849:	0f b7 7d e0          	movzwl -0x20(%ebp),%edi
  80784d:	66 81 e7 ff 1f       	and    $0x1fff,%di
  807852:	66 0b 7d da          	or     -0x26(%ebp),%di
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807856:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
  80785a:	66 85 f6             	test   %si,%si
  80785d:	75 0d                	jne    80786c <ip_frag+0xfa>
      tmp = tmp | IP_MF;
  80785f:	66 81 cf 00 20       	or     $0x2000,%di

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807864:	0f b7 45 ce          	movzwl -0x32(%ebp),%eax
  807868:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80786c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807870:	89 44 24 0c          	mov    %eax,0xc(%esp)
  807874:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807878:	89 44 24 08          	mov    %eax,0x8(%esp)
  80787c:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80787f:	89 54 24 04          	mov    %edx,0x4(%esp)
  807883:	8b 55 08             	mov    0x8(%ebp),%edx
  807886:	89 14 24             	mov    %edx,(%esp)
  807889:	e8 f1 dc ff ff       	call   80557f <pbuf_copy_partial>
  80788e:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807892:	0f b7 ff             	movzwl %di,%edi
  807895:	89 3c 24             	mov    %edi,(%esp)
  807898:	e8 a9 04 00 00       	call   807d46 <htons>
  80789d:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8078a1:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8078a5:	83 c0 14             	add    $0x14,%eax
  8078a8:	0f b7 c0             	movzwl %ax,%eax
  8078ab:	89 04 24             	mov    %eax,(%esp)
  8078ae:	e8 93 04 00 00       	call   807d46 <htons>
  8078b3:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  8078b7:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8078bd:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8078c4:	00 
  8078c5:	89 1c 24             	mov    %ebx,(%esp)
  8078c8:	e8 2b 03 00 00       	call   807bf8 <inet_chksum>
  8078cd:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  8078d1:	66 85 f6             	test   %si,%si
  8078d4:	74 19                	je     8078ef <ip_frag+0x17d>
      pbuf_realloc(rambuf, left + IP_HLEN);
  8078d6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8078da:	83 c0 14             	add    $0x14,%eax
  8078dd:	0f b7 c0             	movzwl %ax,%eax
  8078e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8078e4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8078e7:	89 04 24             	mov    %eax,(%esp)
  8078ea:	e8 57 d8 ff ff       	call   805146 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8078ef:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8078f6:	00 
  8078f7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8078fe:	00 
  8078ff:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  807906:	e8 aa d5 ff ff       	call   804eb5 <pbuf_alloc>
  80790b:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  80790d:	85 c0                	test   %eax,%eax
  80790f:	74 3d                	je     80794e <ip_frag+0x1dc>
      pbuf_chain(header, rambuf);
  807911:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807914:	89 44 24 04          	mov    %eax,0x4(%esp)
  807918:	89 34 24             	mov    %esi,(%esp)
  80791b:	e8 ea d9 ff ff       	call   80530a <pbuf_chain>
      netif->output(netif, header, dest);
  807920:	8b 45 10             	mov    0x10(%ebp),%eax
  807923:	89 44 24 08          	mov    %eax,0x8(%esp)
  807927:	89 74 24 04          	mov    %esi,0x4(%esp)
  80792b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80792e:	89 04 24             	mov    %eax,(%esp)
  807931:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  807934:	89 34 24             	mov    %esi,(%esp)
  807937:	e8 98 d4 ff ff       	call   804dd4 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  80793c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807940:	66 29 45 e4          	sub    %ax,-0x1c(%ebp)
    ofo += nfb;
  807944:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807948:	66 01 45 e0          	add    %ax,-0x20(%ebp)
  80794c:	eb 12                	jmp    807960 <ip_frag+0x1ee>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80794e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807951:	89 04 24             	mov    %eax,(%esp)
  807954:	e8 7b d4 ff ff       	call   804dd4 <pbuf_free>
      return ERR_MEM;
  807959:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80795e:	eb 22                	jmp    807982 <ip_frag+0x210>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807960:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  807965:	0f 85 ce fe ff ff    	jne    807839 <ip_frag+0xc7>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  80796b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80796e:	89 04 24             	mov    %eax,(%esp)
  807971:	e8 5e d4 ff ff       	call   804dd4 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  807976:	b8 00 00 00 00       	mov    $0x0,%eax
  80797b:	eb 05                	jmp    807982 <ip_frag+0x210>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  80797d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  807982:	83 c4 3c             	add    $0x3c,%esp
  807985:	5b                   	pop    %ebx
  807986:	5e                   	pop    %esi
  807987:	5f                   	pop    %edi
  807988:	5d                   	pop    %ebp
  807989:	c3                   	ret    

0080798a <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80798a:	55                   	push   %ebp
  80798b:	89 e5                	mov    %esp,%ebp
  80798d:	57                   	push   %edi
  80798e:	56                   	push   %esi
  80798f:	53                   	push   %ebx
  807990:	83 ec 1c             	sub    $0x1c,%esp
  807993:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  807996:	89 d1                	mov    %edx,%ecx
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  807998:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80799d:	eb 17                	jmp    8079b6 <lwip_standard_chksum+0x2c>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80799f:	0f b6 30             	movzbl (%eax),%esi
  8079a2:	c1 e6 08             	shl    $0x8,%esi
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8079a5:	0f b6 78 01          	movzbl 0x1(%eax),%edi
  8079a9:	09 fe                	or     %edi,%esi
  8079ab:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  8079ae:	0f b7 f6             	movzwl %si,%esi
  8079b1:	01 f3                	add    %esi,%ebx
    len -= 2;
  8079b3:	83 e9 02             	sub    $0x2,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8079b6:	66 83 f9 01          	cmp    $0x1,%cx
  8079ba:	77 e3                	ja     80799f <lwip_standard_chksum+0x15>
  8079bc:	89 d0                	mov    %edx,%eax
  8079be:	25 fe ff 00 00       	and    $0xfffe,%eax
  8079c3:	03 45 e4             	add    -0x1c(%ebp),%eax
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  8079c6:	f6 c2 01             	test   $0x1,%dl
  8079c9:	74 0b                	je     8079d6 <lwip_standard_chksum+0x4c>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8079cb:	0f b6 00             	movzbl (%eax),%eax
  8079ce:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  8079d1:	0f b7 c0             	movzwl %ax,%eax
  8079d4:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8079d6:	89 d8                	mov    %ebx,%eax
  8079d8:	c1 e8 10             	shr    $0x10,%eax
  8079db:	0f b7 db             	movzwl %bx,%ebx
  8079de:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  8079e0:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  8079e6:	74 0a                	je     8079f2 <lwip_standard_chksum+0x68>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8079e8:	89 d8                	mov    %ebx,%eax
  8079ea:	c1 e8 10             	shr    $0x10,%eax
  8079ed:	0f b7 db             	movzwl %bx,%ebx
  8079f0:	01 c3                	add    %eax,%ebx
  8079f2:	0f b7 db             	movzwl %bx,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  8079f5:	89 1c 24             	mov    %ebx,(%esp)
  8079f8:	e8 49 03 00 00       	call   807d46 <htons>
}
  8079fd:	83 c4 1c             	add    $0x1c,%esp
  807a00:	5b                   	pop    %ebx
  807a01:	5e                   	pop    %esi
  807a02:	5f                   	pop    %edi
  807a03:	5d                   	pop    %ebp
  807a04:	c3                   	ret    

00807a05 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807a05:	55                   	push   %ebp
  807a06:	89 e5                	mov    %esp,%ebp
  807a08:	57                   	push   %edi
  807a09:	56                   	push   %esi
  807a0a:	53                   	push   %ebx
  807a0b:	83 ec 1c             	sub    $0x1c,%esp
  807a0e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807a11:	8b 45 14             	mov    0x14(%ebp),%eax
  807a14:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807a17:	8b 45 18             	mov    0x18(%ebp),%eax
  807a1a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807a1d:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  807a22:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807a27:	eb 3d                	jmp    807a66 <inet_chksum_pseudo+0x61>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807a29:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807a2d:	8b 43 04             	mov    0x4(%ebx),%eax
  807a30:	e8 55 ff ff ff       	call   80798a <lwip_standard_chksum>
  807a35:	0f b7 c0             	movzwl %ax,%eax
  807a38:	01 c6                	add    %eax,%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807a3a:	89 f0                	mov    %esi,%eax
  807a3c:	c1 e8 10             	shr    $0x10,%eax
  807a3f:	0f b7 f6             	movzwl %si,%esi
  807a42:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807a44:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807a48:	74 1a                	je     807a64 <inet_chksum_pseudo+0x5f>
      swapped = 1 - swapped;
  807a4a:	b8 01 00 00 00       	mov    $0x1,%eax
  807a4f:	89 f9                	mov    %edi,%ecx
  807a51:	29 c8                	sub    %ecx,%eax
  807a53:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807a55:	89 f0                	mov    %esi,%eax
  807a57:	c1 e0 08             	shl    $0x8,%eax
  807a5a:	0f b7 c0             	movzwl %ax,%eax
  807a5d:	89 f1                	mov    %esi,%ecx
  807a5f:	0f b6 f5             	movzbl %ch,%esi
  807a62:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807a64:	8b 1b                	mov    (%ebx),%ebx
  807a66:	85 db                	test   %ebx,%ebx
  807a68:	75 bf                	jne    807a29 <inet_chksum_pseudo+0x24>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807a6a:	89 f8                	mov    %edi,%eax
  807a6c:	84 c0                	test   %al,%al
  807a6e:	74 0f                	je     807a7f <inet_chksum_pseudo+0x7a>
    acc = SWAP_BYTES_IN_WORD(acc);
  807a70:	89 f0                	mov    %esi,%eax
  807a72:	c1 e0 08             	shl    $0x8,%eax
  807a75:	0f b7 c0             	movzwl %ax,%eax
  807a78:	89 f1                	mov    %esi,%ecx
  807a7a:	0f b6 f5             	movzbl %ch,%esi
  807a7d:	09 c6                	or     %eax,%esi
  }
  acc += (src->addr & 0xffffUL);
  807a7f:	8b 45 0c             	mov    0xc(%ebp),%eax
  807a82:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807a84:	8b 45 10             	mov    0x10(%ebp),%eax
  807a87:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807a89:	89 d1                	mov    %edx,%ecx
  807a8b:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807a8e:	0f b7 d2             	movzwl %dx,%edx
  807a91:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807a93:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807a96:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  807a98:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807a9b:	01 d0                	add    %edx,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807a9d:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons((u16_t)proto);
  807a9f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807aa3:	89 04 24             	mov    %eax,(%esp)
  807aa6:	e8 9b 02 00 00       	call   807d46 <htons>
  807aab:	0f b7 c0             	movzwl %ax,%eax
  807aae:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  807ab0:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807ab4:	89 04 24             	mov    %eax,(%esp)
  807ab7:	e8 8a 02 00 00       	call   807d46 <htons>
  807abc:	0f b7 c0             	movzwl %ax,%eax
  807abf:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807ac1:	89 f2                	mov    %esi,%edx
  807ac3:	c1 ea 10             	shr    $0x10,%edx
  807ac6:	0f b7 c6             	movzwl %si,%eax
  807ac9:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  807acb:	89 c2                	mov    %eax,%edx
  807acd:	c1 ea 10             	shr    $0x10,%edx
  807ad0:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807ad2:	f7 d0                	not    %eax
}
  807ad4:	83 c4 1c             	add    $0x1c,%esp
  807ad7:	5b                   	pop    %ebx
  807ad8:	5e                   	pop    %esi
  807ad9:	5f                   	pop    %edi
  807ada:	5d                   	pop    %ebp
  807adb:	c3                   	ret    

00807adc <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807adc:	55                   	push   %ebp
  807add:	89 e5                	mov    %esp,%ebp
  807adf:	57                   	push   %edi
  807ae0:	56                   	push   %esi
  807ae1:	53                   	push   %ebx
  807ae2:	83 ec 2c             	sub    $0x2c,%esp
  807ae5:	8b 75 08             	mov    0x8(%ebp),%esi
  807ae8:	8b 45 14             	mov    0x14(%ebp),%eax
  807aeb:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807aee:	8b 45 18             	mov    0x18(%ebp),%eax
  807af1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807af4:	0f b7 5d 1c          	movzwl 0x1c(%ebp),%ebx
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  807af8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  807afc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807b03:	eb 73                	jmp    807b78 <inet_chksum_pseudo_partial+0x9c>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  807b05:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  807b09:	66 39 fb             	cmp    %di,%bx
  807b0c:	0f 46 fb             	cmovbe %ebx,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  807b0f:	0f b7 d7             	movzwl %di,%edx
  807b12:	8b 46 04             	mov    0x4(%esi),%eax
  807b15:	e8 70 fe ff ff       	call   80798a <lwip_standard_chksum>
  807b1a:	0f b7 c0             	movzwl %ax,%eax
  807b1d:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  807b20:	29 fb                	sub    %edi,%ebx
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807b22:	66 81 fb fe 7f       	cmp    $0x7ffe,%bx
  807b27:	76 1c                	jbe    807b45 <inet_chksum_pseudo_partial+0x69>
  807b29:	c7 44 24 08 ad 31 81 	movl   $0x8131ad,0x8(%esp)
  807b30:	00 
  807b31:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  807b38:	00 
  807b39:	c7 04 24 b8 31 81 00 	movl   $0x8131b8,(%esp)
  807b40:	e8 f5 74 00 00       	call   80f03a <_panic>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807b45:	89 c2                	mov    %eax,%edx
  807b47:	c1 ea 10             	shr    $0x10,%edx
  807b4a:	0f b7 c0             	movzwl %ax,%eax
  807b4d:	01 d0                	add    %edx,%eax
  807b4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  807b52:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807b56:	74 1e                	je     807b76 <inet_chksum_pseudo_partial+0x9a>
      swapped = 1 - swapped;
  807b58:	b8 01 00 00 00       	mov    $0x1,%eax
  807b5d:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807b60:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807b63:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807b66:	89 c8                	mov    %ecx,%eax
  807b68:	c1 e0 08             	shl    $0x8,%eax
  807b6b:	0f b7 c0             	movzwl %ax,%eax
  807b6e:	0f b6 d5             	movzbl %ch,%edx
  807b71:	09 c2                	or     %eax,%edx
  807b73:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807b76:	8b 36                	mov    (%esi),%esi
  807b78:	66 85 db             	test   %bx,%bx
  807b7b:	74 04                	je     807b81 <inet_chksum_pseudo_partial+0xa5>
  807b7d:	85 f6                	test   %esi,%esi
  807b7f:	75 84                	jne    807b05 <inet_chksum_pseudo_partial+0x29>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807b81:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  807b85:	74 13                	je     807b9a <inet_chksum_pseudo_partial+0xbe>
    acc = SWAP_BYTES_IN_WORD(acc);
  807b87:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807b8a:	89 c8                	mov    %ecx,%eax
  807b8c:	c1 e0 08             	shl    $0x8,%eax
  807b8f:	0f b7 c0             	movzwl %ax,%eax
  807b92:	0f b6 d5             	movzbl %ch,%edx
  807b95:	09 c2                	or     %eax,%edx
  807b97:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807b9a:	8b 45 0c             	mov    0xc(%ebp),%eax
  807b9d:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807b9f:	8b 45 10             	mov    0x10(%ebp),%eax
  807ba2:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807ba4:	89 d1                	mov    %edx,%ecx
  807ba6:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807ba9:	0f b7 f2             	movzwl %dx,%esi
  807bac:	01 ce                	add    %ecx,%esi
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807bae:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807bb1:	01 ce                	add    %ecx,%esi
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  807bb3:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807bb6:	01 c6                	add    %eax,%esi
  acc += ((dest->addr >> 16) & 0xffffUL);
  807bb8:	03 75 e4             	add    -0x1c(%ebp),%esi
  acc += (u32_t)htons((u16_t)proto);
  807bbb:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807bbf:	89 04 24             	mov    %eax,(%esp)
  807bc2:	e8 7f 01 00 00       	call   807d46 <htons>
  807bc7:	0f b7 d8             	movzwl %ax,%ebx
  807bca:	01 f3                	add    %esi,%ebx
  acc += (u32_t)htons(proto_len);
  807bcc:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807bd0:	89 04 24             	mov    %eax,(%esp)
  807bd3:	e8 6e 01 00 00       	call   807d46 <htons>
  807bd8:	0f b7 d0             	movzwl %ax,%edx
  807bdb:	01 da                	add    %ebx,%edx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807bdd:	89 d0                	mov    %edx,%eax
  807bdf:	c1 e8 10             	shr    $0x10,%eax
  807be2:	0f b7 d2             	movzwl %dx,%edx
  807be5:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  807be7:	89 c2                	mov    %eax,%edx
  807be9:	c1 ea 10             	shr    $0x10,%edx
  807bec:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807bee:	f7 d0                	not    %eax
}
  807bf0:	83 c4 2c             	add    $0x2c,%esp
  807bf3:	5b                   	pop    %ebx
  807bf4:	5e                   	pop    %esi
  807bf5:	5f                   	pop    %edi
  807bf6:	5d                   	pop    %ebp
  807bf7:	c3                   	ret    

00807bf8 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807bf8:	55                   	push   %ebp
  807bf9:	89 e5                	mov    %esp,%ebp
  807bfb:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807bfe:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807c02:	8b 45 08             	mov    0x8(%ebp),%eax
  807c05:	e8 80 fd ff ff       	call   80798a <lwip_standard_chksum>
  807c0a:	f7 d0                	not    %eax
}
  807c0c:	c9                   	leave  
  807c0d:	c3                   	ret    

00807c0e <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807c0e:	55                   	push   %ebp
  807c0f:	89 e5                	mov    %esp,%ebp
  807c11:	57                   	push   %edi
  807c12:	56                   	push   %esi
  807c13:	53                   	push   %ebx
  807c14:	83 ec 0c             	sub    $0xc,%esp
  807c17:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807c1a:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  807c1f:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807c24:	eb 3d                	jmp    807c63 <inet_chksum_pbuf+0x55>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807c26:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807c2a:	8b 43 04             	mov    0x4(%ebx),%eax
  807c2d:	e8 58 fd ff ff       	call   80798a <lwip_standard_chksum>
  807c32:	0f b7 c0             	movzwl %ax,%eax
  807c35:	01 c6                	add    %eax,%esi
    acc = FOLD_U32T(acc);
  807c37:	89 f0                	mov    %esi,%eax
  807c39:	c1 e8 10             	shr    $0x10,%eax
  807c3c:	0f b7 f6             	movzwl %si,%esi
  807c3f:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807c41:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807c45:	74 1a                	je     807c61 <inet_chksum_pbuf+0x53>
      swapped = 1 - swapped;
  807c47:	b8 01 00 00 00       	mov    $0x1,%eax
  807c4c:	89 f9                	mov    %edi,%ecx
  807c4e:	29 c8                	sub    %ecx,%eax
  807c50:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807c52:	89 f0                	mov    %esi,%eax
  807c54:	c1 e0 08             	shl    $0x8,%eax
  807c57:	0f b7 c0             	movzwl %ax,%eax
  807c5a:	89 f1                	mov    %esi,%ecx
  807c5c:	0f b6 f5             	movzbl %ch,%esi
  807c5f:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807c61:	8b 1b                	mov    (%ebx),%ebx
  807c63:	85 db                	test   %ebx,%ebx
  807c65:	75 bf                	jne    807c26 <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  807c67:	89 f8                	mov    %edi,%eax
  807c69:	84 c0                	test   %al,%al
  807c6b:	74 0f                	je     807c7c <inet_chksum_pbuf+0x6e>
    acc = SWAP_BYTES_IN_WORD(acc);
  807c6d:	89 f0                	mov    %esi,%eax
  807c6f:	c1 e0 08             	shl    $0x8,%eax
  807c72:	0f b7 c0             	movzwl %ax,%eax
  807c75:	89 f1                	mov    %esi,%ecx
  807c77:	0f b6 f5             	movzbl %ch,%esi
  807c7a:	09 c6                	or     %eax,%esi
  }
  return (u16_t)~(acc & 0xffffUL);
  807c7c:	89 f0                	mov    %esi,%eax
  807c7e:	f7 d0                	not    %eax
}
  807c80:	83 c4 0c             	add    $0xc,%esp
  807c83:	5b                   	pop    %ebx
  807c84:	5e                   	pop    %esi
  807c85:	5f                   	pop    %edi
  807c86:	5d                   	pop    %ebp
  807c87:	c3                   	ret    
  807c88:	66 90                	xchg   %ax,%ax
  807c8a:	66 90                	xchg   %ax,%ax
  807c8c:	66 90                	xchg   %ax,%ax
  807c8e:	66 90                	xchg   %ax,%ax

00807c90 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  807c90:	55                   	push   %ebp
  807c91:	89 e5                	mov    %esp,%ebp
  807c93:	57                   	push   %edi
  807c94:	56                   	push   %esi
  807c95:	53                   	push   %ebx
  807c96:	83 ec 19             	sub    $0x19,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807c99:	8b 45 08             	mov    0x8(%ebp),%eax
  807c9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807c9f:	c6 45 db 00          	movb   $0x0,-0x25(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  807ca3:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  807ca6:	c7 45 dc 04 5a b3 00 	movl   $0xb35a04,-0x24(%ebp)
 */
char *
inet_ntoa(struct in_addr addr)
{
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807cad:	be 00 00 00 00       	mov    $0x0,%esi
  807cb2:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  807cb5:	eb 02                	jmp    807cb9 <inet_ntoa+0x29>
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807cb7:	89 ce                	mov    %ecx,%esi
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807cb9:	8b 7d e0             	mov    -0x20(%ebp),%edi
  807cbc:	0f b6 17             	movzbl (%edi),%edx
      *ap /= (u8_t)10;
  807cbf:	0f b6 c2             	movzbl %dl,%eax
  807cc2:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  807cc5:	8d 04 c8             	lea    (%eax,%ecx,8),%eax
  807cc8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807ccb:	66 c1 e8 0b          	shr    $0xb,%ax
  807ccf:	88 07                	mov    %al,(%edi)
      inv[i++] = '0' + rem;
  807cd1:	8d 4e 01             	lea    0x1(%esi),%ecx
  807cd4:	89 f3                	mov    %esi,%ebx
  807cd6:	0f b6 f3             	movzbl %bl,%esi
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807cd9:	8d 3c 80             	lea    (%eax,%eax,4),%edi
  807cdc:	01 ff                	add    %edi,%edi
  807cde:	89 fb                	mov    %edi,%ebx
  807ce0:	29 da                	sub    %ebx,%edx
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
  807ce2:	83 c2 30             	add    $0x30,%edx
  807ce5:	88 54 35 ed          	mov    %dl,-0x13(%ebp,%esi,1)
    } while(*ap);
  807ce9:	84 c0                	test   %al,%al
  807ceb:	75 ca                	jne    807cb7 <inet_ntoa+0x27>
  807ced:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807cf0:	89 c8                	mov    %ecx,%eax
  807cf2:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  807cf5:	89 cf                	mov    %ecx,%edi
  807cf7:	eb 0d                	jmp    807d06 <inet_ntoa+0x76>
    while(i--)
      *rp++ = inv[i];
  807cf9:	0f b6 f0             	movzbl %al,%esi
  807cfc:	0f b6 4c 35 ed       	movzbl -0x13(%ebp,%esi,1),%ecx
  807d01:	88 0a                	mov    %cl,(%edx)
  807d03:	83 c2 01             	add    $0x1,%edx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  807d06:	83 e8 01             	sub    $0x1,%eax
  807d09:	3c ff                	cmp    $0xff,%al
  807d0b:	75 ec                	jne    807cf9 <inet_ntoa+0x69>
  807d0d:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  807d10:	89 f9                	mov    %edi,%ecx
  807d12:	0f b6 c9             	movzbl %cl,%ecx
  807d15:	03 4d dc             	add    -0x24(%ebp),%ecx
      *rp++ = inv[i];
    *rp++ = '.';
  807d18:	8d 41 01             	lea    0x1(%ecx),%eax
  807d1b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    ap++;
  807d1e:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807d22:	80 45 db 01          	addb   $0x1,-0x25(%ebp)
  807d26:	80 7d db 03          	cmpb   $0x3,-0x25(%ebp)
  807d2a:	77 0a                	ja     807d36 <inet_ntoa+0xa6>
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807d2c:	c6 01 2e             	movb   $0x2e,(%ecx)
  807d2f:	b9 00 00 00 00       	mov    $0x0,%ecx
  807d34:	eb 81                	jmp    807cb7 <inet_ntoa+0x27>
    ap++;
  }
  *--rp = 0;
  807d36:	c6 01 00             	movb   $0x0,(%ecx)
  return str;
}
  807d39:	b8 04 5a b3 00       	mov    $0xb35a04,%eax
  807d3e:	83 c4 19             	add    $0x19,%esp
  807d41:	5b                   	pop    %ebx
  807d42:	5e                   	pop    %esi
  807d43:	5f                   	pop    %edi
  807d44:	5d                   	pop    %ebp
  807d45:	c3                   	ret    

00807d46 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807d46:	55                   	push   %ebp
  807d47:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807d49:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807d4d:	66 c1 c0 08          	rol    $0x8,%ax
}
  807d51:	5d                   	pop    %ebp
  807d52:	c3                   	ret    

00807d53 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807d53:	55                   	push   %ebp
  807d54:	89 e5                	mov    %esp,%ebp
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807d56:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807d5a:	66 c1 c0 08          	rol    $0x8,%ax
 */
u16_t
ntohs(u16_t n)
{
  return htons(n);
}
  807d5e:	5d                   	pop    %ebp
  807d5f:	c3                   	ret    

00807d60 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807d60:	55                   	push   %ebp
  807d61:	89 e5                	mov    %esp,%ebp
  807d63:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  807d66:	89 d1                	mov    %edx,%ecx
  807d68:	c1 e9 18             	shr    $0x18,%ecx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807d6b:	89 d0                	mov    %edx,%eax
  807d6d:	c1 e0 18             	shl    $0x18,%eax
  807d70:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  807d72:	89 d1                	mov    %edx,%ecx
  807d74:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  807d7a:	c1 e1 08             	shl    $0x8,%ecx
  807d7d:	09 c8                	or     %ecx,%eax
    ((n & 0xff0000UL) >> 8) |
  807d7f:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  807d85:	c1 ea 08             	shr    $0x8,%edx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807d88:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  807d8a:	5d                   	pop    %ebp
  807d8b:	c3                   	ret    

00807d8c <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  807d8c:	55                   	push   %ebp
  807d8d:	89 e5                	mov    %esp,%ebp
  807d8f:	57                   	push   %edi
  807d90:	56                   	push   %esi
  807d91:	53                   	push   %ebx
  807d92:	83 ec 20             	sub    $0x20,%esp
  807d95:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  807d98:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  807d9b:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  807d9e:	89 75 d8             	mov    %esi,-0x28(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807da1:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807da4:	80 f9 09             	cmp    $0x9,%cl
  807da7:	0f 87 a6 01 00 00    	ja     807f53 <inet_aton+0x1c7>
      return (0);
    val = 0;
    base = 10;
  807dad:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
    if (c == '0') {
  807db4:	83 fa 30             	cmp    $0x30,%edx
  807db7:	75 2b                	jne    807de4 <inet_aton+0x58>
      c = *++cp;
  807db9:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807dbd:	89 d1                	mov    %edx,%ecx
  807dbf:	83 e1 df             	and    $0xffffffdf,%ecx
  807dc2:	80 f9 58             	cmp    $0x58,%cl
  807dc5:	74 0f                	je     807dd6 <inet_aton+0x4a>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  807dc7:	83 c0 01             	add    $0x1,%eax
  807dca:	0f be d2             	movsbl %dl,%edx
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  807dcd:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  807dd4:	eb 0e                	jmp    807de4 <inet_aton+0x58>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  807dd6:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807dda:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  807ddd:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  807de4:	83 c0 01             	add    $0x1,%eax
  807de7:	bf 00 00 00 00       	mov    $0x0,%edi
  807dec:	eb 03                	jmp    807df1 <inet_aton+0x65>
  807dee:	83 c0 01             	add    $0x1,%eax
  807df1:	8d 70 ff             	lea    -0x1(%eax),%esi
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  807df4:	89 d3                	mov    %edx,%ebx
  807df6:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807df9:	80 f9 09             	cmp    $0x9,%cl
  807dfc:	77 0d                	ja     807e0b <inet_aton+0x7f>
        val = (val * base) + (int)(c - '0');
  807dfe:	0f af 7d e0          	imul   -0x20(%ebp),%edi
  807e02:	8d 7c 3a d0          	lea    -0x30(%edx,%edi,1),%edi
        c = *++cp;
  807e06:	0f be 10             	movsbl (%eax),%edx
  807e09:	eb e3                	jmp    807dee <inet_aton+0x62>
      } else if (base == 16 && isxdigit(c)) {
  807e0b:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  807e0f:	75 30                	jne    807e41 <inet_aton+0xb5>
  807e11:	8d 4b 9f             	lea    -0x61(%ebx),%ecx
  807e14:	88 4d df             	mov    %cl,-0x21(%ebp)
  807e17:	89 d1                	mov    %edx,%ecx
  807e19:	83 e1 df             	and    $0xffffffdf,%ecx
  807e1c:	83 e9 41             	sub    $0x41,%ecx
  807e1f:	80 f9 05             	cmp    $0x5,%cl
  807e22:	77 23                	ja     807e47 <inet_aton+0xbb>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807e24:	89 fb                	mov    %edi,%ebx
  807e26:	c1 e3 04             	shl    $0x4,%ebx
  807e29:	8d 7a 0a             	lea    0xa(%edx),%edi
  807e2c:	80 7d df 1a          	cmpb   $0x1a,-0x21(%ebp)
  807e30:	19 c9                	sbb    %ecx,%ecx
  807e32:	83 e1 20             	and    $0x20,%ecx
  807e35:	83 c1 41             	add    $0x41,%ecx
  807e38:	29 cf                	sub    %ecx,%edi
  807e3a:	09 df                	or     %ebx,%edi
        c = *++cp;
  807e3c:	0f be 10             	movsbl (%eax),%edx
  807e3f:	eb ad                	jmp    807dee <inet_aton+0x62>
  807e41:	89 d0                	mov    %edx,%eax
  807e43:	89 f9                	mov    %edi,%ecx
  807e45:	eb 04                	jmp    807e4b <inet_aton+0xbf>
  807e47:	89 d0                	mov    %edx,%eax
  807e49:	89 f9                	mov    %edi,%ecx
      } else
        break;
    }
    if (c == '.') {
  807e4b:	83 f8 2e             	cmp    $0x2e,%eax
  807e4e:	75 22                	jne    807e72 <inet_aton+0xe6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807e50:	8d 45 f0             	lea    -0x10(%ebp),%eax
  807e53:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  807e56:	0f 84 fe 00 00 00    	je     807f5a <inet_aton+0x1ce>
        return (0);
      *pp++ = val;
  807e5c:	83 45 d8 04          	addl   $0x4,-0x28(%ebp)
  807e60:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807e63:	89 48 fc             	mov    %ecx,-0x4(%eax)
      c = *++cp;
  807e66:	8d 46 01             	lea    0x1(%esi),%eax
  807e69:	0f be 56 01          	movsbl 0x1(%esi),%edx
    } else
      break;
  }
  807e6d:	e9 2f ff ff ff       	jmp    807da1 <inet_aton+0x15>
  807e72:	89 f9                	mov    %edi,%ecx
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807e74:	85 d2                	test   %edx,%edx
  807e76:	74 27                	je     807e9f <inet_aton+0x113>
    return (0);
  807e78:	b8 00 00 00 00       	mov    $0x0,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807e7d:	80 fb 1f             	cmp    $0x1f,%bl
  807e80:	0f 86 e7 00 00 00    	jbe    807f6d <inet_aton+0x1e1>
  807e86:	84 d2                	test   %dl,%dl
  807e88:	0f 88 d3 00 00 00    	js     807f61 <inet_aton+0x1d5>
  807e8e:	83 fa 20             	cmp    $0x20,%edx
  807e91:	74 0c                	je     807e9f <inet_aton+0x113>
  807e93:	83 ea 09             	sub    $0x9,%edx
  807e96:	83 fa 04             	cmp    $0x4,%edx
  807e99:	0f 87 ce 00 00 00    	ja     807f6d <inet_aton+0x1e1>
    return (0);
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  807e9f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807ea2:	8b 55 d8             	mov    -0x28(%ebp),%edx
  807ea5:	29 c2                	sub    %eax,%edx
  807ea7:	c1 fa 02             	sar    $0x2,%edx
  807eaa:	83 c2 01             	add    $0x1,%edx
  switch (n) {
  807ead:	83 fa 02             	cmp    $0x2,%edx
  807eb0:	74 22                	je     807ed4 <inet_aton+0x148>
  807eb2:	83 fa 02             	cmp    $0x2,%edx
  807eb5:	7f 0f                	jg     807ec6 <inet_aton+0x13a>

  case 0:
    return (0);       /* initial nondigit */
  807eb7:	b8 00 00 00 00       	mov    $0x0,%eax
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  807ebc:	85 d2                	test   %edx,%edx
  807ebe:	0f 84 a9 00 00 00    	je     807f6d <inet_aton+0x1e1>
  807ec4:	eb 73                	jmp    807f39 <inet_aton+0x1ad>
  807ec6:	83 fa 03             	cmp    $0x3,%edx
  807ec9:	74 26                	je     807ef1 <inet_aton+0x165>
  807ecb:	83 fa 04             	cmp    $0x4,%edx
  807ece:	66 90                	xchg   %ax,%ax
  807ed0:	74 40                	je     807f12 <inet_aton+0x186>
  807ed2:	eb 65                	jmp    807f39 <inet_aton+0x1ad>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  807ed4:	b8 00 00 00 00       	mov    $0x0,%eax

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  807ed9:	81 f9 ff ff ff 00    	cmp    $0xffffff,%ecx
  807edf:	0f 87 88 00 00 00    	ja     807f6d <inet_aton+0x1e1>
      return (0);
    val |= parts[0] << 24;
  807ee5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ee8:	c1 e0 18             	shl    $0x18,%eax
  807eeb:	89 cf                	mov    %ecx,%edi
  807eed:	09 c7                	or     %eax,%edi
    break;
  807eef:	eb 48                	jmp    807f39 <inet_aton+0x1ad>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  807ef1:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  807ef6:	81 f9 ff ff 00 00    	cmp    $0xffff,%ecx
  807efc:	77 6f                	ja     807f6d <inet_aton+0x1e1>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  807efe:	8b 55 e8             	mov    -0x18(%ebp),%edx
  807f01:	c1 e2 10             	shl    $0x10,%edx
  807f04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f07:	c1 e0 18             	shl    $0x18,%eax
  807f0a:	09 d0                	or     %edx,%eax
  807f0c:	09 c8                	or     %ecx,%eax
  807f0e:	89 c7                	mov    %eax,%edi
    break;
  807f10:	eb 27                	jmp    807f39 <inet_aton+0x1ad>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  807f12:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  807f17:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  807f1d:	77 4e                	ja     807f6d <inet_aton+0x1e1>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807f1f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  807f22:	c1 e2 10             	shl    $0x10,%edx
  807f25:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f28:	c1 e0 18             	shl    $0x18,%eax
  807f2b:	09 c2                	or     %eax,%edx
  807f2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  807f30:	c1 e0 08             	shl    $0x8,%eax
  807f33:	09 d0                	or     %edx,%eax
  807f35:	09 c8                	or     %ecx,%eax
  807f37:	89 c7                	mov    %eax,%edi
    break;
  }
  if (addr)
  807f39:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807f3d:	74 29                	je     807f68 <inet_aton+0x1dc>
    addr->s_addr = htonl(val);
  807f3f:	89 3c 24             	mov    %edi,(%esp)
  807f42:	e8 19 fe ff ff       	call   807d60 <htonl>
  807f47:	8b 75 0c             	mov    0xc(%ebp),%esi
  807f4a:	89 06                	mov    %eax,(%esi)
  return (1);
  807f4c:	b8 01 00 00 00       	mov    $0x1,%eax
  807f51:	eb 1a                	jmp    807f6d <inet_aton+0x1e1>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  807f53:	b8 00 00 00 00       	mov    $0x0,%eax
  807f58:	eb 13                	jmp    807f6d <inet_aton+0x1e1>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  807f5a:	b8 00 00 00 00       	mov    $0x0,%eax
  807f5f:	eb 0c                	jmp    807f6d <inet_aton+0x1e1>
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
    return (0);
  807f61:	b8 00 00 00 00       	mov    $0x0,%eax
  807f66:	eb 05                	jmp    807f6d <inet_aton+0x1e1>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  807f68:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807f6d:	83 c4 20             	add    $0x20,%esp
  807f70:	5b                   	pop    %ebx
  807f71:	5e                   	pop    %esi
  807f72:	5f                   	pop    %edi
  807f73:	5d                   	pop    %ebp
  807f74:	c3                   	ret    

00807f75 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  807f75:	55                   	push   %ebp
  807f76:	89 e5                	mov    %esp,%ebp
  807f78:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  807f7b:	8d 45 fc             	lea    -0x4(%ebp),%eax
  807f7e:	89 44 24 04          	mov    %eax,0x4(%esp)
  807f82:	8b 45 08             	mov    0x8(%ebp),%eax
  807f85:	89 04 24             	mov    %eax,(%esp)
  807f88:	e8 ff fd ff ff       	call   807d8c <inet_aton>
  807f8d:	85 c0                	test   %eax,%eax
    return (val.s_addr);
  807f8f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f94:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
  }
  return (INADDR_NONE);
}
  807f98:	c9                   	leave  
  807f99:	c3                   	ret    

00807f9a <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807f9a:	55                   	push   %ebp
  807f9b:	89 e5                	mov    %esp,%ebp
  807f9d:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  807fa0:	8b 45 08             	mov    0x8(%ebp),%eax
  807fa3:	89 04 24             	mov    %eax,(%esp)
  807fa6:	e8 b5 fd ff ff       	call   807d60 <htonl>
}
  807fab:	c9                   	leave  
  807fac:	c3                   	ret    
  807fad:	66 90                	xchg   %ax,%ax
  807faf:	90                   	nop

00807fb0 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807fb0:	55                   	push   %ebp
  807fb1:	89 e5                	mov    %esp,%ebp
  807fb3:	57                   	push   %edi
  807fb4:	56                   	push   %esi
  807fb5:	53                   	push   %ebx
  807fb6:	83 ec 4c             	sub    $0x4c,%esp
  807fb9:	8b 7d 08             	mov    0x8(%ebp),%edi
  807fbc:	8b 45 10             	mov    0x10(%ebp),%eax
  807fbf:	89 c6                	mov    %eax,%esi
  807fc1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  807fc4:	8b 45 14             	mov    0x14(%ebp),%eax
  807fc7:	89 c1                	mov    %eax,%ecx
  807fc9:	89 45 bc             	mov    %eax,-0x44(%ebp)
  807fcc:	8b 45 18             	mov    0x18(%ebp),%eax
  807fcf:	89 c2                	mov    %eax,%edx
  807fd1:	89 45 b8             	mov    %eax,-0x48(%ebp)
  807fd4:	8b 45 20             	mov    0x20(%ebp),%eax
  807fd7:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  807fdb:	88 4d ce             	mov    %cl,-0x32(%ebp)
  807fde:	88 45 cb             	mov    %al,-0x35(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807fe1:	66 85 f6             	test   %si,%si
  807fe4:	74 20                	je     808006 <tcp_enqueue+0x56>
  807fe6:	84 c0                	test   %al,%al
  807fe8:	74 1c                	je     808006 <tcp_enqueue+0x56>
  807fea:	c7 44 24 08 dc 31 81 	movl   $0x8131dc,0x8(%esp)
  807ff1:	00 
  807ff2:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  807ff9:	00 
  807ffa:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  808001:	e8 34 70 00 00       	call   80f03a <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  808006:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80800a:	0f 95 c1             	setne  %cl
  80800d:	88 4d c9             	mov    %cl,-0x37(%ebp)
  808010:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  808014:	0f 95 45 cf          	setne  -0x31(%ebp)
  808018:	84 c9                	test   %cl,%cl
  80801a:	74 22                	je     80803e <tcp_enqueue+0x8e>
  80801c:	80 7d cf 00          	cmpb   $0x0,-0x31(%ebp)
  808020:	74 1c                	je     80803e <tcp_enqueue+0x8e>
  808022:	c7 44 24 08 1c 32 81 	movl   $0x81321c,0x8(%esp)
  808029:	00 
  80802a:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  808031:	00 
  808032:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  808039:	e8 fc 6f 00 00       	call   80f03a <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80803e:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  808042:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  808046:	76 0e                	jbe    808056 <tcp_enqueue+0xa6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  808048:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  80804c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808051:	e9 24 06 00 00       	jmp    80867a <tcp_enqueue+0x6ca>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  808056:	8b 4f 68             	mov    0x68(%edi),%ecx
  808059:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80805c:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  808060:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  808064:	66 83 f9 1f          	cmp    $0x1f,%cx
  808068:	76 0e                	jbe    808078 <tcp_enqueue+0xc8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80806a:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  80806e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808073:	e9 02 06 00 00       	jmp    80867a <tcp_enqueue+0x6ca>
  }
  if (queuelen != 0) {
  808078:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  80807d:	74 30                	je     8080af <tcp_enqueue+0xff>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80807f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808083:	0f 85 b9 05 00 00    	jne    808642 <tcp_enqueue+0x692>
  808089:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80808d:	0f 85 af 05 00 00    	jne    808642 <tcp_enqueue+0x692>
  808093:	c7 44 24 08 64 32 81 	movl   $0x813264,0x8(%esp)
  80809a:	00 
  80809b:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  8080a2:	00 
  8080a3:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  8080aa:	e8 8b 6f 00 00       	call   80f03a <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8080af:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8080b3:	75 0a                	jne    8080bf <tcp_enqueue+0x10f>
  8080b5:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8080b9:	0f 84 83 05 00 00    	je     808642 <tcp_enqueue+0x692>
  8080bf:	c7 44 24 08 a0 32 81 	movl   $0x8132a0,0x8(%esp)
  8080c6:	00 
  8080c7:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  8080ce:	00 
  8080cf:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  8080d6:	e8 5f 6f 00 00       	call   80f03a <_panic>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  8080db:	89 de                	mov    %ebx,%esi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  8080dd:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  8080e1:	0f b7 4d e0          	movzwl -0x20(%ebp),%ecx
  8080e5:	66 39 c1             	cmp    %ax,%cx
  8080e8:	0f 46 c1             	cmovbe %ecx,%eax
  8080eb:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  8080ef:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  8080f6:	e8 c7 c8 ff ff       	call   8049c2 <memp_malloc>
  8080fb:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  8080fd:	85 c0                	test   %eax,%eax
  8080ff:	0f 84 c3 04 00 00    	je     8085c8 <tcp_enqueue+0x618>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  808105:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80810b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  808112:	80 7d dc 00          	cmpb   $0x0,-0x24(%ebp)
  808116:	75 24                	jne    80813c <tcp_enqueue+0x18c>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  808118:	85 f6                	test   %esi,%esi
  80811a:	75 1c                	jne    808138 <tcp_enqueue+0x188>
  80811c:	c7 44 24 08 96 33 81 	movl   $0x813396,0x8(%esp)
  808123:	00 
  808124:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80812b:	00 
  80812c:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  808133:	e8 02 6f 00 00       	call   80f03a <_panic>
      useg->next = seg;
  808138:	89 06                	mov    %eax,(%esi)
  80813a:	eb 03                	jmp    80813f <tcp_enqueue+0x18f>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80813c:	89 45 d0             	mov    %eax,-0x30(%ebp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80813f:	80 7d cf 00          	cmpb   $0x0,-0x31(%ebp)
  808143:	74 69                	je     8081ae <tcp_enqueue+0x1fe>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  808145:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80814c:	00 
  80814d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808150:	89 44 24 04          	mov    %eax,0x4(%esp)
  808154:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80815b:	e8 55 cd ff ff       	call   804eb5 <pbuf_alloc>
  808160:	89 43 04             	mov    %eax,0x4(%ebx)
  808163:	85 c0                	test   %eax,%eax
  808165:	0f 84 5d 04 00 00    	je     8085c8 <tcp_enqueue+0x618>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80816b:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
  80816f:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  808173:	73 1c                	jae    808191 <tcp_enqueue+0x1e1>
  808175:	c7 44 24 08 d4 32 81 	movl   $0x8132d4,0x8(%esp)
  80817c:	00 
  80817d:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  808184:	00 
  808185:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  80818c:	e8 a9 6e 00 00       	call   80f03a <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  808191:	89 04 24             	mov    %eax,(%esp)
  808194:	e8 d1 d0 ff ff       	call   80526a <pbuf_clen>
  808199:	0f b6 c0             	movzbl %al,%eax
  80819c:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
      seg->dataptr = seg->p->payload;
  8081a0:	8b 43 04             	mov    0x4(%ebx),%eax
  8081a3:	8b 40 04             	mov    0x4(%eax),%eax
  8081a6:	89 43 08             	mov    %eax,0x8(%ebx)
  8081a9:	e9 22 01 00 00       	jmp    8082d0 <tcp_enqueue+0x320>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8081ae:	80 7d ca 00          	cmpb   $0x0,-0x36(%ebp)
  8081b2:	0f 84 8c 00 00 00    	je     808244 <tcp_enqueue+0x294>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  8081b8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8081bf:	00 
  8081c0:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
  8081c4:	0f b7 c6             	movzwl %si,%eax
  8081c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8081cb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8081d2:	e8 de cc ff ff       	call   804eb5 <pbuf_alloc>
  8081d7:	89 43 04             	mov    %eax,0x4(%ebx)
  8081da:	85 c0                	test   %eax,%eax
  8081dc:	0f 84 e6 03 00 00    	je     8085c8 <tcp_enqueue+0x618>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  8081e2:	66 3b 70 0a          	cmp    0xa(%eax),%si
  8081e6:	76 1c                	jbe    808204 <tcp_enqueue+0x254>
  8081e8:	c7 44 24 08 fc 32 81 	movl   $0x8132fc,0x8(%esp)
  8081ef:	00 
  8081f0:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  8081f7:	00 
  8081f8:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  8081ff:	e8 36 6e 00 00       	call   80f03a <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  808204:	89 04 24             	mov    %eax,(%esp)
  808207:	e8 5e d0 ff ff       	call   80526a <pbuf_clen>
  80820c:	0f b6 c0             	movzbl %al,%eax
  80820f:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
      if (arg != NULL) {
  808213:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  808217:	74 1d                	je     808236 <tcp_enqueue+0x286>
        MEMCPY(seg->p->payload, ptr, seglen);
  808219:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80821d:	89 44 24 08          	mov    %eax,0x8(%esp)
  808221:	8b 45 0c             	mov    0xc(%ebp),%eax
  808224:	89 44 24 04          	mov    %eax,0x4(%esp)
  808228:	8b 43 04             	mov    0x4(%ebx),%eax
  80822b:	8b 40 04             	mov    0x4(%eax),%eax
  80822e:	89 04 24             	mov    %eax,(%esp)
  808231:	e8 76 77 00 00       	call   80f9ac <memcpy>
      }
      seg->dataptr = seg->p->payload;
  808236:	8b 43 04             	mov    0x4(%ebx),%eax
  808239:	8b 40 04             	mov    0x4(%eax),%eax
  80823c:	89 43 08             	mov    %eax,0x8(%ebx)
  80823f:	e9 8c 00 00 00       	jmp    8082d0 <tcp_enqueue+0x320>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  808244:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80824b:	00 
  80824c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  808250:	89 44 24 04          	mov    %eax,0x4(%esp)
  808254:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80825b:	e8 55 cc ff ff       	call   804eb5 <pbuf_alloc>
  808260:	89 c6                	mov    %eax,%esi
  808262:	85 c0                	test   %eax,%eax
  808264:	0f 84 5e 03 00 00    	je     8085c8 <tcp_enqueue+0x618>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  80826a:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80826e:	83 c0 01             	add    $0x1,%eax
  808271:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  808275:	8b 45 0c             	mov    0xc(%ebp),%eax
  808278:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  80827b:	89 43 08             	mov    %eax,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  80827e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808285:	00 
  808286:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80828d:	00 
  80828e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808295:	e8 1b cc ff ff       	call   804eb5 <pbuf_alloc>
  80829a:	89 43 04             	mov    %eax,0x4(%ebx)
  80829d:	85 c0                	test   %eax,%eax
  80829f:	75 0d                	jne    8082ae <tcp_enqueue+0x2fe>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  8082a1:	89 34 24             	mov    %esi,(%esp)
  8082a4:	e8 2b cb ff ff       	call   804dd4 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  8082a9:	e9 1a 03 00 00       	jmp    8085c8 <tcp_enqueue+0x618>
      }
      queuelen += pbuf_clen(seg->p);
  8082ae:	89 04 24             	mov    %eax,(%esp)
  8082b1:	e8 b4 cf ff ff       	call   80526a <pbuf_clen>
  8082b6:	0f b6 c0             	movzbl %al,%eax
  8082b9:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  8082bd:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  8082c1:	89 74 24 04          	mov    %esi,0x4(%esp)
  8082c5:	8b 43 04             	mov    0x4(%ebx),%eax
  8082c8:	89 04 24             	mov    %eax,(%esp)
  8082cb:	e8 c3 cf ff ff       	call   805293 <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  8082d0:	66 83 7d e4 20       	cmpw   $0x20,-0x1c(%ebp)
  8082d5:	0f 87 ed 02 00 00    	ja     8085c8 <tcp_enqueue+0x618>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  8082db:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8082df:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  8082e3:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8082ea:	00 
  8082eb:	8b 43 04             	mov    0x4(%ebx),%eax
  8082ee:	89 04 24             	mov    %eax,(%esp)
  8082f1:	e8 fa c9 ff ff       	call   804cf0 <pbuf_header>
  8082f6:	84 c0                	test   %al,%al
  8082f8:	0f 85 ca 02 00 00    	jne    8085c8 <tcp_enqueue+0x618>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  8082fe:	8b 43 04             	mov    0x4(%ebx),%eax
  808301:	8b 70 04             	mov    0x4(%eax),%esi
  808304:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  808307:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80830b:	89 04 24             	mov    %eax,(%esp)
  80830e:	e8 33 fa ff ff       	call   807d46 <htons>
  808313:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  808316:	8b 73 10             	mov    0x10(%ebx),%esi
  808319:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  80831d:	89 04 24             	mov    %eax,(%esp)
  808320:	e8 21 fa ff ff       	call   807d46 <htons>
  808325:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  808329:	8b 73 10             	mov    0x10(%ebx),%esi
  80832c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80832f:	89 04 24             	mov    %eax,(%esp)
  808332:	e8 29 fa ff ff       	call   807d60 <htonl>
  808337:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  80833a:	8b 43 10             	mov    0x10(%ebx),%eax
  80833d:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  808343:	8b 73 10             	mov    0x10(%ebx),%esi
  808346:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80834a:	89 04 24             	mov    %eax,(%esp)
  80834d:	e8 01 fa ff ff       	call   807d53 <ntohs>
  808352:	83 e0 c0             	and    $0xffffffc0,%eax
  808355:	0f b6 55 ce          	movzbl -0x32(%ebp),%edx
  808359:	09 d0                	or     %edx,%eax
  80835b:	0f b7 c0             	movzwl %ax,%eax
  80835e:	89 04 24             	mov    %eax,(%esp)
  808361:	e8 e0 f9 ff ff       	call   807d46 <htons>
  808366:	66 89 46 0c          	mov    %ax,0xc(%esi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80836a:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80836e:	75 23                	jne    808393 <tcp_enqueue+0x3e3>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  808370:	8b 73 10             	mov    0x10(%ebx),%esi
  808373:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  808377:	89 04 24             	mov    %eax,(%esp)
  80837a:	e8 d4 f9 ff ff       	call   807d53 <ntohs>
  80837f:	83 e0 3f             	and    $0x3f,%eax
  808382:	80 cc 50             	or     $0x50,%ah
  808385:	89 04 24             	mov    %eax,(%esp)
  808388:	e8 b9 f9 ff ff       	call   807d46 <htons>
  80838d:	66 89 46 0c          	mov    %ax,0xc(%esi)
  808391:	eb 3e                	jmp    8083d1 <tcp_enqueue+0x421>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  808393:	8b 73 10             	mov    0x10(%ebx),%esi
  808396:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80839a:	89 04 24             	mov    %eax,(%esp)
  80839d:	e8 b1 f9 ff ff       	call   807d53 <ntohs>
  8083a2:	83 e0 3f             	and    $0x3f,%eax
  8083a5:	66 0b 45 cc          	or     -0x34(%ebp),%ax
  8083a9:	0f b7 c0             	movzwl %ax,%eax
  8083ac:	89 04 24             	mov    %eax,(%esp)
  8083af:	e8 92 f9 ff ff       	call   807d46 <htons>
  8083b4:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  8083b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8083bb:	89 44 24 08          	mov    %eax,0x8(%esp)
  8083bf:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8083c2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8083c6:	8b 43 08             	mov    0x8(%ebx),%eax
  8083c9:	89 04 24             	mov    %eax,(%esp)
  8083cc:	e8 db 75 00 00       	call   80f9ac <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  8083d1:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8083d5:	66 29 45 e0          	sub    %ax,-0x20(%ebp)
    seqno += seglen;
  8083d9:	0f b7 c0             	movzwl %ax,%eax
  8083dc:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  8083df:	01 45 0c             	add    %eax,0xc(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  8083e2:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  8083e6:	0f 94 45 dc          	sete   -0x24(%ebp)
  8083ea:	0f 84 eb fc ff ff    	je     8080db <tcp_enqueue+0x12b>
  8083f0:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  8083f5:	0f 85 e0 fc ff ff    	jne    8080db <tcp_enqueue+0x12b>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  8083fb:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  8083fe:	8b 77 74             	mov    0x74(%edi),%esi
  808401:	85 f6                	test   %esi,%esi
  808403:	0f 84 24 02 00 00    	je     80862d <tcp_enqueue+0x67d>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  808409:	8b 06                	mov    (%esi),%eax
  80840b:	85 c0                	test   %eax,%eax
  80840d:	74 04                	je     808413 <tcp_enqueue+0x463>
  80840f:	89 c6                	mov    %eax,%esi
  808411:	eb f6                	jmp    808409 <tcp_enqueue+0x459>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808413:	85 f6                	test   %esi,%esi
  808415:	0f 84 12 02 00 00    	je     80862d <tcp_enqueue+0x67d>
    TCP_TCPLEN(useg) != 0 &&
  80841b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80841f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808422:	8b 46 10             	mov    0x10(%esi),%eax
  808425:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808429:	89 04 24             	mov    %eax,(%esp)
  80842c:	e8 22 f9 ff ff       	call   807d53 <ntohs>
  808431:	ba 01 00 00 00       	mov    $0x1,%edx
  808436:	a8 01                	test   $0x1,%al
  808438:	75 17                	jne    808451 <tcp_enqueue+0x4a1>
  80843a:	8b 46 10             	mov    0x10(%esi),%eax
  80843d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808441:	89 04 24             	mov    %eax,(%esp)
  808444:	e8 0a f9 ff ff       	call   807d53 <ntohs>
  808449:	66 d1 e8             	shr    %ax
  80844c:	89 c2                	mov    %eax,%edx
  80844e:	83 e2 01             	and    $0x1,%edx
  808451:	03 55 e0             	add    -0x20(%ebp),%edx
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808454:	85 d2                	test   %edx,%edx
  808456:	0f 84 dc 01 00 00    	je     808638 <tcp_enqueue+0x688>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  80845c:	8b 46 10             	mov    0x10(%esi),%eax
  80845f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808463:	89 04 24             	mov    %eax,(%esp)
  808466:	e8 e8 f8 ff ff       	call   807d53 <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  80846b:	a8 03                	test   $0x3,%al
  80846d:	0f 85 c5 01 00 00    	jne    808638 <tcp_enqueue+0x688>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  808473:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  808477:	0f 85 bb 01 00 00    	jne    808638 <tcp_enqueue+0x688>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  80847d:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  808481:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808484:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808488:	01 c2                	add    %eax,%edx
  80848a:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  80848e:	39 c2                	cmp    %eax,%edx
  808490:	0f 8f a2 01 00 00    	jg     808638 <tcp_enqueue+0x688>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  808496:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80849d:	ff 
  80849e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8084a1:	8b 40 04             	mov    0x4(%eax),%eax
  8084a4:	89 04 24             	mov    %eax,(%esp)
  8084a7:	e8 44 c8 ff ff       	call   804cf0 <pbuf_header>
  8084ac:	84 c0                	test   %al,%al
  8084ae:	74 1c                	je     8084cc <tcp_enqueue+0x51c>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8084b0:	c7 44 24 08 a3 33 81 	movl   $0x8133a3,0x8(%esp)
  8084b7:	00 
  8084b8:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  8084bf:	00 
  8084c0:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  8084c7:	e8 6e 6b 00 00       	call   80f03a <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  8084cc:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8084cf:	8b 40 04             	mov    0x4(%eax),%eax
  8084d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8084d6:	8b 46 04             	mov    0x4(%esi),%eax
  8084d9:	89 04 24             	mov    %eax,(%esp)
  8084dc:	e8 b2 cd ff ff       	call   805293 <pbuf_cat>
    useg->len += queue->len;
  8084e1:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8084e4:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  8084e8:	66 01 46 0c          	add    %ax,0xc(%esi)
    useg->next = queue->next;
  8084ec:	8b 02                	mov    (%edx),%eax
  8084ee:	89 06                	mov    %eax,(%esi)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
      seg = NULL;
  8084f0:	3b 55 dc             	cmp    -0x24(%ebp),%edx
  8084f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8084f8:	0f 44 d8             	cmove  %eax,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  8084fb:	89 54 24 04          	mov    %edx,0x4(%esp)
  8084ff:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808506:	e8 17 c5 ff ff       	call   804a22 <memp_free>
  80850b:	eb 19                	jmp    808526 <tcp_enqueue+0x576>
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80850d:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  808511:	83 e2 03             	and    $0x3,%edx
    ++len;
  808514:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  808518:	83 c0 01             	add    $0x1,%eax
  80851b:	84 d2                	test   %dl,%dl
  80851d:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  808522:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  808526:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  80852a:	74 04                	je     808530 <tcp_enqueue+0x580>
    pcb->flags |= TF_FIN;
  80852c:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  808530:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  808534:	0f b7 c2             	movzwl %dx,%eax
  808537:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  80853a:	66 29 57 6e          	sub    %dx,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80853e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808542:	66 89 47 70          	mov    %ax,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  808546:	66 85 c0             	test   %ax,%ax
  808549:	74 28                	je     808573 <tcp_enqueue+0x5c3>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80854b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80854f:	75 22                	jne    808573 <tcp_enqueue+0x5c3>
  808551:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  808555:	75 1c                	jne    808573 <tcp_enqueue+0x5c3>
  808557:	c7 44 24 08 30 33 81 	movl   $0x813330,0x8(%esp)
  80855e:	00 
  80855f:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  808566:	00 
  808567:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  80856e:	e8 c7 6a 00 00       	call   80f03a <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  808573:	85 db                	test   %ebx,%ebx
  808575:	0f 84 8f 00 00 00    	je     80860a <tcp_enqueue+0x65a>
  80857b:	66 83 7d e6 00       	cmpw   $0x0,-0x1a(%ebp)
  808580:	0f 84 84 00 00 00    	je     80860a <tcp_enqueue+0x65a>
  808586:	8b 5b 10             	mov    0x10(%ebx),%ebx
  808589:	85 db                	test   %ebx,%ebx
  80858b:	0f 84 80 00 00 00    	je     808611 <tcp_enqueue+0x661>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  808591:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  808596:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  80859a:	0f 85 da 00 00 00    	jne    80867a <tcp_enqueue+0x6ca>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  8085a0:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8085a4:	89 04 24             	mov    %eax,(%esp)
  8085a7:	e8 a7 f7 ff ff       	call   807d53 <ntohs>
  8085ac:	83 c8 08             	or     $0x8,%eax
  8085af:	0f b7 c0             	movzwl %ax,%eax
  8085b2:	89 04 24             	mov    %eax,(%esp)
  8085b5:	e8 8c f7 ff ff       	call   807d46 <htons>
  8085ba:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  }

  return ERR_OK;
  8085be:	b8 00 00 00 00       	mov    $0x0,%eax
  8085c3:	e9 b2 00 00 00       	jmp    80867a <tcp_enqueue+0x6ca>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  8085c8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  8085cc:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8085cf:	85 c0                	test   %eax,%eax
  8085d1:	74 08                	je     8085db <tcp_enqueue+0x62b>
    tcp_segs_free(queue);
  8085d3:	89 04 24             	mov    %eax,(%esp)
  8085d6:	e8 13 d8 ff ff       	call   805dee <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  8085db:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  8085e0:	74 36                	je     808618 <tcp_enqueue+0x668>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  8085e2:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8085e6:	75 37                	jne    80861f <tcp_enqueue+0x66f>
  8085e8:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8085ec:	75 38                	jne    808626 <tcp_enqueue+0x676>
  8085ee:	c7 44 24 08 30 33 81 	movl   $0x813330,0x8(%esp)
  8085f5:	00 
  8085f6:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  8085fd:	00 
  8085fe:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  808605:	e8 30 6a 00 00       	call   80f03a <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  80860a:	b8 00 00 00 00       	mov    $0x0,%eax
  80860f:	eb 69                	jmp    80867a <tcp_enqueue+0x6ca>
  808611:	b8 00 00 00 00       	mov    $0x0,%eax
  808616:	eb 62                	jmp    80867a <tcp_enqueue+0x6ca>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  808618:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80861d:	eb 5b                	jmp    80867a <tcp_enqueue+0x6ca>
  80861f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808624:	eb 54                	jmp    80867a <tcp_enqueue+0x6ca>
  808626:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80862b:	eb 4d                	jmp    80867a <tcp_enqueue+0x6ca>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80862d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808630:	89 47 74             	mov    %eax,0x74(%edi)
  808633:	e9 d5 fe ff ff       	jmp    80850d <tcp_enqueue+0x55d>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  808638:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80863b:	89 06                	mov    %eax,(%esi)
  80863d:	e9 cb fe ff ff       	jmp    80850d <tcp_enqueue+0x55d>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  808642:	c0 e8 02             	shr    $0x2,%al
  808645:	c1 e0 0c             	shl    $0xc,%eax
  808648:	66 05 00 50          	add    $0x5000,%ax
  80864c:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
  808650:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  808654:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  808658:	c6 45 dc 01          	movb   $0x1,-0x24(%ebp)
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80865c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  808663:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  808668:	83 e2 01             	and    $0x1,%edx
  80866b:	88 55 ca             	mov    %dl,-0x36(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80866e:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
  808672:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  808675:	e9 63 fa ff ff       	jmp    8080dd <tcp_enqueue+0x12d>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  80867a:	83 c4 4c             	add    $0x4c,%esp
  80867d:	5b                   	pop    %ebx
  80867e:	5e                   	pop    %esi
  80867f:	5f                   	pop    %edi
  808680:	5d                   	pop    %ebp
  808681:	c3                   	ret    

00808682 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  808682:	55                   	push   %ebp
  808683:	89 e5                	mov    %esp,%ebp
  808685:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  808688:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80868f:	00 
  808690:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  808697:	00 
  808698:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80869f:	00 
  8086a0:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  8086a4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8086a8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8086af:	00 
  8086b0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8086b7:	00 
  8086b8:	8b 45 08             	mov    0x8(%ebp),%eax
  8086bb:	89 04 24             	mov    %eax,(%esp)
  8086be:	e8 ed f8 ff ff       	call   807fb0 <tcp_enqueue>
}
  8086c3:	c9                   	leave  
  8086c4:	c3                   	ret    

008086c5 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  8086c5:	55                   	push   %ebp
  8086c6:	89 e5                	mov    %esp,%ebp
  8086c8:	56                   	push   %esi
  8086c9:	53                   	push   %ebx
  8086ca:	83 ec 20             	sub    $0x20,%esp
  8086cd:	8b 55 08             	mov    0x8(%ebp),%edx
  8086d0:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8086d3:	8b 5d 14             	mov    0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  8086d6:	8b 42 10             	mov    0x10(%edx),%eax
  8086d9:	83 f8 07             	cmp    $0x7,%eax
  8086dc:	74 0d                	je     8086eb <tcp_write+0x26>
     pcb->state == CLOSE_WAIT ||
  8086de:	8d 70 fe             	lea    -0x2(%eax),%esi
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  8086e1:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  8086e6:	83 fe 02             	cmp    $0x2,%esi
  8086e9:	77 3f                	ja     80872a <tcp_write+0x65>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  8086eb:	b8 00 00 00 00       	mov    $0x0,%eax
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  8086f0:	66 85 c9             	test   %cx,%cx
  8086f3:	74 35                	je     80872a <tcp_write+0x65>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  8086f5:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  8086fc:	00 
  8086fd:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  808704:	00 
  808705:	0f b6 db             	movzbl %bl,%ebx
  808708:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  80870c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  808713:	00 
  808714:	0f b7 c9             	movzwl %cx,%ecx
  808717:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80871b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80871e:	89 44 24 04          	mov    %eax,0x4(%esp)
  808722:	89 14 24             	mov    %edx,(%esp)
  808725:	e8 86 f8 ff ff       	call   807fb0 <tcp_enqueue>
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80872a:	83 c4 20             	add    $0x20,%esp
  80872d:	5b                   	pop    %ebx
  80872e:	5e                   	pop    %esi
  80872f:	5d                   	pop    %ebp
  808730:	c3                   	ret    

00808731 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  808731:	55                   	push   %ebp
  808732:	89 e5                	mov    %esp,%ebp
  808734:	57                   	push   %edi
  808735:	56                   	push   %esi
  808736:	53                   	push   %ebx
  808737:	83 ec 3c             	sub    $0x3c,%esp
  80873a:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80873d:	39 3d 78 c2 b3 00    	cmp    %edi,0xb3c278
  808743:	0f 84 53 04 00 00    	je     808b9c <tcp_output+0x46b>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808749:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80874d:	66 39 47 5c          	cmp    %ax,0x5c(%edi)
  808751:	66 0f 46 47 5c       	cmovbe 0x5c(%edi),%ax
  808756:	0f b7 c0             	movzwl %ax,%eax
  808759:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  80875c:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80875f:	8b 47 78             	mov    0x78(%edi),%eax
  808762:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (useg != NULL) {
  808765:	85 c0                	test   %eax,%eax
  808767:	74 0f                	je     808778 <tcp_output+0x47>
  808769:	89 c2                	mov    %eax,%edx
    for (; useg->next != NULL; useg = useg->next);
  80876b:	8b 02                	mov    (%edx),%eax
  80876d:	85 c0                	test   %eax,%eax
  80876f:	74 04                	je     808775 <tcp_output+0x44>
  808771:	89 c2                	mov    %eax,%edx
  808773:	eb f6                	jmp    80876b <tcp_output+0x3a>
  808775:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808778:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  80877c:	74 20                	je     80879e <tcp_output+0x6d>
  80877e:	85 db                	test   %ebx,%ebx
  808780:	74 27                	je     8087a9 <tcp_output+0x78>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  808782:	8b 43 10             	mov    0x10(%ebx),%eax
  808785:	8b 40 04             	mov    0x4(%eax),%eax
  808788:	89 04 24             	mov    %eax,(%esp)
  80878b:	e8 0a f8 ff ff       	call   807f9a <ntohl>
  808790:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808794:	2b 57 48             	sub    0x48(%edi),%edx
  808797:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  808799:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  80879c:	72 0b                	jb     8087a9 <tcp_output+0x78>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80879e:	8d 47 04             	lea    0x4(%edi),%eax
  8087a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8087a4:	e9 92 03 00 00       	jmp    808b3b <tcp_output+0x40a>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8087a9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8087b0:	00 
  8087b1:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8087b8:	00 
  8087b9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8087c0:	e8 f0 c6 ff ff       	call   804eb5 <pbuf_alloc>
  8087c5:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8087c7:	85 c0                	test   %eax,%eax
  8087c9:	0f 84 d4 03 00 00    	je     808ba3 <tcp_output+0x472>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8087cf:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  8087d3:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  8087d6:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8087da:	89 04 24             	mov    %eax,(%esp)
  8087dd:	e8 64 f5 ff ff       	call   807d46 <htons>
  8087e2:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  8087e5:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8087e9:	89 04 24             	mov    %eax,(%esp)
  8087ec:	e8 55 f5 ff ff       	call   807d46 <htons>
  8087f1:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8087f5:	8b 47 54             	mov    0x54(%edi),%eax
  8087f8:	89 04 24             	mov    %eax,(%esp)
  8087fb:	e8 60 f5 ff ff       	call   807d60 <htonl>
  808800:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  808803:	8b 47 24             	mov    0x24(%edi),%eax
  808806:	89 04 24             	mov    %eax,(%esp)
  808809:	e8 52 f5 ff ff       	call   807d60 <htonl>
  80880e:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  808811:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808815:	89 04 24             	mov    %eax,(%esp)
  808818:	e8 36 f5 ff ff       	call   807d53 <ntohs>
  80881d:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808822:	83 c8 10             	or     $0x10,%eax
  808825:	89 04 24             	mov    %eax,(%esp)
  808828:	e8 19 f5 ff ff       	call   807d46 <htons>
  80882d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808831:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808835:	89 04 24             	mov    %eax,(%esp)
  808838:	e8 09 f5 ff ff       	call   807d46 <htons>
  80883d:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808841:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  808847:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80884b:	89 04 24             	mov    %eax,(%esp)
  80884e:	e8 00 f5 ff ff       	call   807d53 <ntohs>
  808853:	83 e0 3f             	and    $0x3f,%eax
  808856:	80 cc 50             	or     $0x50,%ah
  808859:	89 04 24             	mov    %eax,(%esp)
  80885c:	e8 e5 f4 ff ff       	call   807d46 <htons>
  808861:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808865:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80886b:	8d 47 04             	lea    0x4(%edi),%eax
  80886e:	89 c1                	mov    %eax,%ecx
  808870:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808874:	89 44 24 10          	mov    %eax,0x10(%esp)
  808878:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80887f:	00 
  808880:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808883:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808887:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80888b:	89 34 24             	mov    %esi,(%esp)
  80888e:	e8 72 f1 ff ff       	call   807a05 <inet_chksum_pseudo>
  808893:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808897:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80889e:	00 
  80889f:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  8088a3:	89 44 24 10          	mov    %eax,0x10(%esp)
  8088a7:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  8088ab:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8088af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8088b2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8088b6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8088ba:	89 34 24             	mov    %esi,(%esp)
  8088bd:	e8 ce e6 ff ff       	call   806f90 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  8088c2:	89 34 24             	mov    %esi,(%esp)
  8088c5:	e8 0a c5 ff ff       	call   804dd4 <pbuf_free>

    return ERR_OK;
  8088ca:	b8 00 00 00 00       	mov    $0x0,%eax
  8088cf:	e9 e9 02 00 00       	jmp    808bbd <tcp_output+0x48c>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  8088d4:	8b 43 10             	mov    0x10(%ebx),%eax
  8088d7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8088db:	89 04 24             	mov    %eax,(%esp)
  8088de:	e8 70 f4 ff ff       	call   807d53 <ntohs>
  8088e3:	a8 04                	test   $0x4,%al
  8088e5:	74 1c                	je     808903 <tcp_output+0x1d2>
  8088e7:	c7 44 24 08 b7 33 81 	movl   $0x8133b7,0x8(%esp)
  8088ee:	00 
  8088ef:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  8088f6:	00 
  8088f7:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  8088fe:	e8 37 67 00 00       	call   80f03a <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808903:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808907:	74 1c                	je     808925 <tcp_output+0x1f4>
  808909:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80890d:	a8 40                	test   $0x40,%al
  80890f:	75 14                	jne    808925 <tcp_output+0x1f4>
  808911:	8b 57 74             	mov    0x74(%edi),%edx
  808914:	85 d2                	test   %edx,%edx
  808916:	0f 84 8e 02 00 00    	je     808baa <tcp_output+0x479>
  80891c:	83 3a 00             	cmpl   $0x0,(%edx)
  80891f:	0f 84 85 02 00 00    	je     808baa <tcp_output+0x479>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  808925:	8b 03                	mov    (%ebx),%eax
  808927:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  80892a:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  80892e:	74 25                	je     808955 <tcp_output+0x224>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808930:	8b 73 10             	mov    0x10(%ebx),%esi
  808933:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  808937:	89 04 24             	mov    %eax,(%esp)
  80893a:	e8 14 f4 ff ff       	call   807d53 <ntohs>
  80893f:	83 c8 10             	or     $0x10,%eax
  808942:	0f b7 c0             	movzwl %ax,%eax
  808945:	89 04 24             	mov    %eax,(%esp)
  808948:	e8 f9 f3 ff ff       	call   807d46 <htons>
  80894d:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808951:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  808955:	8b 73 10             	mov    0x10(%ebx),%esi
  808958:	8b 47 24             	mov    0x24(%edi),%eax
  80895b:	89 04 24             	mov    %eax,(%esp)
  80895e:	e8 fd f3 ff ff       	call   807d60 <htonl>
  808963:	89 46 08             	mov    %eax,0x8(%esi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808966:	8b 73 10             	mov    0x10(%ebx),%esi
  808969:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80896d:	89 04 24             	mov    %eax,(%esp)
  808970:	e8 d1 f3 ff ff       	call   807d46 <htons>
  808975:	66 89 46 0e          	mov    %ax,0xe(%esi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  808979:	85 ff                	test   %edi,%edi
  80897b:	74 05                	je     808982 <tcp_output+0x251>
  80897d:	83 3f 00             	cmpl   $0x0,(%edi)
  808980:	75 27                	jne    8089a9 <tcp_output+0x278>
    netif = ip_route(&(pcb->remote_ip));
  808982:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808985:	89 04 24             	mov    %eax,(%esp)
  808988:	e8 33 e1 ff ff       	call   806ac0 <ip_route>
    if (netif == NULL) {
  80898d:	85 c0                	test   %eax,%eax
  80898f:	0f 84 c1 00 00 00    	je     808a56 <tcp_output+0x325>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808995:	83 f8 fc             	cmp    $0xfffffffc,%eax
  808998:	74 08                	je     8089a2 <tcp_output+0x271>
  80899a:	8b 40 04             	mov    0x4(%eax),%eax
  80899d:	8d 76 00             	lea    0x0(%esi),%esi
  8089a0:	eb 05                	jmp    8089a7 <tcp_output+0x276>
  8089a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8089a7:	89 07                	mov    %eax,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  8089a9:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  8089ae:	75 06                	jne    8089b6 <tcp_output+0x285>
    pcb->rtime = 0;
  8089b0:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  8089b6:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  8089ba:	75 19                	jne    8089d5 <tcp_output+0x2a4>
    pcb->rttest = tcp_ticks;
  8089bc:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  8089c1:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8089c4:	8b 43 10             	mov    0x10(%ebx),%eax
  8089c7:	8b 40 04             	mov    0x4(%eax),%eax
  8089ca:	89 04 24             	mov    %eax,(%esp)
  8089cd:	e8 c8 f5 ff ff       	call   807f9a <ntohl>
  8089d2:	89 47 3c             	mov    %eax,0x3c(%edi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  8089d5:	8b 43 04             	mov    0x4(%ebx),%eax
  8089d8:	8b 53 10             	mov    0x10(%ebx),%edx
  8089db:	2b 50 04             	sub    0x4(%eax),%edx

  seg->p->len -= len;
  8089de:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  8089e2:	8b 43 04             	mov    0x4(%ebx),%eax
  8089e5:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  8089e9:	8b 43 04             	mov    0x4(%ebx),%eax
  8089ec:	8b 53 10             	mov    0x10(%ebx),%edx
  8089ef:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  8089f2:	8b 43 10             	mov    0x10(%ebx),%eax
  8089f5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8089fb:	8b 73 10             	mov    0x10(%ebx),%esi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  8089fe:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808a01:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808a05:	89 54 24 10          	mov    %edx,0x10(%esp)
  808a09:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808a10:	00 
  808a11:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808a14:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808a18:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808a1c:	89 04 24             	mov    %eax,(%esp)
  808a1f:	e8 e1 ef ff ff       	call   807a05 <inet_chksum_pseudo>
  808a24:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808a28:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808a2f:	00 
  808a30:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808a34:	89 44 24 10          	mov    %eax,0x10(%esp)
  808a38:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808a3c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808a40:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808a43:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808a47:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808a4b:	8b 43 04             	mov    0x4(%ebx),%eax
  808a4e:	89 04 24             	mov    %eax,(%esp)
  808a51:	e8 3a e5 ff ff       	call   806f90 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808a56:	8b 43 10             	mov    0x10(%ebx),%eax
  808a59:	8b 40 04             	mov    0x4(%eax),%eax
  808a5c:	89 04 24             	mov    %eax,(%esp)
  808a5f:	e8 36 f5 ff ff       	call   807f9a <ntohl>
  808a64:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808a67:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808a6b:	8b 43 10             	mov    0x10(%ebx),%eax
  808a6e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808a72:	89 04 24             	mov    %eax,(%esp)
  808a75:	e8 d9 f2 ff ff       	call   807d53 <ntohs>
  808a7a:	ba 01 00 00 00       	mov    $0x1,%edx
  808a7f:	a8 01                	test   $0x1,%al
  808a81:	75 17                	jne    808a9a <tcp_output+0x369>
  808a83:	8b 43 10             	mov    0x10(%ebx),%eax
  808a86:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808a8a:	89 04 24             	mov    %eax,(%esp)
  808a8d:	e8 c1 f2 ff ff       	call   807d53 <ntohs>
  808a92:	66 d1 e8             	shr    %ax
  808a95:	89 c2                	mov    %eax,%edx
  808a97:	83 e2 01             	and    $0x1,%edx
  808a9a:	01 d6                	add    %edx,%esi
  808a9c:	03 75 e0             	add    -0x20(%ebp),%esi
  808a9f:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  808aa2:	39 77 58             	cmp    %esi,0x58(%edi)
  808aa5:	79 03                	jns    808aaa <tcp_output+0x379>
      pcb->snd_max = pcb->snd_nxt;
  808aa7:	89 77 58             	mov    %esi,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  808aaa:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808aae:	8b 43 10             	mov    0x10(%ebx),%eax
  808ab1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808ab5:	89 04 24             	mov    %eax,(%esp)
  808ab8:	e8 96 f2 ff ff       	call   807d53 <ntohs>
  808abd:	ba 01 00 00 00       	mov    $0x1,%edx
  808ac2:	a8 01                	test   $0x1,%al
  808ac4:	75 17                	jne    808add <tcp_output+0x3ac>
  808ac6:	8b 43 10             	mov    0x10(%ebx),%eax
  808ac9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808acd:	89 04 24             	mov    %eax,(%esp)
  808ad0:	e8 7e f2 ff ff       	call   807d53 <ntohs>
  808ad5:	66 d1 e8             	shr    %ax
  808ad8:	89 c2                	mov    %eax,%edx
  808ada:	83 e2 01             	and    $0x1,%edx
  808add:	01 d6                	add    %edx,%esi
  808adf:	85 f6                	test   %esi,%esi
  808ae1:	7e 4d                	jle    808b30 <tcp_output+0x3ff>
      seg->next = NULL;
  808ae3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  808ae9:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808aed:	75 08                	jne    808af7 <tcp_output+0x3c6>
        pcb->unacked = seg;
  808aef:	89 5f 78             	mov    %ebx,0x78(%edi)
  808af2:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808af5:	eb 41                	jmp    808b38 <tcp_output+0x407>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808af7:	8b 43 10             	mov    0x10(%ebx),%eax
  808afa:	8b 40 04             	mov    0x4(%eax),%eax
  808afd:	89 04 24             	mov    %eax,(%esp)
  808b00:	e8 95 f4 ff ff       	call   807f9a <ntohl>
  808b05:	89 c6                	mov    %eax,%esi
  808b07:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808b0a:	8b 40 10             	mov    0x10(%eax),%eax
  808b0d:	8b 40 04             	mov    0x4(%eax),%eax
  808b10:	89 04 24             	mov    %eax,(%esp)
  808b13:	e8 82 f4 ff ff       	call   807f9a <ntohl>
  808b18:	39 c6                	cmp    %eax,%esi
  808b1a:	79 0a                	jns    808b26 <tcp_output+0x3f5>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  808b1c:	8b 47 78             	mov    0x78(%edi),%eax
  808b1f:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808b21:	89 5f 78             	mov    %ebx,0x78(%edi)
  808b24:	eb 12                	jmp    808b38 <tcp_output+0x407>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  808b26:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808b29:	89 18                	mov    %ebx,(%eax)
  808b2b:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808b2e:	eb 08                	jmp    808b38 <tcp_output+0x407>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  808b30:	89 1c 24             	mov    %ebx,(%esp)
  808b33:	e8 71 d2 ff ff       	call   805da9 <tcp_seg_free>
    }
    seg = pcb->unsent;
  808b38:	8b 5f 74             	mov    0x74(%edi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808b3b:	85 db                	test   %ebx,%ebx
  808b3d:	74 52                	je     808b91 <tcp_output+0x460>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808b3f:	8b 43 10             	mov    0x10(%ebx),%eax
  808b42:	8b 40 04             	mov    0x4(%eax),%eax
  808b45:	89 04 24             	mov    %eax,(%esp)
  808b48:	e8 4d f4 ff ff       	call   807f9a <ntohl>
  808b4d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808b51:	2b 57 48             	sub    0x48(%edi),%edx
  808b54:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808b56:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808b59:	0f 83 75 fd ff ff    	jae    8088d4 <tcp_output+0x1a3>
  808b5f:	eb 51                	jmp    808bb2 <tcp_output+0x481>
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808b61:	8b 43 10             	mov    0x10(%ebx),%eax
  808b64:	8b 40 04             	mov    0x4(%eax),%eax
  808b67:	89 04 24             	mov    %eax,(%esp)
  808b6a:	e8 2b f4 ff ff       	call   807f9a <ntohl>
  808b6f:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808b73:	2b 57 48             	sub    0x48(%edi),%edx
  808b76:	01 c2                	add    %eax,%edx
  808b78:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808b7c:	39 c2                	cmp    %eax,%edx
  808b7e:	76 11                	jbe    808b91 <tcp_output+0x460>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  808b80:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808b87:	00 00 00 
    pcb->persist_backoff = 1;
  808b8a:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  808b91:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808b95:	b8 00 00 00 00       	mov    $0x0,%eax
  808b9a:	eb 21                	jmp    808bbd <tcp_output+0x48c>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  808b9c:	b8 00 00 00 00       	mov    $0x0,%eax
  808ba1:	eb 1a                	jmp    808bbd <tcp_output+0x48c>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  808ba3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808ba8:	eb 13                	jmp    808bbd <tcp_output+0x48c>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808baa:	a8 a0                	test   $0xa0,%al
  808bac:	0f 85 73 fd ff ff    	jne    808925 <tcp_output+0x1f4>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808bb2:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  808bb9:	75 d6                	jne    808b91 <tcp_output+0x460>
  808bbb:	eb a4                	jmp    808b61 <tcp_output+0x430>
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  808bbd:	83 c4 3c             	add    $0x3c,%esp
  808bc0:	5b                   	pop    %ebx
  808bc1:	5e                   	pop    %esi
  808bc2:	5f                   	pop    %edi
  808bc3:	5d                   	pop    %ebp
  808bc4:	c3                   	ret    

00808bc5 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808bc5:	55                   	push   %ebp
  808bc6:	89 e5                	mov    %esp,%ebp
  808bc8:	57                   	push   %edi
  808bc9:	56                   	push   %esi
  808bca:	53                   	push   %ebx
  808bcb:	83 ec 2c             	sub    $0x2c,%esp
  808bce:	8b 7d 18             	mov    0x18(%ebp),%edi
  808bd1:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808bd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808bd7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808bde:	00 
  808bdf:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808be6:	00 
  808be7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808bee:	e8 c2 c2 ff ff       	call   804eb5 <pbuf_alloc>
  808bf3:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  808bf5:	85 c0                	test   %eax,%eax
  808bf7:	0f 84 1a 01 00 00    	je     808d17 <tcp_rst+0x152>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808bfd:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808c02:	77 1c                	ja     808c20 <tcp_rst+0x5b>
  808c04:	c7 44 24 08 50 33 81 	movl   $0x813350,0x8(%esp)
  808c0b:	00 
  808c0c:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  808c13:	00 
  808c14:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  808c1b:	e8 1a 64 00 00       	call   80f03a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808c20:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  808c23:	0f b7 ff             	movzwl %di,%edi
  808c26:	89 3c 24             	mov    %edi,(%esp)
  808c29:	e8 18 f1 ff ff       	call   807d46 <htons>
  808c2e:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  808c31:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808c35:	89 04 24             	mov    %eax,(%esp)
  808c38:	e8 09 f1 ff ff       	call   807d46 <htons>
  808c3d:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  808c41:	8b 45 08             	mov    0x8(%ebp),%eax
  808c44:	89 04 24             	mov    %eax,(%esp)
  808c47:	e8 14 f1 ff ff       	call   807d60 <htonl>
  808c4c:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808c4f:	8b 45 0c             	mov    0xc(%ebp),%eax
  808c52:	89 04 24             	mov    %eax,(%esp)
  808c55:	e8 06 f1 ff ff       	call   807d60 <htonl>
  808c5a:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808c5d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808c61:	89 04 24             	mov    %eax,(%esp)
  808c64:	e8 ea f0 ff ff       	call   807d53 <ntohs>
  808c69:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808c6e:	83 c8 14             	or     $0x14,%eax
  808c71:	89 04 24             	mov    %eax,(%esp)
  808c74:	e8 cd f0 ff ff       	call   807d46 <htons>
  808c79:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808c7d:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808c84:	e8 bd f0 ff ff       	call   807d46 <htons>
  808c89:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808c8d:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808c93:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808c97:	89 04 24             	mov    %eax,(%esp)
  808c9a:	e8 b4 f0 ff ff       	call   807d53 <ntohs>
  808c9f:	83 e0 3f             	and    $0x3f,%eax
  808ca2:	80 cc 50             	or     $0x50,%ah
  808ca5:	89 04 24             	mov    %eax,(%esp)
  808ca8:	e8 99 f0 ff ff       	call   807d46 <htons>
  808cad:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808cb1:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808cb7:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808cbb:	89 44 24 10          	mov    %eax,0x10(%esp)
  808cbf:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808cc6:	00 
  808cc7:	8b 45 14             	mov    0x14(%ebp),%eax
  808cca:	89 44 24 08          	mov    %eax,0x8(%esp)
  808cce:	8b 45 10             	mov    0x10(%ebp),%eax
  808cd1:	89 44 24 04          	mov    %eax,0x4(%esp)
  808cd5:	89 34 24             	mov    %esi,(%esp)
  808cd8:	e8 28 ed ff ff       	call   807a05 <inet_chksum_pseudo>
  808cdd:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808ce1:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808ce8:	00 
  808ce9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808cf0:	00 
  808cf1:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  808cf8:	00 
  808cf9:	8b 45 14             	mov    0x14(%ebp),%eax
  808cfc:	89 44 24 08          	mov    %eax,0x8(%esp)
  808d00:	8b 45 10             	mov    0x10(%ebp),%eax
  808d03:	89 44 24 04          	mov    %eax,0x4(%esp)
  808d07:	89 34 24             	mov    %esi,(%esp)
  808d0a:	e8 81 e2 ff ff       	call   806f90 <ip_output>
  pbuf_free(p);
  808d0f:	89 34 24             	mov    %esi,(%esp)
  808d12:	e8 bd c0 ff ff       	call   804dd4 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  808d17:	83 c4 2c             	add    $0x2c,%esp
  808d1a:	5b                   	pop    %ebx
  808d1b:	5e                   	pop    %esi
  808d1c:	5f                   	pop    %edi
  808d1d:	5d                   	pop    %ebp
  808d1e:	c3                   	ret    

00808d1f <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  808d1f:	55                   	push   %ebp
  808d20:	89 e5                	mov    %esp,%ebp
  808d22:	53                   	push   %ebx
  808d23:	83 ec 14             	sub    $0x14,%esp
  808d26:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808d29:	8b 53 78             	mov    0x78(%ebx),%edx
  808d2c:	85 d2                	test   %edx,%edx
  808d2e:	74 40                	je     808d70 <tcp_rexmit_rto+0x51>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  808d30:	8b 02                	mov    (%edx),%eax
  808d32:	85 c0                	test   %eax,%eax
  808d34:	74 04                	je     808d3a <tcp_rexmit_rto+0x1b>
  808d36:	89 c2                	mov    %eax,%edx
  808d38:	eb f6                	jmp    808d30 <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  808d3a:	8b 43 74             	mov    0x74(%ebx),%eax
  808d3d:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  808d3f:	8b 43 78             	mov    0x78(%ebx),%eax
  808d42:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  808d45:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808d4c:	8b 40 10             	mov    0x10(%eax),%eax
  808d4f:	8b 40 04             	mov    0x4(%eax),%eax
  808d52:	89 04 24             	mov    %eax,(%esp)
  808d55:	e8 40 f2 ff ff       	call   807f9a <ntohl>
  808d5a:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  808d5d:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  808d61:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808d68:	89 1c 24             	mov    %ebx,(%esp)
  808d6b:	e8 c1 f9 ff ff       	call   808731 <tcp_output>
}
  808d70:	83 c4 14             	add    $0x14,%esp
  808d73:	5b                   	pop    %ebx
  808d74:	5d                   	pop    %ebp
  808d75:	c3                   	ret    

00808d76 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808d76:	55                   	push   %ebp
  808d77:	89 e5                	mov    %esp,%ebp
  808d79:	53                   	push   %ebx
  808d7a:	83 ec 14             	sub    $0x14,%esp
  808d7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808d80:	8b 43 78             	mov    0x78(%ebx),%eax
  808d83:	85 c0                	test   %eax,%eax
  808d85:	74 34                	je     808dbb <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808d87:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808d89:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808d8c:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808d8e:	8b 43 78             	mov    0x78(%ebx),%eax
  808d91:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808d94:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808d97:	8b 40 10             	mov    0x10(%eax),%eax
  808d9a:	8b 40 04             	mov    0x4(%eax),%eax
  808d9d:	89 04 24             	mov    %eax,(%esp)
  808da0:	e8 f5 f1 ff ff       	call   807f9a <ntohl>
  808da5:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808da8:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808dac:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808db3:	89 1c 24             	mov    %ebx,(%esp)
  808db6:	e8 76 f9 ff ff       	call   808731 <tcp_output>
}
  808dbb:	83 c4 14             	add    $0x14,%esp
  808dbe:	5b                   	pop    %ebx
  808dbf:	5d                   	pop    %ebp
  808dc0:	c3                   	ret    

00808dc1 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808dc1:	55                   	push   %ebp
  808dc2:	89 e5                	mov    %esp,%ebp
  808dc4:	57                   	push   %edi
  808dc5:	56                   	push   %esi
  808dc6:	53                   	push   %ebx
  808dc7:	83 ec 2c             	sub    $0x2c,%esp
  808dca:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808dcd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808dd4:	00 
  808dd5:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808ddc:	00 
  808ddd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808de4:	e8 cc c0 ff ff       	call   804eb5 <pbuf_alloc>
  808de9:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808deb:	85 c0                	test   %eax,%eax
  808ded:	0f 84 1a 01 00 00    	je     808f0d <tcp_keepalive+0x14c>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808df3:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808df8:	77 1c                	ja     808e16 <tcp_keepalive+0x55>
  808dfa:	c7 44 24 08 50 33 81 	movl   $0x813350,0x8(%esp)
  808e01:	00 
  808e02:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  808e09:	00 
  808e0a:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  808e11:	e8 24 62 00 00       	call   80f03a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808e16:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808e19:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808e1d:	89 04 24             	mov    %eax,(%esp)
  808e20:	e8 21 ef ff ff       	call   807d46 <htons>
  808e25:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808e28:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808e2c:	89 04 24             	mov    %eax,(%esp)
  808e2f:	e8 12 ef ff ff       	call   807d46 <htons>
  808e34:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  808e38:	8b 46 54             	mov    0x54(%esi),%eax
  808e3b:	83 e8 01             	sub    $0x1,%eax
  808e3e:	89 04 24             	mov    %eax,(%esp)
  808e41:	e8 1a ef ff ff       	call   807d60 <htonl>
  808e46:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808e49:	8b 46 24             	mov    0x24(%esi),%eax
  808e4c:	89 04 24             	mov    %eax,(%esp)
  808e4f:	e8 0c ef ff ff       	call   807d60 <htonl>
  808e54:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808e57:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808e5b:	89 04 24             	mov    %eax,(%esp)
  808e5e:	e8 f0 ee ff ff       	call   807d53 <ntohs>
  808e63:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808e68:	89 04 24             	mov    %eax,(%esp)
  808e6b:	e8 d6 ee ff ff       	call   807d46 <htons>
  808e70:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808e74:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808e78:	89 04 24             	mov    %eax,(%esp)
  808e7b:	e8 c6 ee ff ff       	call   807d46 <htons>
  808e80:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808e84:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808e8a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808e8e:	89 04 24             	mov    %eax,(%esp)
  808e91:	e8 bd ee ff ff       	call   807d53 <ntohs>
  808e96:	83 e0 3f             	and    $0x3f,%eax
  808e99:	80 cc 50             	or     $0x50,%ah
  808e9c:	89 04 24             	mov    %eax,(%esp)
  808e9f:	e8 a2 ee ff ff       	call   807d46 <htons>
  808ea4:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808ea8:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808eae:	8d 46 04             	lea    0x4(%esi),%eax
  808eb1:	89 c2                	mov    %eax,%edx
  808eb3:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808eb7:	89 44 24 10          	mov    %eax,0x10(%esp)
  808ebb:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808ec2:	00 
  808ec3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808ec6:	89 54 24 08          	mov    %edx,0x8(%esp)
  808eca:	89 74 24 04          	mov    %esi,0x4(%esp)
  808ece:	89 3c 24             	mov    %edi,(%esp)
  808ed1:	e8 2f eb ff ff       	call   807a05 <inet_chksum_pseudo>
  808ed6:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808eda:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808ee1:	00 
  808ee2:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808ee9:	00 
  808eea:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808eee:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808ef2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808ef5:	89 44 24 08          	mov    %eax,0x8(%esp)
  808ef9:	89 74 24 04          	mov    %esi,0x4(%esp)
  808efd:	89 3c 24             	mov    %edi,(%esp)
  808f00:	e8 8b e0 ff ff       	call   806f90 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808f05:	89 3c 24             	mov    %edi,(%esp)
  808f08:	e8 c7 be ff ff       	call   804dd4 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808f0d:	83 c4 2c             	add    $0x2c,%esp
  808f10:	5b                   	pop    %ebx
  808f11:	5e                   	pop    %esi
  808f12:	5f                   	pop    %edi
  808f13:	5d                   	pop    %ebp
  808f14:	c3                   	ret    

00808f15 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808f15:	55                   	push   %ebp
  808f16:	89 e5                	mov    %esp,%ebp
  808f18:	57                   	push   %edi
  808f19:	56                   	push   %esi
  808f1a:	53                   	push   %ebx
  808f1b:	83 ec 2c             	sub    $0x2c,%esp
  808f1e:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808f21:	8b 46 78             	mov    0x78(%esi),%eax
  808f24:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808f27:	85 c0                	test   %eax,%eax
  808f29:	75 0e                	jne    808f39 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  808f2b:	8b 46 74             	mov    0x74(%esi),%eax
  808f2e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808f31:	85 c0                	test   %eax,%eax
  808f33:	0f 84 4a 01 00 00    	je     809083 <tcp_zero_window_probe+0x16e>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808f39:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808f40:	00 
  808f41:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  808f48:	00 
  808f49:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808f50:	e8 60 bf ff ff       	call   804eb5 <pbuf_alloc>
  808f55:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808f57:	85 c0                	test   %eax,%eax
  808f59:	0f 84 24 01 00 00    	je     809083 <tcp_zero_window_probe+0x16e>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808f5f:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808f64:	77 1c                	ja     808f82 <tcp_zero_window_probe+0x6d>
  808f66:	c7 44 24 08 50 33 81 	movl   $0x813350,0x8(%esp)
  808f6d:	00 
  808f6e:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  808f75:	00 
  808f76:	c7 04 24 7e 33 81 00 	movl   $0x81337e,(%esp)
  808f7d:	e8 b8 60 00 00       	call   80f03a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808f82:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808f85:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808f89:	89 04 24             	mov    %eax,(%esp)
  808f8c:	e8 b5 ed ff ff       	call   807d46 <htons>
  808f91:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808f94:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808f98:	89 04 24             	mov    %eax,(%esp)
  808f9b:	e8 a6 ed ff ff       	call   807d46 <htons>
  808fa0:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808fa4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808fa7:	8b 40 10             	mov    0x10(%eax),%eax
  808faa:	8b 40 04             	mov    0x4(%eax),%eax
  808fad:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808fb0:	8b 46 24             	mov    0x24(%esi),%eax
  808fb3:	89 04 24             	mov    %eax,(%esp)
  808fb6:	e8 a5 ed ff ff       	call   807d60 <htonl>
  808fbb:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808fbe:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808fc2:	89 04 24             	mov    %eax,(%esp)
  808fc5:	e8 89 ed ff ff       	call   807d53 <ntohs>
  808fca:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808fcf:	89 04 24             	mov    %eax,(%esp)
  808fd2:	e8 6f ed ff ff       	call   807d46 <htons>
  808fd7:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808fdb:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808fdf:	89 04 24             	mov    %eax,(%esp)
  808fe2:	e8 5f ed ff ff       	call   807d46 <htons>
  808fe7:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808feb:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808ff1:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808ff5:	89 04 24             	mov    %eax,(%esp)
  808ff8:	e8 56 ed ff ff       	call   807d53 <ntohs>
  808ffd:	83 e0 3f             	and    $0x3f,%eax
  809000:	80 cc 50             	or     $0x50,%ah
  809003:	89 04 24             	mov    %eax,(%esp)
  809006:	e8 3b ed ff ff       	call   807d46 <htons>
  80900b:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80900f:	8b 47 04             	mov    0x4(%edi),%eax
  809012:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809015:	8b 51 08             	mov    0x8(%ecx),%edx
  809018:	0f b6 12             	movzbl (%edx),%edx
  80901b:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80901e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  809024:	8d 46 04             	lea    0x4(%esi),%eax
  809027:	89 c1                	mov    %eax,%ecx
  809029:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80902d:	89 44 24 10          	mov    %eax,0x10(%esp)
  809031:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  809038:	00 
  809039:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80903c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  809040:	89 74 24 04          	mov    %esi,0x4(%esp)
  809044:	89 3c 24             	mov    %edi,(%esp)
  809047:	e8 b9 e9 ff ff       	call   807a05 <inet_chksum_pseudo>
  80904c:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  809050:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  809057:	00 
  809058:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80905f:	00 
  809060:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  809064:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809068:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80906b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80906f:	89 74 24 04          	mov    %esi,0x4(%esp)
  809073:	89 3c 24             	mov    %edi,(%esp)
  809076:	e8 15 df ff ff       	call   806f90 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80907b:	89 3c 24             	mov    %edi,(%esp)
  80907e:	e8 51 bd ff ff       	call   804dd4 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  809083:	83 c4 2c             	add    $0x2c,%esp
  809086:	5b                   	pop    %ebx
  809087:	5e                   	pop    %esi
  809088:	5f                   	pop    %edi
  809089:	5d                   	pop    %ebp
  80908a:	c3                   	ret    
  80908b:	66 90                	xchg   %ax,%ax
  80908d:	66 90                	xchg   %ax,%ax
  80908f:	90                   	nop

00809090 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  809090:	55                   	push   %ebp
  809091:	89 e5                	mov    %esp,%ebp
  809093:	57                   	push   %edi
  809094:	56                   	push   %esi
  809095:	53                   	push   %ebx
  809096:	83 ec 3c             	sub    $0x3c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  809099:	8b 45 08             	mov    0x8(%ebp),%eax
  80909c:	8b 40 04             	mov    0x4(%eax),%eax
  80909f:	89 c7                	mov    %eax,%edi
  8090a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  8090a4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8090a7:	0f b7 59 08          	movzwl 0x8(%ecx),%ebx
  8090ab:	0f b7 00             	movzwl (%eax),%eax
  8090ae:	89 04 24             	mov    %eax,(%esp)
  8090b1:	e8 9d ec ff ff       	call   807d53 <ntohs>
  8090b6:	66 c1 e8 08          	shr    $0x8,%ax
  8090ba:	83 e0 0f             	and    $0xf,%eax
  8090bd:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  8090c4:	39 c3                	cmp    %eax,%ebx
  8090c6:	7c 28                	jl     8090f0 <udp_input+0x60>
  8090c8:	0f b7 07             	movzwl (%edi),%eax
  8090cb:	89 04 24             	mov    %eax,(%esp)
  8090ce:	e8 80 ec ff ff       	call   807d53 <ntohs>
  8090d3:	66 c1 e8 06          	shr    $0x6,%ax
  8090d7:	83 e0 3c             	and    $0x3c,%eax
  8090da:	f7 d8                	neg    %eax
  8090dc:	98                   	cwtl   
  8090dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8090e1:	8b 45 08             	mov    0x8(%ebp),%eax
  8090e4:	89 04 24             	mov    %eax,(%esp)
  8090e7:	e8 04 bc ff ff       	call   804cf0 <pbuf_header>
  8090ec:	84 c0                	test   %al,%al
  8090ee:	74 10                	je     809100 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  8090f0:	8b 45 08             	mov    0x8(%ebp),%eax
  8090f3:	89 04 24             	mov    %eax,(%esp)
  8090f6:	e8 d9 bc ff ff       	call   804dd4 <pbuf_free>
    goto end;
  8090fb:	e9 09 03 00 00       	jmp    809409 <udp_input+0x379>
  }

  udphdr = (struct udp_hdr *)p->payload;
  809100:	8b 45 08             	mov    0x8(%ebp),%eax
  809103:	8b 40 04             	mov    0x4(%eax),%eax
  809106:	89 c6                	mov    %eax,%esi
  809108:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80910b:	0f b7 00             	movzwl (%eax),%eax
  80910e:	89 04 24             	mov    %eax,(%esp)
  809111:	e8 3d ec ff ff       	call   807d53 <ntohs>
  809116:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  dest = ntohs(udphdr->dest);
  80911a:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80911e:	89 04 24             	mov    %eax,(%esp)
  809121:	e8 2d ec ff ff       	call   807d53 <ntohs>
  809126:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  809128:	66 83 f8 44          	cmp    $0x44,%ax
  80912c:	75 5a                	jne    809188 <udp_input+0xf8>
  80912e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  809135:	66 83 7d de 43       	cmpw   $0x43,-0x22(%ebp)
  80913a:	0f 85 14 01 00 00    	jne    809254 <udp_input+0x1c4>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  809140:	8b 45 0c             	mov    0xc(%ebp),%eax
  809143:	8b 40 20             	mov    0x20(%eax),%eax
  809146:	85 c0                	test   %eax,%eax
  809148:	0f 84 ff 00 00 00    	je     80924d <udp_input+0x1bd>
  80914e:	8b 40 08             	mov    0x8(%eax),%eax
  809151:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809154:	85 c0                	test   %eax,%eax
  809156:	0f 84 f8 00 00 00    	je     809254 <udp_input+0x1c4>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80915c:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80915f:	0f 84 01 01 00 00    	je     809266 <udp_input+0x1d6>
  809165:	8b 40 04             	mov    0x4(%eax),%eax
  809168:	85 c0                	test   %eax,%eax
  80916a:	0f 84 f6 00 00 00    	je     809266 <udp_input+0x1d6>
  809170:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809173:	3b 41 0c             	cmp    0xc(%ecx),%eax
  809176:	0f 84 ea 00 00 00    	je     809266 <udp_input+0x1d6>
  80917c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  809183:	e9 cc 00 00 00       	jmp    809254 <udp_input+0x1c4>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  809188:	8b 1d 74 c2 b3 00    	mov    0xb3c274,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  80918e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  809195:	bf 00 00 00 00       	mov    $0x0,%edi
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80919a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80919d:	83 c0 10             	add    $0x10,%eax
  8091a0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8091a3:	e9 95 00 00 00       	jmp    80923d <udp_input+0x1ad>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8091a8:	66 39 73 12          	cmp    %si,0x12(%ebx)
  8091ac:	0f 85 86 00 00 00    	jne    809238 <udp_input+0x1a8>
  8091b2:	85 db                	test   %ebx,%ebx
  8091b4:	74 24                	je     8091da <udp_input+0x14a>
          (ip_addr_isany(&pcb->local_ip) ||
  8091b6:	8b 03                	mov    (%ebx),%eax
  8091b8:	85 c0                	test   %eax,%eax
  8091ba:	74 1e                	je     8091da <udp_input+0x14a>
  8091bc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8091bf:	3b 41 10             	cmp    0x10(%ecx),%eax
  8091c2:	74 16                	je     8091da <udp_input+0x14a>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8091c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8091c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8091cb:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8091ce:	89 04 24             	mov    %eax,(%esp)
  8091d1:	e8 9b d8 ff ff       	call   806a71 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  8091d6:	84 c0                	test   %al,%al
  8091d8:	74 5e                	je     809238 <udp_input+0x1a8>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8091da:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8091de:	0f 85 0a 02 00 00    	jne    8093ee <udp_input+0x35e>
  8091e4:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  8091e8:	83 e0 04             	and    $0x4,%eax
  8091eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8091ee:	0f 44 c3             	cmove  %ebx,%eax
  8091f1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8091f4:	e9 f5 01 00 00       	jmp    8093ee <udp_input+0x35e>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  8091f9:	83 fb fc             	cmp    $0xfffffffc,%ebx
  8091fc:	74 13                	je     809211 <udp_input+0x181>
          (ip_addr_isany(&pcb->remote_ip) ||
  8091fe:	8b 43 04             	mov    0x4(%ebx),%eax
  809201:	85 c0                	test   %eax,%eax
  809203:	74 10                	je     809215 <udp_input+0x185>
  809205:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809208:	3b 42 0c             	cmp    0xc(%edx),%eax
  80920b:	75 2b                	jne    809238 <udp_input+0x1a8>
  80920d:	89 d8                	mov    %ebx,%eax
  80920f:	eb 06                	jmp    809217 <udp_input+0x187>
  809211:	89 d8                	mov    %ebx,%eax
  809213:	eb 02                	jmp    809217 <udp_input+0x187>
  809215:	89 d8                	mov    %ebx,%eax
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  809217:	85 ff                	test   %edi,%edi
  809219:	0f 84 e2 01 00 00    	je     809401 <udp_input+0x371>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80921f:	8b 50 0c             	mov    0xc(%eax),%edx
  809222:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  809225:	8b 15 74 c2 b3 00    	mov    0xb3c274,%edx
  80922b:	89 50 0c             	mov    %edx,0xc(%eax)
          udp_pcbs = pcb;
  80922e:	a3 74 c2 b3 00       	mov    %eax,0xb3c274
  809233:	e9 c9 01 00 00       	jmp    809401 <udp_input+0x371>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  809238:	89 df                	mov    %ebx,%edi
  80923a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80923d:	85 db                	test   %ebx,%ebx
  80923f:	0f 85 63 ff ff ff    	jne    8091a8 <udp_input+0x118>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  809245:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  809249:	75 1b                	jne    809266 <udp_input+0x1d6>
  80924b:	eb 07                	jmp    809254 <udp_input+0x1c4>
  80924d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  809254:	8b 45 0c             	mov    0xc(%ebp),%eax
  809257:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80925a:	8b 49 10             	mov    0x10(%ecx),%ecx
  80925d:	39 48 04             	cmp    %ecx,0x4(%eax)
  809260:	0f 85 7b 01 00 00    	jne    8093e1 <udp_input+0x351>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  809266:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  809269:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80926e:	74 48                	je     8092b8 <udp_input+0x228>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  809270:	8b 45 08             	mov    0x8(%ebp),%eax
  809273:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  809277:	89 44 24 10          	mov    %eax,0x10(%esp)
  80927b:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  809282:	00 
  809283:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809286:	89 d0                	mov    %edx,%eax
  809288:	83 c0 10             	add    $0x10,%eax
  80928b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80928f:	89 d0                	mov    %edx,%eax
  809291:	83 c0 0c             	add    $0xc,%eax
  809294:	89 44 24 04          	mov    %eax,0x4(%esp)
  809298:	8b 45 08             	mov    0x8(%ebp),%eax
  80929b:	89 04 24             	mov    %eax,(%esp)
  80929e:	e8 62 e7 ff ff       	call   807a05 <inet_chksum_pseudo>
  8092a3:	66 85 c0             	test   %ax,%ax
  8092a6:	74 10                	je     8092b8 <udp_input+0x228>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  8092a8:	8b 45 08             	mov    0x8(%ebp),%eax
  8092ab:	89 04 24             	mov    %eax,(%esp)
  8092ae:	e8 21 bb ff ff       	call   804dd4 <pbuf_free>
          goto end;
  8092b3:	e9 51 01 00 00       	jmp    809409 <udp_input+0x379>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  8092b8:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  8092bf:	ff 
  8092c0:	8b 45 08             	mov    0x8(%ebp),%eax
  8092c3:	89 04 24             	mov    %eax,(%esp)
  8092c6:	e8 25 ba ff ff       	call   804cf0 <pbuf_header>
  8092cb:	84 c0                	test   %al,%al
  8092cd:	74 1c                	je     8092eb <udp_input+0x25b>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8092cf:	c7 44 24 08 a3 33 81 	movl   $0x8133a3,0x8(%esp)
  8092d6:	00 
  8092d7:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  8092de:	00 
  8092df:	c7 04 24 ce 33 81 00 	movl   $0x8133ce,(%esp)
  8092e6:	e8 4f 5d 00 00       	call   80f03a <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  8092eb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8092ee:	85 c9                	test   %ecx,%ecx
  8092f0:	74 43                	je     809335 <udp_input+0x2a5>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  8092f2:	8b 41 18             	mov    0x18(%ecx),%eax
  8092f5:	85 c0                	test   %eax,%eax
  8092f7:	74 2a                	je     809323 <udp_input+0x293>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  8092f9:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  8092fd:	89 54 24 10          	mov    %edx,0x10(%esp)
  809301:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809304:	83 c2 0c             	add    $0xc,%edx
  809307:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80930b:	8b 55 08             	mov    0x8(%ebp),%edx
  80930e:	89 54 24 08          	mov    %edx,0x8(%esp)
  809312:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  809316:	8b 51 1c             	mov    0x1c(%ecx),%edx
  809319:	89 14 24             	mov    %edx,(%esp)
  80931c:	ff d0                	call   *%eax
  80931e:	e9 e6 00 00 00       	jmp    809409 <udp_input+0x379>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  809323:	8b 45 08             	mov    0x8(%ebp),%eax
  809326:	89 04 24             	mov    %eax,(%esp)
  809329:	e8 a6 ba ff ff       	call   804dd4 <pbuf_free>
        goto end;
  80932e:	66 90                	xchg   %ax,%ax
  809330:	e9 d4 00 00 00       	jmp    809409 <udp_input+0x379>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  809335:	8b 45 0c             	mov    0xc(%ebp),%eax
  809338:	89 44 24 04          	mov    %eax,0x4(%esp)
  80933c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80933f:	89 f0                	mov    %esi,%eax
  809341:	83 c0 10             	add    $0x10,%eax
  809344:	89 04 24             	mov    %eax,(%esp)
  809347:	e8 25 d7 ff ff       	call   806a71 <ip_addr_isbroadcast>
  80934c:	84 c0                	test   %al,%al
  80934e:	0f 85 80 00 00 00    	jne    8093d4 <udp_input+0x344>
          !ip_addr_ismulticast(&iphdr->dest)) {
  809354:	8b 5e 10             	mov    0x10(%esi),%ebx
  809357:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80935e:	e8 37 ec ff ff       	call   807f9a <ntohl>
  809363:	21 c3                	and    %eax,%ebx
  809365:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80936c:	e8 29 ec ff ff       	call   807f9a <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  809371:	39 c3                	cmp    %eax,%ebx
  809373:	74 5f                	je     8093d4 <udp_input+0x344>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  809375:	0f b7 06             	movzwl (%esi),%eax
  809378:	89 04 24             	mov    %eax,(%esp)
  80937b:	e8 d3 e9 ff ff       	call   807d53 <ntohs>
  809380:	66 c1 e8 08          	shr    $0x8,%ax
  809384:	83 e0 0f             	and    $0xf,%eax
  809387:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80938e:	89 44 24 04          	mov    %eax,0x4(%esp)
  809392:	8b 45 08             	mov    0x8(%ebp),%eax
  809395:	89 04 24             	mov    %eax,(%esp)
  809398:	e8 53 b9 ff ff       	call   804cf0 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80939d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8093a0:	39 71 04             	cmp    %esi,0x4(%ecx)
  8093a3:	74 1c                	je     8093c1 <udp_input+0x331>
  8093a5:	c7 44 24 08 e2 33 81 	movl   $0x8133e2,0x8(%esp)
  8093ac:	00 
  8093ad:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  8093b4:	00 
  8093b5:	c7 04 24 ce 33 81 00 	movl   $0x8133ce,(%esp)
  8093bc:	e8 79 5c 00 00       	call   80f03a <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  8093c1:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  8093c8:	00 
  8093c9:	8b 45 08             	mov    0x8(%ebp),%eax
  8093cc:	89 04 24             	mov    %eax,(%esp)
  8093cf:	e8 e1 59 00 00       	call   80edb5 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  8093d4:	8b 45 08             	mov    0x8(%ebp),%eax
  8093d7:	89 04 24             	mov    %eax,(%esp)
  8093da:	e8 f5 b9 ff ff       	call   804dd4 <pbuf_free>
  8093df:	eb 28                	jmp    809409 <udp_input+0x379>
    }
  } else {
    pbuf_free(p);
  8093e1:	8b 45 08             	mov    0x8(%ebp),%eax
  8093e4:	89 04 24             	mov    %eax,(%esp)
  8093e7:	e8 e8 b9 ff ff       	call   804dd4 <pbuf_free>
  8093ec:	eb 1b                	jmp    809409 <udp_input+0x379>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  8093ee:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  8093f2:	66 39 43 14          	cmp    %ax,0x14(%ebx)
  8093f6:	0f 85 3c fe ff ff    	jne    809238 <udp_input+0x1a8>
  8093fc:	e9 f8 fd ff ff       	jmp    8091f9 <udp_input+0x169>
  809401:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  809404:	e9 5d fe ff ff       	jmp    809266 <udp_input+0x1d6>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  809409:	83 c4 3c             	add    $0x3c,%esp
  80940c:	5b                   	pop    %ebx
  80940d:	5e                   	pop    %esi
  80940e:	5f                   	pop    %edi
  80940f:	5d                   	pop    %ebp
  809410:	c3                   	ret    

00809411 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809411:	55                   	push   %ebp
  809412:	89 e5                	mov    %esp,%ebp
  809414:	57                   	push   %edi
  809415:	56                   	push   %esi
  809416:	53                   	push   %ebx
  809417:	83 ec 1c             	sub    $0x1c,%esp
  80941a:	8b 55 08             	mov    0x8(%ebp),%edx
  80941d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  809420:	8b 45 10             	mov    0x10(%ebp),%eax
  809423:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809426:	89 c1                	mov    %eax,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809428:	a1 74 c2 b3 00       	mov    0xb3c274,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  80942d:	be 00 00 00 00       	mov    $0x0,%esi
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809432:	eb 2e                	jmp    809462 <udp_bind+0x51>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  809434:	39 c2                	cmp    %eax,%edx
  809436:	75 27                	jne    80945f <udp_bind+0x4e>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  809438:	89 f3                	mov    %esi,%ebx
  80943a:	84 db                	test   %bl,%bl
  80943c:	74 1c                	je     80945a <udp_bind+0x49>
  80943e:	c7 44 24 08 f6 33 81 	movl   $0x8133f6,0x8(%esp)
  809445:	00 
  809446:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80944d:	00 
  80944e:	c7 04 24 ce 33 81 00 	movl   $0x8133ce,(%esp)
  809455:	e8 e0 5b 00 00       	call   80f03a <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  80945a:	be 01 00 00 00       	mov    $0x1,%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80945f:	8b 40 0c             	mov    0xc(%eax),%eax
  809462:	85 c0                	test   %eax,%eax
  809464:	75 ce                	jne    809434 <udp_bind+0x23>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  809466:	85 ff                	test   %edi,%edi
  809468:	74 04                	je     80946e <udp_bind+0x5d>
  80946a:	8b 07                	mov    (%edi),%eax
  80946c:	eb 05                	jmp    809473 <udp_bind+0x62>
  80946e:	b8 00 00 00 00       	mov    $0x0,%eax
  809473:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  809475:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  80947a:	75 36                	jne    8094b2 <udp_bind+0xa1>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  80947c:	8b 3d 74 c2 b3 00    	mov    0xb3c274,%edi
  809482:	89 f8                	mov    %edi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  809484:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  809489:	eb 13                	jmp    80949e <udp_bind+0x8d>
      if (ipcb->local_port == port) {
  80948b:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  80948f:	66 39 cb             	cmp    %cx,%bx
  809492:	75 07                	jne    80949b <udp_bind+0x8a>
        /* port is already used by another udp_pcb */
        port++;
  809494:	8d 4b 01             	lea    0x1(%ebx),%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  809497:	89 f8                	mov    %edi,%eax
  809499:	eb 03                	jmp    80949e <udp_bind+0x8d>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  80949b:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80949e:	85 c0                	test   %eax,%eax
  8094a0:	0f 95 c3             	setne  %bl
  8094a3:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  8094a8:	74 04                	je     8094ae <udp_bind+0x9d>
  8094aa:	84 db                	test   %bl,%bl
  8094ac:	75 dd                	jne    80948b <udp_bind+0x7a>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  8094ae:	84 db                	test   %bl,%bl
  8094b0:	75 24                	jne    8094d6 <udp_bind+0xc5>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  8094b2:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8094b6:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  8094bb:	89 f1                	mov    %esi,%ecx
  8094bd:	84 c9                	test   %cl,%cl
  8094bf:	75 1a                	jne    8094db <udp_bind+0xca>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  8094c1:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  8094c6:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  8094c9:	89 15 74 c2 b3 00    	mov    %edx,0xb3c274
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8094cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8094d4:	eb 05                	jmp    8094db <udp_bind+0xca>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  8094d6:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  8094db:	83 c4 1c             	add    $0x1c,%esp
  8094de:	5b                   	pop    %ebx
  8094df:	5e                   	pop    %esi
  8094e0:	5f                   	pop    %edi
  8094e1:	5d                   	pop    %ebp
  8094e2:	c3                   	ret    

008094e3 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  8094e3:	55                   	push   %ebp
  8094e4:	89 e5                	mov    %esp,%ebp
  8094e6:	57                   	push   %edi
  8094e7:	56                   	push   %esi
  8094e8:	53                   	push   %ebx
  8094e9:	83 ec 2c             	sub    $0x2c,%esp
  8094ec:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8094ef:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  8094f2:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  8094f7:	75 1c                	jne    809515 <udp_sendto_if+0x32>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  8094f9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809500:	00 
  809501:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809505:	89 1c 24             	mov    %ebx,(%esp)
  809508:	e8 04 ff ff ff       	call   809411 <udp_bind>
    if (err != ERR_OK) {
  80950d:	84 c0                	test   %al,%al
  80950f:	0f 85 76 01 00 00    	jne    80968b <udp_sendto_if+0x1a8>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  809515:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80951c:	00 
  80951d:	8b 45 0c             	mov    0xc(%ebp),%eax
  809520:	89 04 24             	mov    %eax,(%esp)
  809523:	e8 c8 b7 ff ff       	call   804cf0 <pbuf_header>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  809528:	8b 75 0c             	mov    0xc(%ebp),%esi
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80952b:	84 c0                	test   %al,%al
  80952d:	74 35                	je     809564 <udp_sendto_if+0x81>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80952f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809536:	00 
  809537:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80953e:	00 
  80953f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809546:	e8 6a b9 ff ff       	call   804eb5 <pbuf_alloc>
  80954b:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80954d:	85 c0                	test   %eax,%eax
  80954f:	0f 84 31 01 00 00    	je     809686 <udp_sendto_if+0x1a3>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  809555:	8b 45 0c             	mov    0xc(%ebp),%eax
  809558:	89 44 24 04          	mov    %eax,0x4(%esp)
  80955c:	89 34 24             	mov    %esi,(%esp)
  80955f:	e8 a6 bd ff ff       	call   80530a <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  809564:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  809569:	77 1c                	ja     809587 <udp_sendto_if+0xa4>
  80956b:	c7 44 24 08 04 34 81 	movl   $0x813404,0x8(%esp)
  809572:	00 
  809573:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80957a:	00 
  80957b:	c7 04 24 ce 33 81 00 	movl   $0x8133ce,(%esp)
  809582:	e8 b3 5a 00 00       	call   80f03a <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  809587:	8b 46 04             	mov    0x4(%esi),%eax
  80958a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  udphdr->src = htons(pcb->local_port);
  80958d:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  809591:	89 04 24             	mov    %eax,(%esp)
  809594:	e8 ad e7 ff ff       	call   807d46 <htons>
  809599:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80959c:	66 89 01             	mov    %ax,(%ecx)
  udphdr->dest = htons(dst_port);
  80959f:	0f b7 ff             	movzwl %di,%edi
  8095a2:	89 3c 24             	mov    %edi,(%esp)
  8095a5:	e8 9c e7 ff ff       	call   807d46 <htons>
  8095aa:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8095ad:	66 89 41 02          	mov    %ax,0x2(%ecx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  8095b1:	66 c7 41 06 00 00    	movw   $0x0,0x6(%ecx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  8095b7:	89 df                	mov    %ebx,%edi
  8095b9:	85 db                	test   %ebx,%ebx
  8095bb:	74 06                	je     8095c3 <udp_sendto_if+0xe0>
  8095bd:	8b 03                	mov    (%ebx),%eax
  8095bf:	85 c0                	test   %eax,%eax
  8095c1:	75 08                	jne    8095cb <udp_sendto_if+0xe8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  8095c3:	8b 45 18             	mov    0x18(%ebp),%eax
  8095c6:	8d 78 04             	lea    0x4(%eax),%edi
  8095c9:	eb 28                	jmp    8095f3 <udp_sendto_if+0x110>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8095cb:	8b 55 18             	mov    0x18(%ebp),%edx
  8095ce:	3b 42 04             	cmp    0x4(%edx),%eax
  8095d1:	74 20                	je     8095f3 <udp_sendto_if+0x110>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  8095d3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  8095d8:	3b 75 0c             	cmp    0xc(%ebp),%esi
  8095db:	0f 84 aa 00 00 00    	je     80968b <udp_sendto_if+0x1a8>
        /* free the header pbuf */
        pbuf_free(q);
  8095e1:	89 34 24             	mov    %esi,(%esp)
  8095e4:	e8 eb b7 ff ff       	call   804dd4 <pbuf_free>
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  8095e9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8095ee:	e9 98 00 00 00       	jmp    80968b <udp_sendto_if+0x1a8>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  8095f3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8095f7:	89 04 24             	mov    %eax,(%esp)
  8095fa:	e8 47 e7 ff ff       	call   807d46 <htons>
  8095ff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809602:	66 89 42 04          	mov    %ax,0x4(%edx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  809606:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  80960a:	75 35                	jne    809641 <udp_sendto_if+0x15e>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80960c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  809610:	89 44 24 10          	mov    %eax,0x10(%esp)
  809614:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80961b:	00 
  80961c:	8b 45 10             	mov    0x10(%ebp),%eax
  80961f:	89 44 24 08          	mov    %eax,0x8(%esp)
  809623:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809627:	89 34 24             	mov    %esi,(%esp)
  80962a:	e8 d6 e3 ff ff       	call   807a05 <inet_chksum_pseudo>
  80962f:	66 85 c0             	test   %ax,%ax
  809632:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  809637:	0f 44 c2             	cmove  %edx,%eax
  80963a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80963d:	66 89 42 06          	mov    %ax,0x6(%edx)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  809641:	8b 45 18             	mov    0x18(%ebp),%eax
  809644:	89 44 24 18          	mov    %eax,0x18(%esp)
  809648:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  80964f:	00 
  809650:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  809654:	89 44 24 10          	mov    %eax,0x10(%esp)
  809658:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80965c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809660:	8b 45 10             	mov    0x10(%ebp),%eax
  809663:	89 44 24 08          	mov    %eax,0x8(%esp)
  809667:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80966b:	89 34 24             	mov    %esi,(%esp)
  80966e:	e8 8b d7 ff ff       	call   806dfe <ip_output_if>
  809673:	89 c3                	mov    %eax,%ebx
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  809675:	3b 75 0c             	cmp    0xc(%ebp),%esi
  809678:	74 11                	je     80968b <udp_sendto_if+0x1a8>
    /* free the header pbuf */
    pbuf_free(q);
  80967a:	89 34 24             	mov    %esi,(%esp)
  80967d:	e8 52 b7 ff ff       	call   804dd4 <pbuf_free>
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  809682:	89 d8                	mov    %ebx,%eax
  809684:	eb 05                	jmp    80968b <udp_sendto_if+0x1a8>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  809686:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  80968b:	83 c4 2c             	add    $0x2c,%esp
  80968e:	5b                   	pop    %ebx
  80968f:	5e                   	pop    %esi
  809690:	5f                   	pop    %edi
  809691:	5d                   	pop    %ebp
  809692:	c3                   	ret    

00809693 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  809693:	55                   	push   %ebp
  809694:	89 e5                	mov    %esp,%ebp
  809696:	56                   	push   %esi
  809697:	53                   	push   %ebx
  809698:	83 ec 20             	sub    $0x20,%esp
  80969b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80969e:	8b 75 14             	mov    0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  8096a1:	89 1c 24             	mov    %ebx,(%esp)
  8096a4:	e8 17 d4 ff ff       	call   806ac0 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  8096a9:	85 c0                	test   %eax,%eax
  8096ab:	74 23                	je     8096d0 <udp_sendto+0x3d>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  8096ad:	89 44 24 10          	mov    %eax,0x10(%esp)
  8096b1:	0f b7 f6             	movzwl %si,%esi
  8096b4:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8096b8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8096bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8096bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8096c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8096c6:	89 04 24             	mov    %eax,(%esp)
  8096c9:	e8 15 fe ff ff       	call   8094e3 <udp_sendto_if>
  8096ce:	eb 05                	jmp    8096d5 <udp_sendto+0x42>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  8096d0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  8096d5:	83 c4 20             	add    $0x20,%esp
  8096d8:	5b                   	pop    %ebx
  8096d9:	5e                   	pop    %esi
  8096da:	5d                   	pop    %ebp
  8096db:	c3                   	ret    

008096dc <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  8096dc:	55                   	push   %ebp
  8096dd:	89 e5                	mov    %esp,%ebp
  8096df:	83 ec 18             	sub    $0x18,%esp
  8096e2:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  8096e5:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  8096e9:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8096ed:	8d 50 04             	lea    0x4(%eax),%edx
  8096f0:	89 54 24 08          	mov    %edx,0x8(%esp)
  8096f4:	8b 55 0c             	mov    0xc(%ebp),%edx
  8096f7:	89 54 24 04          	mov    %edx,0x4(%esp)
  8096fb:	89 04 24             	mov    %eax,(%esp)
  8096fe:	e8 90 ff ff ff       	call   809693 <udp_sendto>
}
  809703:	c9                   	leave  
  809704:	c3                   	ret    

00809705 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809705:	55                   	push   %ebp
  809706:	89 e5                	mov    %esp,%ebp
  809708:	57                   	push   %edi
  809709:	56                   	push   %esi
  80970a:	53                   	push   %ebx
  80970b:	83 ec 1c             	sub    $0x1c,%esp
  80970e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809711:	8b 75 0c             	mov    0xc(%ebp),%esi
  809714:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  809717:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80971c:	75 1a                	jne    809738 <udp_connect+0x33>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80971e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809725:	00 
  809726:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80972a:	89 1c 24             	mov    %ebx,(%esp)
  80972d:	e8 df fc ff ff       	call   809411 <udp_bind>
  809732:	89 c2                	mov    %eax,%edx
    if (err != ERR_OK)
  809734:	84 d2                	test   %dl,%dl
  809736:	75 3f                	jne    809777 <udp_connect+0x72>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  809738:	85 f6                	test   %esi,%esi
  80973a:	74 06                	je     809742 <udp_connect+0x3d>
  80973c:	8b 06                	mov    (%esi),%eax
  80973e:	66 90                	xchg   %ax,%ax
  809740:	eb 05                	jmp    809747 <udp_connect+0x42>
  809742:	b8 00 00 00 00       	mov    $0x0,%eax
  809747:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  80974a:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80974e:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809752:	8b 15 74 c2 b3 00    	mov    0xb3c274,%edx
  809758:	89 d0                	mov    %edx,%eax
  80975a:	eb 07                	jmp    809763 <udp_connect+0x5e>
    if (pcb == ipcb) {
  80975c:	39 c3                	cmp    %eax,%ebx
  80975e:	74 12                	je     809772 <udp_connect+0x6d>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809760:	8b 40 0c             	mov    0xc(%eax),%eax
  809763:	85 c0                	test   %eax,%eax
  809765:	75 f5                	jne    80975c <udp_connect+0x57>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  809767:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80976a:	89 1d 74 c2 b3 00    	mov    %ebx,0xb3c274
  return ERR_OK;
  809770:	eb 05                	jmp    809777 <udp_connect+0x72>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  809772:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  809777:	83 c4 1c             	add    $0x1c,%esp
  80977a:	5b                   	pop    %ebx
  80977b:	5e                   	pop    %esi
  80977c:	5f                   	pop    %edi
  80977d:	5d                   	pop    %ebp
  80977e:	c3                   	ret    

0080977f <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80977f:	55                   	push   %ebp
  809780:	89 e5                	mov    %esp,%ebp
  809782:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  809785:	8b 15 40 30 81 00    	mov    0x813040,%edx
  80978b:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80978e:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  809794:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  809798:	5d                   	pop    %ebp
  809799:	c3                   	ret    

0080979a <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80979a:	55                   	push   %ebp
  80979b:	89 e5                	mov    %esp,%ebp
  80979d:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  8097a0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8097a3:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  8097a6:	8b 55 10             	mov    0x10(%ebp),%edx
  8097a9:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  8097ac:	5d                   	pop    %ebp
  8097ad:	c3                   	ret    

008097ae <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  8097ae:	55                   	push   %ebp
  8097af:	89 e5                	mov    %esp,%ebp
  8097b1:	83 ec 18             	sub    $0x18,%esp
  8097b4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  8097b7:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  8097bc:	39 c8                	cmp    %ecx,%eax
  8097be:	75 1e                	jne    8097de <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  8097c0:	8b 40 0c             	mov    0xc(%eax),%eax
  8097c3:	a3 74 c2 b3 00       	mov    %eax,0xb3c274
  8097c8:	eb 18                	jmp    8097e2 <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8097ca:	8b 50 0c             	mov    0xc(%eax),%edx
  8097cd:	85 d2                	test   %edx,%edx
  8097cf:	74 0a                	je     8097db <udp_remove+0x2d>
  8097d1:	39 d1                	cmp    %edx,%ecx
  8097d3:	75 06                	jne    8097db <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  8097d5:	8b 51 0c             	mov    0xc(%ecx),%edx
  8097d8:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8097db:	8b 40 0c             	mov    0xc(%eax),%eax
  8097de:	85 c0                	test   %eax,%eax
  8097e0:	75 e8                	jne    8097ca <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  8097e2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8097e6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8097ed:	e8 30 b2 ff ff       	call   804a22 <memp_free>
}
  8097f2:	c9                   	leave  
  8097f3:	c3                   	ret    

008097f4 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8097f4:	55                   	push   %ebp
  8097f5:	89 e5                	mov    %esp,%ebp
  8097f7:	53                   	push   %ebx
  8097f8:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8097fb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809802:	e8 bb b1 ff ff       	call   8049c2 <memp_malloc>
  809807:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  809809:	85 c0                	test   %eax,%eax
  80980b:	74 1c                	je     809829 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80980d:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  809814:	00 
  809815:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80981c:	00 
  80981d:	89 04 24             	mov    %eax,(%esp)
  809820:	e8 d2 60 00 00       	call   80f8f7 <memset>
    pcb->ttl = UDP_TTL;
  809825:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  809829:	89 d8                	mov    %ebx,%eax
  80982b:	83 c4 14             	add    $0x14,%esp
  80982e:	5b                   	pop    %ebx
  80982f:	5d                   	pop    %ebp
  809830:	c3                   	ret    
  809831:	66 90                	xchg   %ax,%ax
  809833:	66 90                	xchg   %ax,%ax
  809835:	66 90                	xchg   %ax,%ax
  809837:	66 90                	xchg   %ax,%ax
  809839:	66 90                	xchg   %ax,%ax
  80983b:	66 90                	xchg   %ax,%ax
  80983d:	66 90                	xchg   %ax,%ax
  80983f:	90                   	nop

00809840 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  809840:	55                   	push   %ebp
  809841:	89 e5                	mov    %esp,%ebp
  809843:	56                   	push   %esi
  809844:	53                   	push   %ebx
  809845:	83 ec 10             	sub    $0x10,%esp
  809848:	89 c3                	mov    %eax,%ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80984a:	85 c0                	test   %eax,%eax
  80984c:	75 1c                	jne    80986a <free_etharp_q+0x2a>
  80984e:	c7 44 24 08 48 2b 81 	movl   $0x812b48,0x8(%esp)
  809855:	00 
  809856:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  80985d:	00 
  80985e:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809865:	e8 d0 57 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80986a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  80986e:	75 1c                	jne    80988c <free_etharp_q+0x4c>
  809870:	c7 44 24 08 4a 34 81 	movl   $0x81344a,0x8(%esp)
  809877:	00 
  809878:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  80987f:	00 
  809880:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809887:	e8 ae 57 00 00       	call   80f03a <_panic>
  while (q) {
    r = q;
    q = q->next;
  80988c:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80988e:	8b 43 04             	mov    0x4(%ebx),%eax
  809891:	85 c0                	test   %eax,%eax
  809893:	75 1c                	jne    8098b1 <free_etharp_q+0x71>
  809895:	c7 44 24 08 57 34 81 	movl   $0x813457,0x8(%esp)
  80989c:	00 
  80989d:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  8098a4:	00 
  8098a5:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  8098ac:	e8 89 57 00 00       	call   80f03a <_panic>
    pbuf_free(r->p);
  8098b1:	89 04 24             	mov    %eax,(%esp)
  8098b4:	e8 1b b5 ff ff       	call   804dd4 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  8098b9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8098bd:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  8098c4:	e8 59 b1 ff ff       	call   804a22 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  8098c9:	85 f6                	test   %esi,%esi
  8098cb:	74 04                	je     8098d1 <free_etharp_q+0x91>
    r = q;
    q = q->next;
  8098cd:	89 f3                	mov    %esi,%ebx
  8098cf:	eb bb                	jmp    80988c <free_etharp_q+0x4c>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  8098d1:	83 c4 10             	add    $0x10,%esp
  8098d4:	5b                   	pop    %ebx
  8098d5:	5e                   	pop    %esi
  8098d6:	5d                   	pop    %ebp
  8098d7:	c3                   	ret    

008098d8 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  8098d8:	55                   	push   %ebp
  8098d9:	89 e5                	mov    %esp,%ebp
  8098db:	57                   	push   %edi
  8098dc:	56                   	push   %esi
  8098dd:	53                   	push   %ebx
  8098de:	83 ec 2c             	sub    $0x2c,%esp
  8098e1:	89 c3                	mov    %eax,%ebx
  8098e3:	89 55 dc             	mov    %edx,-0x24(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  8098e6:	85 c0                	test   %eax,%eax
  8098e8:	75 2f                	jne    809919 <find_entry+0x41>
  8098ea:	ba 54 5a b3 00       	mov    $0xb35a54,%edx
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
          old_pending = i;
          age_pending = arp_table[i].ctime;
  8098ef:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  8098f3:	c6 45 e0 0a          	movb   $0xa,-0x20(%ebp)
  8098f7:	c6 45 e2 00          	movb   $0x0,-0x1e(%ebp)
  8098fb:	c6 45 db 00          	movb   $0x0,-0x25(%ebp)
  8098ff:	b9 00 00 00 00       	mov    $0x0,%ecx
  809904:	b8 0a 00 00 00       	mov    $0xa,%eax
  809909:	c6 45 e1 0a          	movb   $0xa,-0x1f(%ebp)
  80990d:	c6 45 da 0a          	movb   $0xa,-0x26(%ebp)
  809911:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  809914:	e9 b8 00 00 00       	jmp    8099d1 <find_entry+0xf9>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809919:	0f b6 05 20 5a b3 00 	movzbl 0xb35a20,%eax
  809920:	0f b6 d0             	movzbl %al,%edx
  809923:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809926:	83 b9 50 5a b3 00 02 	cmpl   $0x2,0xb35a50(%ecx)
  80992d:	75 bb                	jne    8098ea <find_entry+0x12>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80992f:	8b b9 44 5a b3 00    	mov    0xb35a44(%ecx),%edi
  809935:	39 3b                	cmp    %edi,(%ebx)
  809937:	75 b1                	jne    8098ea <find_entry+0x12>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  809939:	e9 a7 01 00 00       	jmp    809ae5 <find_entry+0x20d>
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80993e:	3c 0a                	cmp    $0xa,%al
  809940:	75 0a                	jne    80994c <find_entry+0x74>
  809942:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  809946:	75 04                	jne    80994c <find_entry+0x74>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  809948:	89 c8                	mov    %ecx,%eax
  80994a:	eb 7f                	jmp    8099cb <find_entry+0xf3>
  80994c:	89 d7                	mov    %edx,%edi
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80994e:	8b 72 fc             	mov    -0x4(%edx),%esi
  809951:	83 fe 01             	cmp    $0x1,%esi
  809954:	75 45                	jne    80999b <find_entry+0xc3>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809956:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  809959:	85 f6                	test   %esi,%esi
  80995b:	74 14                	je     809971 <find_entry+0x99>
  80995d:	8b 5a f0             	mov    -0x10(%edx),%ebx
  809960:	39 1e                	cmp    %ebx,(%esi)
  809962:	75 0d                	jne    809971 <find_entry+0x99>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809964:	88 0d 20 5a b3 00    	mov    %cl,0xb35a20
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80996a:	89 c8                	mov    %ecx,%eax
  80996c:	e9 74 01 00 00       	jmp    809ae5 <find_entry+0x20d>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  809971:	83 7f ec 00          	cmpl   $0x0,-0x14(%edi)
  809975:	74 12                	je     809989 <find_entry+0xb1>
        if (arp_table[i].ctime >= age_queue) {
  809977:	0f b6 37             	movzbl (%edi),%esi
  80997a:	89 f3                	mov    %esi,%ebx
  80997c:	38 5d e3             	cmp    %bl,-0x1d(%ebp)
  80997f:	77 4a                	ja     8099cb <find_entry+0xf3>
          old_queue = i;
  809981:	88 4d e0             	mov    %cl,-0x20(%ebp)
          age_queue = arp_table[i].ctime;
  809984:	88 5d e3             	mov    %bl,-0x1d(%ebp)
  809987:	eb 42                	jmp    8099cb <find_entry+0xf3>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  809989:	0f b6 37             	movzbl (%edi),%esi
  80998c:	89 f3                	mov    %esi,%ebx
  80998e:	38 5d db             	cmp    %bl,-0x25(%ebp)
  809991:	77 38                	ja     8099cb <find_entry+0xf3>
          old_pending = i;
  809993:	88 4d da             	mov    %cl,-0x26(%ebp)
          age_pending = arp_table[i].ctime;
  809996:	88 5d db             	mov    %bl,-0x25(%ebp)
  809999:	eb 30                	jmp    8099cb <find_entry+0xf3>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80999b:	83 fe 02             	cmp    $0x2,%esi
  80999e:	75 2b                	jne    8099cb <find_entry+0xf3>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8099a0:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8099a3:	85 f6                	test   %esi,%esi
  8099a5:	74 14                	je     8099bb <find_entry+0xe3>
  8099a7:	8b 5a f0             	mov    -0x10(%edx),%ebx
  8099aa:	39 1e                	cmp    %ebx,(%esi)
  8099ac:	75 0d                	jne    8099bb <find_entry+0xe3>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8099ae:	88 0d 20 5a b3 00    	mov    %cl,0xb35a20
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8099b4:	89 c8                	mov    %ecx,%eax
  8099b6:	e9 2a 01 00 00       	jmp    809ae5 <find_entry+0x20d>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  8099bb:	0f b6 37             	movzbl (%edi),%esi
  8099be:	89 f3                	mov    %esi,%ebx
  8099c0:	38 5d e2             	cmp    %bl,-0x1e(%ebp)
  8099c3:	77 06                	ja     8099cb <find_entry+0xf3>
        old_stable = i;
  8099c5:	88 4d e1             	mov    %cl,-0x1f(%ebp)
        age_stable = arp_table[i].ctime;
  8099c8:	88 5d e2             	mov    %bl,-0x1e(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8099cb:	83 c1 01             	add    $0x1,%ecx
  8099ce:	83 c2 1c             	add    $0x1c,%edx
  8099d1:	80 f9 0a             	cmp    $0xa,%cl
  8099d4:	0f 85 64 ff ff ff    	jne    80993e <find_entry+0x66>
  8099da:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8099dd:	3c 0a                	cmp    $0xa,%al
  8099df:	75 0f                	jne    8099f0 <find_entry+0x118>
  8099e1:	f6 45 dc 01          	testb  $0x1,-0x24(%ebp)
  8099e5:	0f 85 ee 00 00 00    	jne    809ad9 <find_entry+0x201>
  8099eb:	e9 cd 00 00 00       	jmp    809abd <find_entry+0x1e5>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8099f0:	f6 45 dc 02          	testb  $0x2,-0x24(%ebp)
  8099f4:	0f 85 ca 00 00 00    	jne    809ac4 <find_entry+0x1ec>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8099fa:	89 c6                	mov    %eax,%esi
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  8099fc:	3c 09                	cmp    $0x9,%al
  8099fe:	66 90                	xchg   %ax,%ax
  809a00:	7e 68                	jle    809a6a <find_entry+0x192>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  809a02:	80 7d e1 09          	cmpb   $0x9,-0x1f(%ebp)
  809a06:	7f 31                	jg     809a39 <find_entry+0x161>
    /* recycle oldest stable*/
    i = old_stable;
  809a08:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
  809a0c:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809a0e:	0f b6 c0             	movzbl %al,%eax
  809a11:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809a14:	83 b8 40 5a b3 00 00 	cmpl   $0x0,0xb35a40(%eax)
  809a1b:	74 4d                	je     809a6a <find_entry+0x192>
  809a1d:	c7 44 24 08 64 34 81 	movl   $0x813464,0x8(%esp)
  809a24:	00 
  809a25:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  809a2c:	00 
  809a2d:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809a34:	e8 01 56 00 00       	call   80f03a <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  809a39:	80 7d da 09          	cmpb   $0x9,-0x26(%ebp)
  809a3d:	7f 06                	jg     809a45 <find_entry+0x16d>
    /* recycle oldest pending */
    i = old_pending;
  809a3f:	0f b6 75 da          	movzbl -0x26(%ebp),%esi
  809a43:	eb 25                	jmp    809a6a <find_entry+0x192>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  809a45:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  809a49:	3c 09                	cmp    $0x9,%al
  809a4b:	7f 7e                	jg     809acb <find_entry+0x1f3>
    /* recycle oldest pending */
    i = old_queue;
  809a4d:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  809a4f:	0f b6 f8             	movzbl %al,%edi
  809a52:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809a55:	8b 87 40 5a b3 00    	mov    0xb35a40(%edi),%eax
  809a5b:	e8 e0 fd ff ff       	call   809840 <free_etharp_q>
    arp_table[i].q = NULL;
  809a60:	c7 87 40 5a b3 00 00 	movl   $0x0,0xb35a40(%edi)
  809a67:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809a6a:	89 f0                	mov    %esi,%eax
  809a6c:	3c 09                	cmp    $0x9,%al
  809a6e:	76 1c                	jbe    809a8c <find_entry+0x1b4>
  809a70:	c7 44 24 08 7b 34 81 	movl   $0x81347b,0x8(%esp)
  809a77:	00 
  809a78:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  809a7f:	00 
  809a80:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809a87:	e8 ae 55 00 00       	call   80f03a <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809a8c:	89 f0                	mov    %esi,%eax
  809a8e:	0f b6 c0             	movzbl %al,%eax
  809a91:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809a94:	c7 82 50 5a b3 00 00 	movl   $0x0,0xb35a50(%edx)
  809a9b:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809a9e:	85 db                	test   %ebx,%ebx
  809aa0:	74 08                	je     809aaa <find_entry+0x1d2>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809aa2:	8b 0b                	mov    (%ebx),%ecx
  809aa4:	89 8a 44 5a b3 00    	mov    %ecx,0xb35a44(%edx)
  }
  arp_table[i].ctime = 0;
  809aaa:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809aad:	c6 80 54 5a b3 00 00 	movb   $0x0,0xb35a54(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809ab4:	89 f0                	mov    %esi,%eax
  809ab6:	a2 20 5a b3 00       	mov    %al,0xb35a20
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809abb:	eb 28                	jmp    809ae5 <find_entry+0x20d>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809abd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ac2:	eb 21                	jmp    809ae5 <find_entry+0x20d>
  809ac4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ac9:	eb 1a                	jmp    809ae5 <find_entry+0x20d>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  809acb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ad0:	eb 13                	jmp    809ae5 <find_entry+0x20d>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809ad2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ad7:	eb 0c                	jmp    809ae5 <find_entry+0x20d>
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809ad9:	f6 45 dc 02          	testb  $0x2,-0x24(%ebp)
  809add:	0f 84 1f ff ff ff    	je     809a02 <find_entry+0x12a>
  809ae3:	eb ed                	jmp    809ad2 <find_entry+0x1fa>
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  809ae5:	83 c4 2c             	add    $0x2c,%esp
  809ae8:	5b                   	pop    %ebx
  809ae9:	5e                   	pop    %esi
  809aea:	5f                   	pop    %edi
  809aeb:	5d                   	pop    %ebp
  809aec:	c3                   	ret    

00809aed <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809aed:	55                   	push   %ebp
  809aee:	89 e5                	mov    %esp,%ebp
  809af0:	57                   	push   %edi
  809af1:	56                   	push   %esi
  809af2:	53                   	push   %ebx
  809af3:	83 ec 2c             	sub    $0x2c,%esp
  809af6:	89 c6                	mov    %eax,%esi
  809af8:	89 55 e0             	mov    %edx,-0x20(%ebp)
  809afb:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  809afe:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809b01:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  809b05:	74 1c                	je     809b23 <etharp_send_ip+0x36>
  809b07:	c7 44 24 08 a8 34 81 	movl   $0x8134a8,0x8(%esp)
  809b0e:	00 
  809b0f:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  809b16:	00 
  809b17:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809b1e:	e8 17 55 00 00       	call   80f03a <_panic>
  809b23:	b8 06 00 00 00       	mov    $0x6,%eax
  809b28:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  809b2b:	83 e8 01             	sub    $0x1,%eax
    ethhdr->dest.addr[k] = dst->addr[k];
  809b2e:	0f b6 d0             	movzbl %al,%edx
  809b31:	0f b6 0c 17          	movzbl (%edi,%edx,1),%ecx
  809b35:	88 0c 13             	mov    %cl,(%ebx,%edx,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809b38:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809b3b:	0f b6 0c 11          	movzbl (%ecx,%edx,1),%ecx
  809b3f:	88 4c 13 06          	mov    %cl,0x6(%ebx,%edx,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  809b43:	84 c0                	test   %al,%al
  809b45:	75 e4                	jne    809b2b <etharp_send_ip+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809b47:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809b4e:	e8 f3 e1 ff ff       	call   807d46 <htons>
  809b53:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809b57:	8b 45 e0             	mov    -0x20(%ebp),%eax
  809b5a:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b5e:	89 34 24             	mov    %esi,(%esp)
  809b61:	ff 56 18             	call   *0x18(%esi)
}
  809b64:	83 c4 2c             	add    $0x2c,%esp
  809b67:	5b                   	pop    %ebx
  809b68:	5e                   	pop    %esi
  809b69:	5f                   	pop    %edi
  809b6a:	5d                   	pop    %ebp
  809b6b:	c3                   	ret    

00809b6c <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809b6c:	55                   	push   %ebp
  809b6d:	89 e5                	mov    %esp,%ebp
  809b6f:	57                   	push   %edi
  809b70:	56                   	push   %esi
  809b71:	53                   	push   %ebx
  809b72:	83 ec 2c             	sub    $0x2c,%esp
  809b75:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809b78:	89 cb                	mov    %ecx,%ebx
  809b7a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809b7d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809b80:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809b84:	74 1c                	je     809ba2 <update_arp_entry+0x36>
  809b86:	c7 44 24 08 ec 34 81 	movl   $0x8134ec,0x8(%esp)
  809b8d:	00 
  809b8e:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  809b95:	00 
  809b96:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809b9d:	e8 98 54 00 00       	call   80f03a <_panic>
  809ba2:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809ba4:	85 d2                	test   %edx,%edx
  809ba6:	0f 84 e2 00 00 00    	je     809c8e <update_arp_entry+0x122>
  809bac:	83 3a 00             	cmpl   $0x0,(%edx)
  809baf:	0f 84 e0 00 00 00    	je     809c95 <update_arp_entry+0x129>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809bb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809bb8:	89 44 24 04          	mov    %eax,0x4(%esp)
  809bbc:	89 14 24             	mov    %edx,(%esp)
  809bbf:	e8 ad ce ff ff       	call   806a71 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809bc4:	84 c0                	test   %al,%al
  809bc6:	0f 85 d0 00 00 00    	jne    809c9c <update_arp_entry+0x130>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  809bcc:	8b 3e                	mov    (%esi),%edi
  809bce:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809bd5:	e8 c0 e3 ff ff       	call   807f9a <ntohl>
  809bda:	21 c7                	and    %eax,%edi
  809bdc:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809be3:	e8 b2 e3 ff ff       	call   807f9a <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  809be8:	39 c7                	cmp    %eax,%edi
  809bea:	0f 84 b3 00 00 00    	je     809ca3 <update_arp_entry+0x137>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  809bf0:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  809bf4:	89 f0                	mov    %esi,%eax
  809bf6:	e8 dd fc ff ff       	call   8098d8 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809bfb:	84 c0                	test   %al,%al
  809bfd:	0f 88 a5 00 00 00    	js     809ca8 <update_arp_entry+0x13c>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809c03:	0f be f8             	movsbl %al,%edi
  809c06:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c09:	c7 80 50 5a b3 00 02 	movl   $0x2,0xb35a50(%eax)
  809c10:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  809c13:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809c16:	89 88 58 5a b3 00    	mov    %ecx,0xb35a58(%eax)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  809c1c:	ba 06 00 00 00       	mov    $0x6,%edx
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809c21:	89 c6                	mov    %eax,%esi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  809c23:	83 ea 01             	sub    $0x1,%edx
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809c26:	0f b6 c2             	movzbl %dl,%eax
  809c29:	0f b6 0c 03          	movzbl (%ebx,%eax,1),%ecx
  809c2d:	88 8c 30 48 5a b3 00 	mov    %cl,0xb35a48(%eax,%esi,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  809c34:	84 d2                	test   %dl,%dl
  809c36:	75 eb                	jne    809c23 <update_arp_entry+0xb7>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809c38:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c3b:	c6 80 54 5a b3 00 00 	movb   $0x0,0xb35a54(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809c42:	89 c7                	mov    %eax,%edi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809c44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809c47:	83 c0 25             	add    $0x25,%eax
  809c4a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809c4d:	eb 33                	jmp    809c82 <update_arp_entry+0x116>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  809c4f:	8b 10                	mov    (%eax),%edx
  809c51:	89 97 40 5a b3 00    	mov    %edx,0xb35a40(%edi)
    /* get the packet pointer */
    p = q->p;
  809c57:	8b 70 04             	mov    0x4(%eax),%esi
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  809c5a:	89 44 24 04          	mov    %eax,0x4(%esp)
  809c5e:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809c65:	e8 b8 ad ff ff       	call   804a22 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809c6a:	89 1c 24             	mov    %ebx,(%esp)
  809c6d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809c70:	89 f2                	mov    %esi,%edx
  809c72:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809c75:	e8 73 fe ff ff       	call   809aed <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809c7a:	89 34 24             	mov    %esi,(%esp)
  809c7d:	e8 52 b1 ff ff       	call   804dd4 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809c82:	8b 87 40 5a b3 00    	mov    0xb35a40(%edi),%eax
  809c88:	85 c0                	test   %eax,%eax
  809c8a:	75 c3                	jne    809c4f <update_arp_entry+0xe3>
  809c8c:	eb 1a                	jmp    809ca8 <update_arp_entry+0x13c>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809c8e:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809c93:	eb 13                	jmp    809ca8 <update_arp_entry+0x13c>
  809c95:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809c9a:	eb 0c                	jmp    809ca8 <update_arp_entry+0x13c>
  809c9c:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809ca1:	eb 05                	jmp    809ca8 <update_arp_entry+0x13c>
  809ca3:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  809ca8:	83 c4 2c             	add    $0x2c,%esp
  809cab:	5b                   	pop    %ebx
  809cac:	5e                   	pop    %esi
  809cad:	5f                   	pop    %edi
  809cae:	5d                   	pop    %ebp
  809caf:	c3                   	ret    

00809cb0 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  809cb0:	55                   	push   %ebp
  809cb1:	89 e5                	mov    %esp,%ebp
  809cb3:	57                   	push   %edi
  809cb4:	56                   	push   %esi
  809cb5:	53                   	push   %ebx
  809cb6:	83 ec 0c             	sub    $0xc,%esp
  809cb9:	bb 54 5a b3 00       	mov    $0xb35a54,%ebx
  809cbe:	bf 6c 5b b3 00       	mov    $0xb35b6c,%edi
  809cc3:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  809cc5:	0f b6 03             	movzbl (%ebx),%eax
  809cc8:	8d 50 01             	lea    0x1(%eax),%edx
  809ccb:	88 13                	mov    %dl,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  809ccd:	8b 43 fc             	mov    -0x4(%ebx),%eax
  809cd0:	83 f8 02             	cmp    $0x2,%eax
  809cd3:	75 07                	jne    809cdc <etharp_tmr+0x2c>
  809cd5:	80 fa ef             	cmp    $0xef,%dl
  809cd8:	77 0d                	ja     809ce7 <etharp_tmr+0x37>
  809cda:	eb 25                	jmp    809d01 <etharp_tmr+0x51>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  809cdc:	83 f8 01             	cmp    $0x1,%eax
  809cdf:	90                   	nop
  809ce0:	75 1f                	jne    809d01 <etharp_tmr+0x51>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809ce2:	80 fa 01             	cmp    $0x1,%dl
  809ce5:	76 1a                	jbe    809d01 <etharp_tmr+0x51>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  809ce7:	8b 46 ec             	mov    -0x14(%esi),%eax
  809cea:	85 c0                	test   %eax,%eax
  809cec:	74 0c                	je     809cfa <etharp_tmr+0x4a>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  809cee:	e8 4d fb ff ff       	call   809840 <free_etharp_q>
        arp_table[i].q = NULL;
  809cf3:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809cfa:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  809d01:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809d04:	39 fb                	cmp    %edi,%ebx
  809d06:	75 bb                	jne    809cc3 <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  809d08:	83 c4 0c             	add    $0xc,%esp
  809d0b:	5b                   	pop    %ebx
  809d0c:	5e                   	pop    %esi
  809d0d:	5f                   	pop    %edi
  809d0e:	5d                   	pop    %ebp
  809d0f:	c3                   	ret    

00809d10 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  809d10:	55                   	push   %ebp
  809d11:	89 e5                	mov    %esp,%ebp
  809d13:	53                   	push   %ebx
  809d14:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809d17:	ba 02 00 00 00       	mov    $0x2,%edx
  809d1c:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d1f:	e8 b4 fb ff ff       	call   8098d8 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809d24:	84 c0                	test   %al,%al
  809d26:	78 29                	js     809d51 <etharp_find_addr+0x41>
  809d28:	0f be d0             	movsbl %al,%edx
  809d2b:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809d2e:	83 b9 50 5a b3 00 02 	cmpl   $0x2,0xb35a50(%ecx)
  809d35:	75 21                	jne    809d58 <etharp_find_addr+0x48>
      *eth_ret = &arp_table[i].ethaddr;
  809d37:	89 ca                	mov    %ecx,%edx
  809d39:	8d 99 48 5a b3 00    	lea    0xb35a48(%ecx),%ebx
  809d3f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809d42:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809d44:	81 c2 44 5a b3 00    	add    $0xb35a44,%edx
  809d4a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809d4d:	89 11                	mov    %edx,(%ecx)
      return i;
  809d4f:	eb 0c                	jmp    809d5d <etharp_find_addr+0x4d>
  }
  return -1;
  809d51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809d56:	eb 05                	jmp    809d5d <etharp_find_addr+0x4d>
  809d58:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  809d5d:	83 c4 04             	add    $0x4,%esp
  809d60:	5b                   	pop    %ebx
  809d61:	5d                   	pop    %ebp
  809d62:	c3                   	ret    

00809d63 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809d63:	55                   	push   %ebp
  809d64:	89 e5                	mov    %esp,%ebp
  809d66:	83 ec 18             	sub    $0x18,%esp
  809d69:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809d6c:	85 c0                	test   %eax,%eax
  809d6e:	75 1c                	jne    809d8c <etharp_ip_input+0x29>
  809d70:	c7 44 24 08 a2 27 81 	movl   $0x8127a2,0x8(%esp)
  809d77:	00 
  809d78:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  809d7f:	00 
  809d80:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809d87:	e8 ae 52 00 00       	call   80f03a <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809d8c:	8b 55 0c             	mov    0xc(%ebp),%edx
  809d8f:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809d92:	8b 48 04             	mov    0x4(%eax),%ecx
  809d95:	33 4a 1c             	xor    0x1c(%edx),%ecx
  809d98:	85 48 08             	test   %ecx,0x8(%eax)
  809d9b:	75 12                	jne    809daf <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809d9d:	8d 4a 06             	lea    0x6(%edx),%ecx
  809da0:	83 c2 1c             	add    $0x1c,%edx
  809da3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809daa:	e8 bd fd ff ff       	call   809b6c <update_arp_entry>
}
  809daf:	c9                   	leave  
  809db0:	c3                   	ret    

00809db1 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  809db1:	55                   	push   %ebp
  809db2:	89 e5                	mov    %esp,%ebp
  809db4:	57                   	push   %edi
  809db5:	56                   	push   %esi
  809db6:	53                   	push   %ebx
  809db7:	83 ec 2c             	sub    $0x2c,%esp
  809dba:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809dbd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  809dc1:	75 1c                	jne    809ddf <etharp_arp_input+0x2e>
  809dc3:	c7 44 24 08 a2 27 81 	movl   $0x8127a2,0x8(%esp)
  809dca:	00 
  809dcb:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  809dd2:	00 
  809dd3:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809dda:	e8 5b 52 00 00       	call   80f03a <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  809ddf:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  809de4:	77 0d                	ja     809df3 <etharp_arp_input+0x42>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809de6:	89 1c 24             	mov    %ebx,(%esp)
  809de9:	e8 e6 af ff ff       	call   804dd4 <pbuf_free>
    return;
  809dee:	e9 a6 01 00 00       	jmp    809f99 <etharp_arp_input+0x1e8>
  }

  hdr = p->payload;
  809df3:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809df6:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  809dfa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809e01:	e8 40 df ff ff       	call   807d46 <htons>
  809e06:	66 39 c7             	cmp    %ax,%di
  809e09:	75 3f                	jne    809e4a <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809e0b:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  809e0f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809e16:	e8 2b df ff ff       	call   807d46 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809e1b:	66 39 c7             	cmp    %ax,%di
  809e1e:	75 2a                	jne    809e4a <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809e20:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  809e24:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809e2b:	e8 16 df ff ff       	call   807d46 <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809e30:	66 39 c7             	cmp    %ax,%di
  809e33:	75 15                	jne    809e4a <etharp_arp_input+0x99>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809e35:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809e39:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809e40:	e8 01 df ff ff       	call   807d46 <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809e45:	66 39 c7             	cmp    %ax,%di
  809e48:	74 0d                	je     809e57 <etharp_arp_input+0xa6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809e4a:	89 1c 24             	mov    %ebx,(%esp)
  809e4d:	e8 82 af ff ff       	call   804dd4 <pbuf_free>
    return;
  809e52:	e9 42 01 00 00       	jmp    809f99 <etharp_arp_input+0x1e8>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809e57:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809e5e:	00 
  809e5f:	8d 46 1c             	lea    0x1c(%esi),%eax
  809e62:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e66:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809e69:	89 04 24             	mov    %eax,(%esp)
  809e6c:	e8 3b 5b 00 00       	call   80f9ac <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809e71:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809e78:	00 
  809e79:	8d 46 26             	lea    0x26(%esi),%eax
  809e7c:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e80:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809e83:	89 04 24             	mov    %eax,(%esp)
  809e86:	e8 21 5b 00 00       	call   80f9ac <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  809e8b:	8b 45 08             	mov    0x8(%ebp),%eax
  809e8e:	8b 40 04             	mov    0x4(%eax),%eax
  809e91:	85 c0                	test   %eax,%eax
  809e93:	74 21                	je     809eb6 <etharp_arp_input+0x105>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  809e95:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  809e98:	0f 94 c0             	sete   %al
  809e9b:	89 c7                	mov    %eax,%edi
  809e9d:	75 1c                	jne    809ebb <etharp_arp_input+0x10a>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  809e9f:	8d 4e 16             	lea    0x16(%esi),%ecx
  809ea2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809ea9:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809eac:	8b 45 08             	mov    0x8(%ebp),%eax
  809eaf:	e8 b8 fc ff ff       	call   809b6c <update_arp_entry>
  809eb4:	eb 1a                	jmp    809ed0 <etharp_arp_input+0x11f>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
    for_us = 0;
  809eb6:	bf 00 00 00 00       	mov    $0x0,%edi
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809ebb:	8d 4e 16             	lea    0x16(%esi),%ecx
  809ebe:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809ec5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809ec8:	8b 45 08             	mov    0x8(%ebp),%eax
  809ecb:	e8 9c fc ff ff       	call   809b6c <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  809ed0:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809ed4:	89 04 24             	mov    %eax,(%esp)
  809ed7:	e8 6a de ff ff       	call   807d46 <htons>
  809edc:	66 83 f8 01          	cmp    $0x1,%ax
  809ee0:	74 0f                	je     809ef1 <etharp_arp_input+0x140>
  809ee2:	66 83 f8 02          	cmp    $0x2,%ax
  809ee6:	0f 84 93 00 00 00    	je     809f7f <etharp_arp_input+0x1ce>
  809eec:	e9 a0 00 00 00       	jmp    809f91 <etharp_arp_input+0x1e0>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  809ef1:	89 f8                	mov    %edi,%eax
  809ef3:	84 c0                	test   %al,%al
  809ef5:	0f 84 96 00 00 00    	je     809f91 <etharp_arp_input+0x1e0>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  809efb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809f02:	e8 3f de ff ff       	call   807d46 <htons>
  809f07:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  809f0b:	8b 46 1c             	mov    0x1c(%esi),%eax
  809f0e:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809f11:	8b 45 08             	mov    0x8(%ebp),%eax
  809f14:	8b 40 04             	mov    0x4(%eax),%eax
  809f17:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809f1a:	ba 06 00 00 00       	mov    $0x6,%edx
  809f1f:	8b 45 08             	mov    0x8(%ebp),%eax
  809f22:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809f26:	74 1c                	je     809f44 <etharp_arp_input+0x193>
  809f28:	c7 44 24 08 a8 34 81 	movl   $0x8134a8,0x8(%esp)
  809f2f:	00 
  809f30:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  809f37:	00 
  809f38:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809f3f:	e8 f6 50 00 00       	call   80f03a <_panic>
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  809f44:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809f47:	0f b6 c2             	movzbl %dl,%eax
  809f4a:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  809f4f:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809f53:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809f56:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  809f59:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809f5d:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809f61:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  809f64:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809f68:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  809f6c:	84 d2                	test   %dl,%dl
  809f6e:	75 d4                	jne    809f44 <etharp_arp_input+0x193>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  809f70:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809f74:	8b 45 08             	mov    0x8(%ebp),%eax
  809f77:	89 04 24             	mov    %eax,(%esp)
  809f7a:	ff 50 18             	call   *0x18(%eax)
  809f7d:	eb 12                	jmp    809f91 <etharp_arp_input+0x1e0>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  809f7f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809f82:	89 44 24 04          	mov    %eax,0x4(%esp)
  809f86:	8b 45 08             	mov    0x8(%ebp),%eax
  809f89:	89 04 24             	mov    %eax,(%esp)
  809f8c:	e8 2d 9e ff ff       	call   803dbe <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  809f91:	89 1c 24             	mov    %ebx,(%esp)
  809f94:	e8 3b ae ff ff       	call   804dd4 <pbuf_free>
}
  809f99:	83 c4 2c             	add    $0x2c,%esp
  809f9c:	5b                   	pop    %ebx
  809f9d:	5e                   	pop    %esi
  809f9e:	5f                   	pop    %edi
  809f9f:	5d                   	pop    %ebp
  809fa0:	c3                   	ret    

00809fa1 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  809fa1:	55                   	push   %ebp
  809fa2:	89 e5                	mov    %esp,%ebp
  809fa4:	57                   	push   %edi
  809fa5:	56                   	push   %esi
  809fa6:	53                   	push   %ebx
  809fa7:	83 ec 1c             	sub    $0x1c,%esp
  809faa:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809fad:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809fb4:	00 
  809fb5:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  809fbc:	00 
  809fbd:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809fc4:	e8 ec ae ff ff       	call   804eb5 <pbuf_alloc>
  809fc9:	89 c7                	mov    %eax,%edi
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  809fcb:	85 c0                	test   %eax,%eax
  809fcd:	0f 84 f4 00 00 00    	je     80a0c7 <etharp_request+0x126>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809fd3:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809fd8:	77 1c                	ja     809ff6 <etharp_request+0x55>
  809fda:	c7 44 24 08 14 35 81 	movl   $0x813514,0x8(%esp)
  809fe1:	00 
  809fe2:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  809fe9:	00 
  809fea:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  809ff1:	e8 44 50 00 00       	call   80f03a <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  809ff6:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  809ff9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80a000:	e8 41 dd ff ff       	call   807d46 <htons>
  80a005:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80a009:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80a00d:	74 1c                	je     80a02b <etharp_request+0x8a>
  80a00f:	c7 44 24 08 a8 34 81 	movl   $0x8134a8,0x8(%esp)
  80a016:	00 
  80a017:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80a01e:	00 
  80a01f:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  80a026:	e8 0f 50 00 00       	call   80f03a <_panic>
  80a02b:	ba 06 00 00 00       	mov    $0x6,%edx
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80a030:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80a033:	0f b6 c2             	movzbl %dl,%eax
  80a036:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  80a03b:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80a03f:	0f b6 88 91 35 81 00 	movzbl 0x813591(%eax),%ecx
  80a046:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80a04a:	0f b6 88 97 35 81 00 	movzbl 0x813597(%eax),%ecx
  80a051:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80a054:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  80a059:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80a05d:	84 d2                	test   %dl,%dl
  80a05f:	75 cf                	jne    80a030 <etharp_request+0x8f>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80a061:	8b 46 04             	mov    0x4(%esi),%eax
  80a064:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80a067:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a06a:	8b 00                	mov    (%eax),%eax
  80a06c:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80a06f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80a076:	e8 cb dc ff ff       	call   807d46 <htons>
  80a07b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80a07f:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80a086:	e8 bb dc ff ff       	call   807d46 <htons>
  80a08b:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80a08f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80a096:	e8 ab dc ff ff       	call   807d46 <htons>
  80a09b:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80a09f:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80a0a6:	e8 9b dc ff ff       	call   807d46 <htons>
  80a0ab:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80a0af:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a0b3:	89 34 24             	mov    %esi,(%esp)
  80a0b6:	ff 56 18             	call   *0x18(%esi)
  80a0b9:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80a0bb:	89 3c 24             	mov    %edi,(%esp)
  80a0be:	e8 11 ad ff ff       	call   804dd4 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  80a0c3:	89 d8                	mov    %ebx,%eax
  80a0c5:	eb 05                	jmp    80a0cc <etharp_request+0x12b>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  80a0c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80a0cc:	83 c4 1c             	add    $0x1c,%esp
  80a0cf:	5b                   	pop    %ebx
  80a0d0:	5e                   	pop    %esi
  80a0d1:	5f                   	pop    %edi
  80a0d2:	5d                   	pop    %ebp
  80a0d3:	c3                   	ret    

0080a0d4 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80a0d4:	55                   	push   %ebp
  80a0d5:	89 e5                	mov    %esp,%ebp
  80a0d7:	57                   	push   %edi
  80a0d8:	56                   	push   %esi
  80a0d9:	53                   	push   %ebx
  80a0da:	83 ec 1c             	sub    $0x1c,%esp
  80a0dd:	8b 7d 08             	mov    0x8(%ebp),%edi
  80a0e0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80a0e3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a0e7:	89 1c 24             	mov    %ebx,(%esp)
  80a0ea:	e8 82 c9 ff ff       	call   806a71 <ip_addr_isbroadcast>
  80a0ef:	84 c0                	test   %al,%al
  80a0f1:	0f 85 ad 01 00 00    	jne    80a2a4 <etharp_query+0x1d0>
      ip_addr_ismulticast(ipaddr) ||
  80a0f7:	8b 33                	mov    (%ebx),%esi
  80a0f9:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a100:	e8 95 de ff ff       	call   807f9a <ntohl>
  80a105:	21 c6                	and    %eax,%esi
  80a107:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a10e:	e8 87 de ff ff       	call   807f9a <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80a113:	39 c6                	cmp    %eax,%esi
  80a115:	0f 84 93 01 00 00    	je     80a2ae <etharp_query+0x1da>
      ip_addr_ismulticast(ipaddr) ||
  80a11b:	85 db                	test   %ebx,%ebx
  80a11d:	0f 84 95 01 00 00    	je     80a2b8 <etharp_query+0x1e4>
      ip_addr_isany(ipaddr)) {
  80a123:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a126:	0f 84 93 01 00 00    	je     80a2bf <etharp_query+0x1eb>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80a12c:	ba 01 00 00 00       	mov    $0x1,%edx
  80a131:	89 d8                	mov    %ebx,%eax
  80a133:	e8 a0 f7 ff ff       	call   8098d8 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80a138:	84 c0                	test   %al,%al
  80a13a:	0f 88 fb 01 00 00    	js     80a33b <etharp_query+0x267>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80a140:	0f be f0             	movsbl %al,%esi
  80a143:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a146:	8b 80 50 5a b3 00    	mov    0xb35a50(%eax),%eax
  80a14c:	85 c0                	test   %eax,%eax
  80a14e:	75 0f                	jne    80a15f <etharp_query+0x8b>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80a150:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a153:	c7 80 50 5a b3 00 01 	movl   $0x1,0xb35a50(%eax)
  80a15a:	00 00 00 
  80a15d:	eb 38                	jmp    80a197 <etharp_query+0xc3>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80a15f:	8d 50 ff             	lea    -0x1(%eax),%edx
  80a162:	83 fa 01             	cmp    $0x1,%edx
  80a165:	76 1c                	jbe    80a183 <etharp_query+0xaf>
  80a167:	c7 44 24 08 48 35 81 	movl   $0x813548,0x8(%esp)
  80a16e:	00 
  80a16f:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80a176:	00 
  80a177:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  80a17e:	e8 b7 4e 00 00       	call   80f03a <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80a183:	83 f8 01             	cmp    $0x1,%eax
  80a186:	74 0f                	je     80a197 <etharp_query+0xc3>
  80a188:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a18c:	0f 85 94 01 00 00    	jne    80a326 <etharp_query+0x252>
  80a192:	e9 81 01 00 00       	jmp    80a318 <etharp_query+0x244>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a197:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a19b:	89 3c 24             	mov    %edi,(%esp)
  80a19e:	e8 fe fd ff ff       	call   809fa1 <etharp_request>
  80a1a3:	89 c3                	mov    %eax,%ebx
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80a1a5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a1a9:	0f 84 17 01 00 00    	je     80a2c6 <etharp_query+0x1f2>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80a1af:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a1b2:	8b 90 50 5a b3 00    	mov    0xb35a50(%eax),%edx
  80a1b8:	83 fa 02             	cmp    $0x2,%edx
  80a1bb:	75 1e                	jne    80a1db <etharp_query+0x107>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80a1bd:	8d 4f 25             	lea    0x25(%edi),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80a1c0:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80a1c3:	81 c6 48 5a b3 00    	add    $0xb35a48,%esi
  80a1c9:	89 34 24             	mov    %esi,(%esp)
  80a1cc:	8b 55 10             	mov    0x10(%ebp),%edx
  80a1cf:	89 f8                	mov    %edi,%eax
  80a1d1:	e8 17 f9 ff ff       	call   809aed <etharp_send_ip>
  80a1d6:	e9 60 01 00 00       	jmp    80a33b <etharp_query+0x267>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a1db:	89 d8                	mov    %ebx,%eax
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80a1dd:	83 fa 01             	cmp    $0x1,%edx
  80a1e0:	0f 85 55 01 00 00    	jne    80a33b <etharp_query+0x267>
  80a1e6:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80a1e9:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
  80a1ed:	66 39 48 0a          	cmp    %cx,0xa(%eax)
  80a1f1:	75 21                	jne    80a214 <etharp_query+0x140>
  80a1f3:	83 38 00             	cmpl   $0x0,(%eax)
  80a1f6:	74 1c                	je     80a214 <etharp_query+0x140>
  80a1f8:	c7 44 24 08 8e 34 81 	movl   $0x81348e,0x8(%esp)
  80a1ff:	00 
  80a200:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80a207:	00 
  80a208:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  80a20f:	e8 26 4e 00 00       	call   80f03a <_panic>
        if(p->type != PBUF_ROM) {
  80a214:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80a218:	0f 85 b7 00 00 00    	jne    80a2d5 <etharp_query+0x201>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80a21e:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80a220:	85 c0                	test   %eax,%eax
  80a222:	75 c5                	jne    80a1e9 <etharp_query+0x115>
  80a224:	e9 9f 00 00 00       	jmp    80a2c8 <etharp_query+0x1f4>
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  80a229:	8b 45 10             	mov    0x10(%ebp),%eax
  80a22c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a230:	89 3c 24             	mov    %edi,(%esp)
  80a233:	e8 ac b1 ff ff       	call   8053e4 <pbuf_copy>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80a238:	89 7d 10             	mov    %edi,0x10(%ebp)
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  80a23b:	84 c0                	test   %al,%al
  80a23d:	0f 84 bc 00 00 00    	je     80a2ff <etharp_query+0x22b>
            pbuf_free(p);
  80a243:	89 3c 24             	mov    %edi,(%esp)
  80a246:	e8 89 ab ff ff       	call   804dd4 <pbuf_free>
  80a24b:	e9 ab 00 00 00       	jmp    80a2fb <etharp_query+0x227>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
  80a250:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80a256:	8b 7d 10             	mov    0x10(%ebp),%edi
  80a259:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80a25c:	6b d6 1c             	imul   $0x1c,%esi,%edx
  80a25f:	8b 8a 40 5a b3 00    	mov    0xb35a40(%edx),%ecx
  80a265:	85 c9                	test   %ecx,%ecx
  80a267:	74 16                	je     80a27f <etharp_query+0x1ab>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80a269:	8b 11                	mov    (%ecx),%edx
  80a26b:	85 d2                	test   %edx,%edx
  80a26d:	74 04                	je     80a273 <etharp_query+0x19f>
              r = r->next;
  80a26f:	89 d1                	mov    %edx,%ecx
  80a271:	eb f6                	jmp    80a269 <etharp_query+0x195>
            }
            r->next = new_entry;
  80a273:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a275:	b8 00 00 00 00       	mov    $0x0,%eax
  80a27a:	e9 bc 00 00 00       	jmp    80a33b <etharp_query+0x267>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80a27f:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80a282:	89 86 40 5a b3 00    	mov    %eax,0xb35a40(%esi)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a288:	b8 00 00 00 00       	mov    $0x0,%eax
  80a28d:	e9 a9 00 00 00       	jmp    80a33b <etharp_query+0x267>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80a292:	8b 45 10             	mov    0x10(%ebp),%eax
  80a295:	89 04 24             	mov    %eax,(%esp)
  80a298:	e8 37 ab ff ff       	call   804dd4 <pbuf_free>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a29d:	89 d8                	mov    %ebx,%eax
  80a29f:	e9 97 00 00 00       	jmp    80a33b <etharp_query+0x267>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80a2a4:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a2a9:	e9 8d 00 00 00       	jmp    80a33b <etharp_query+0x267>
  80a2ae:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a2b3:	e9 83 00 00 00       	jmp    80a33b <etharp_query+0x267>
  80a2b8:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a2bd:	eb 7c                	jmp    80a33b <etharp_query+0x267>
  80a2bf:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a2c4:	eb 75                	jmp    80a33b <etharp_query+0x267>
  80a2c6:	eb 73                	jmp    80a33b <etharp_query+0x267>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80a2c8:	8b 45 10             	mov    0x10(%ebp),%eax
  80a2cb:	89 04 24             	mov    %eax,(%esp)
  80a2ce:	e8 af af ff ff       	call   805282 <pbuf_ref>
  80a2d3:	eb 2a                	jmp    80a2ff <etharp_query+0x22b>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80a2d5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80a2d9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80a2e0:	00 
  80a2e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a2e5:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80a2ec:	e8 c4 ab ff ff       	call   804eb5 <pbuf_alloc>
  80a2f1:	89 c7                	mov    %eax,%edi
        if(p != NULL) {
  80a2f3:	85 c0                	test   %eax,%eax
  80a2f5:	0f 85 2e ff ff ff    	jne    80a229 <etharp_query+0x155>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a2fb:	89 d8                	mov    %ebx,%eax
  80a2fd:	eb 3c                	jmp    80a33b <etharp_query+0x267>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80a2ff:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80a306:	e8 b7 a6 ff ff       	call   8049c2 <memp_malloc>
        if (new_entry != NULL) {
  80a30b:	85 c0                	test   %eax,%eax
  80a30d:	0f 85 3d ff ff ff    	jne    80a250 <etharp_query+0x17c>
  80a313:	e9 7a ff ff ff       	jmp    80a292 <etharp_query+0x1be>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a318:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a31c:	89 3c 24             	mov    %edi,(%esp)
  80a31f:	e8 7d fc ff ff       	call   809fa1 <etharp_request>
  80a324:	eb 15                	jmp    80a33b <etharp_query+0x267>
  }
  
  /* packet given? */
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80a326:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a329:	83 b8 50 5a b3 00 02 	cmpl   $0x2,0xb35a50(%eax)
  80a330:	0f 84 87 fe ff ff    	je     80a1bd <etharp_query+0xe9>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  80a336:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80a33b:	83 c4 1c             	add    $0x1c,%esp
  80a33e:	5b                   	pop    %ebx
  80a33f:	5e                   	pop    %esi
  80a340:	5f                   	pop    %edi
  80a341:	5d                   	pop    %ebp
  80a342:	c3                   	ret    

0080a343 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80a343:	55                   	push   %ebp
  80a344:	89 e5                	mov    %esp,%ebp
  80a346:	57                   	push   %edi
  80a347:	56                   	push   %esi
  80a348:	53                   	push   %ebx
  80a349:	83 ec 2c             	sub    $0x2c,%esp
  80a34c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a34f:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80a352:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80a359:	00 
  80a35a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a35d:	89 04 24             	mov    %eax,(%esp)
  80a360:	e8 8b a9 ff ff       	call   804cf0 <pbuf_header>
  80a365:	84 c0                	test   %al,%al
  80a367:	0f 85 b4 00 00 00    	jne    80a421 <etharp_output+0xde>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80a36d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a371:	89 34 24             	mov    %esi,(%esp)
  80a374:	e8 f8 c6 ff ff       	call   806a71 <ip_addr_isbroadcast>
  80a379:	84 c0                	test   %al,%al
  80a37b:	0f 85 89 00 00 00    	jne    80a40a <etharp_output+0xc7>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80a381:	8b 3e                	mov    (%esi),%edi
  80a383:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a38a:	e8 0b dc ff ff       	call   807f9a <ntohl>
  80a38f:	21 c7                	and    %eax,%edi
  80a391:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a398:	e8 fd db ff ff       	call   807f9a <ntohl>
  80a39d:	39 c7                	cmp    %eax,%edi
  80a39f:	75 41                	jne    80a3e2 <etharp_output+0x9f>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80a3a1:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80a3a5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80a3a9:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80a3ad:	8b 06                	mov    (%esi),%eax
  80a3af:	89 04 24             	mov    %eax,(%esp)
  80a3b2:	e8 e3 db ff ff       	call   807f9a <ntohl>
  80a3b7:	c1 e8 10             	shr    $0x10,%eax
  80a3ba:	83 e0 7f             	and    $0x7f,%eax
  80a3bd:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80a3c0:	8b 06                	mov    (%esi),%eax
  80a3c2:	89 04 24             	mov    %eax,(%esp)
  80a3c5:	e8 d0 db ff ff       	call   807f9a <ntohl>
  80a3ca:	c1 e8 08             	shr    $0x8,%eax
  80a3cd:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80a3d0:	8b 06                	mov    (%esi),%eax
  80a3d2:	89 04 24             	mov    %eax,(%esp)
  80a3d5:	e8 c0 db ff ff       	call   807f9a <ntohl>
  80a3da:	88 45 e7             	mov    %al,-0x19(%ebp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  80a3dd:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  80a3e0:	eb 2d                	jmp    80a40f <etharp_output+0xcc>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80a3e2:	8b 43 04             	mov    0x4(%ebx),%eax
  80a3e5:	33 06                	xor    (%esi),%eax
  80a3e7:	85 43 08             	test   %eax,0x8(%ebx)
  80a3ea:	74 09                	je     80a3f5 <etharp_output+0xb2>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80a3ec:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80a3f0:	74 36                	je     80a428 <etharp_output+0xe5>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80a3f2:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80a3f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a3f8:	89 44 24 08          	mov    %eax,0x8(%esp)
  80a3fc:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a400:	89 1c 24             	mov    %ebx,(%esp)
  80a403:	e8 cc fc ff ff       	call   80a0d4 <etharp_query>
  80a408:	eb 23                	jmp    80a42d <etharp_output+0xea>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  80a40a:	b8 97 35 81 00       	mov    $0x813597,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80a40f:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80a412:	89 04 24             	mov    %eax,(%esp)
  80a415:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a418:	89 d8                	mov    %ebx,%eax
  80a41a:	e8 ce f6 ff ff       	call   809aed <etharp_send_ip>
  80a41f:	eb 0c                	jmp    80a42d <etharp_output+0xea>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  80a421:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80a426:	eb 05                	jmp    80a42d <etharp_output+0xea>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  80a428:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  80a42d:	83 c4 2c             	add    $0x2c,%esp
  80a430:	5b                   	pop    %ebx
  80a431:	5e                   	pop    %esi
  80a432:	5f                   	pop    %edi
  80a433:	5d                   	pop    %ebp
  80a434:	c3                   	ret    

0080a435 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80a435:	55                   	push   %ebp
  80a436:	89 e5                	mov    %esp,%ebp
  80a438:	56                   	push   %esi
  80a439:	53                   	push   %ebx
  80a43a:	83 ec 10             	sub    $0x10,%esp
  80a43d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a440:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80a443:	8b 43 04             	mov    0x4(%ebx),%eax
  80a446:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80a44a:	89 04 24             	mov    %eax,(%esp)
  80a44d:	e8 f4 d8 ff ff       	call   807d46 <htons>
  80a452:	66 3d 00 08          	cmp    $0x800,%ax
  80a456:	74 0a                	je     80a462 <ethernet_input+0x2d>
  80a458:	66 3d 06 08          	cmp    $0x806,%ax
  80a45c:	74 4e                	je     80a4ac <ethernet_input+0x77>
  80a45e:	66 90                	xchg   %ax,%ax
  80a460:	eb 5f                	jmp    80a4c1 <ethernet_input+0x8c>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80a462:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a466:	89 34 24             	mov    %esi,(%esp)
  80a469:	e8 f5 f8 ff ff       	call   809d63 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80a46e:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80a475:	ff 
  80a476:	89 1c 24             	mov    %ebx,(%esp)
  80a479:	e8 72 a8 ff ff       	call   804cf0 <pbuf_header>
  80a47e:	84 c0                	test   %al,%al
  80a480:	74 1c                	je     80a49e <ethernet_input+0x69>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80a482:	c7 44 24 08 70 35 81 	movl   $0x813570,0x8(%esp)
  80a489:	00 
  80a48a:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80a491:	00 
  80a492:	c7 04 24 32 34 81 00 	movl   $0x813432,(%esp)
  80a499:	e8 9c 4b 00 00       	call   80f03a <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80a49e:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a4a2:	89 1c 24             	mov    %ebx,(%esp)
  80a4a5:	e8 76 c6 ff ff       	call   806b20 <ip_input>
      }
      break;
  80a4aa:	eb 1d                	jmp    80a4c9 <ethernet_input+0x94>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80a4ac:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80a4b0:	8d 46 25             	lea    0x25(%esi),%eax
  80a4b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a4b7:	89 34 24             	mov    %esi,(%esp)
  80a4ba:	e8 f2 f8 ff ff       	call   809db1 <etharp_arp_input>
      break;
  80a4bf:	eb 08                	jmp    80a4c9 <ethernet_input+0x94>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80a4c1:	89 1c 24             	mov    %ebx,(%esp)
  80a4c4:	e8 0b a9 ff ff       	call   804dd4 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80a4c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80a4ce:	83 c4 10             	add    $0x10,%esp
  80a4d1:	5b                   	pop    %ebx
  80a4d2:	5e                   	pop    %esi
  80a4d3:	5d                   	pop    %ebp
  80a4d4:	c3                   	ret    
  80a4d5:	66 90                	xchg   %ax,%ax
  80a4d7:	66 90                	xchg   %ax,%ax
  80a4d9:	66 90                	xchg   %ax,%ax
  80a4db:	66 90                	xchg   %ax,%ax
  80a4dd:	66 90                	xchg   %ax,%ax
  80a4df:	90                   	nop

0080a4e0 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80a4e0:	55                   	push   %ebp
  80a4e1:	89 e5                	mov    %esp,%ebp
  80a4e3:	53                   	push   %ebx
  80a4e4:	83 ec 14             	sub    $0x14,%esp
  80a4e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80a4ea:	8b 43 04             	mov    0x4(%ebx),%eax
  80a4ed:	89 04 24             	mov    %eax,(%esp)
  80a4f0:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80a4f2:	89 1c 24             	mov    %ebx,(%esp)
  80a4f5:	e8 16 6f 00 00       	call   811410 <free>
}
  80a4fa:	83 c4 14             	add    $0x14,%esp
  80a4fd:	5b                   	pop    %ebx
  80a4fe:	5d                   	pop    %ebp
  80a4ff:	c3                   	ret    

0080a500 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80a500:	55                   	push   %ebp
  80a501:	89 e5                	mov    %esp,%ebp
  80a503:	83 ec 18             	sub    $0x18,%esp
  80a506:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a509:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a50e:	89 c8                	mov    %ecx,%eax
  80a510:	f7 e2                	mul    %edx
  80a512:	c1 ea 08             	shr    $0x8,%edx
  80a515:	89 d0                	mov    %edx,%eax
  80a517:	c1 e0 08             	shl    $0x8,%eax
  80a51a:	01 c2                	add    %eax,%edx
  80a51c:	89 c8                	mov    %ecx,%eax
  80a51e:	29 d0                	sub    %edx,%eax
  80a520:	8b 14 85 60 5b b3 00 	mov    0xb35b60(,%eax,4),%edx
  80a527:	eb 26                	jmp    80a54f <timeout_cleanup+0x4f>
	if (t->tid == tid) {
  80a529:	39 0a                	cmp    %ecx,(%edx)
  80a52b:	75 1f                	jne    80a54c <timeout_cleanup+0x4c>
	    LIST_REMOVE(t, link);
  80a52d:	8b 42 08             	mov    0x8(%edx),%eax
  80a530:	85 c0                	test   %eax,%eax
  80a532:	74 06                	je     80a53a <timeout_cleanup+0x3a>
  80a534:	8b 4a 0c             	mov    0xc(%edx),%ecx
  80a537:	89 48 0c             	mov    %ecx,0xc(%eax)
  80a53a:	8b 42 0c             	mov    0xc(%edx),%eax
  80a53d:	8b 4a 08             	mov    0x8(%edx),%ecx
  80a540:	89 08                	mov    %ecx,(%eax)
	    free(t);
  80a542:	89 14 24             	mov    %edx,(%esp)
  80a545:	e8 c6 6e 00 00       	call   811410 <free>
	    goto done;
  80a54a:	eb 07                	jmp    80a553 <timeout_cleanup+0x53>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a54c:	8b 52 08             	mov    0x8(%edx),%edx
  80a54f:	85 d2                	test   %edx,%edx
  80a551:	75 d6                	jne    80a529 <timeout_cleanup+0x29>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80a553:	c9                   	leave  
  80a554:	c3                   	ret    

0080a555 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80a555:	55                   	push   %ebp
  80a556:	89 e5                	mov    %esp,%ebp
  80a558:	56                   	push   %esi
  80a559:	53                   	push   %ebx
  80a55a:	8b 15 80 ad b3 00    	mov    0xb3ad80,%edx
  80a560:	b8 a0 ad b3 00       	mov    $0xb3ada0,%eax
  80a565:	be a0 c1 b3 00       	mov    $0xb3c1a0,%esi
  80a56a:	89 c1                	mov    %eax,%ecx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80a56c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a572:	89 50 0c             	mov    %edx,0xc(%eax)
  80a575:	85 d2                	test   %edx,%edx
  80a577:	74 06                	je     80a57f <sys_init+0x2a>
  80a579:	8d 58 0c             	lea    0xc(%eax),%ebx
  80a57c:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a57f:	c7 41 10 80 ad b3 00 	movl   $0xb3ad80,0x10(%ecx)
  80a586:	83 c0 14             	add    $0x14,%eax

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80a589:	39 f0                	cmp    %esi,%eax
  80a58b:	74 04                	je     80a591 <sys_init+0x3c>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a58d:	89 ca                	mov    %ecx,%edx
  80a58f:	eb d9                	jmp    80a56a <sys_init+0x15>
  80a591:	c7 05 80 ad b3 00 8c 	movl   $0xb3c18c,0xb3ad80
  80a598:	c1 b3 00 
  80a59b:	8b 15 64 5f b3 00    	mov    0xb35f64,%edx
  80a5a1:	b8 80 5f b3 00       	mov    $0xb35f80,%eax
  80a5a6:	be 80 ad b3 00       	mov    $0xb3ad80,%esi
  80a5ab:	89 c1                	mov    %eax,%ecx
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80a5ad:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a5b3:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80a5b9:	85 d2                	test   %edx,%edx
  80a5bb:	74 0c                	je     80a5c9 <sys_init+0x74>
  80a5bd:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80a5c3:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80a5c9:	c7 81 98 00 00 00 64 	movl   $0xb35f64,0x98(%ecx)
  80a5d0:	5f b3 00 
  80a5d3:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80a5d8:	39 f0                	cmp    %esi,%eax
  80a5da:	74 04                	je     80a5e0 <sys_init+0x8b>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a5dc:	89 ca                	mov    %ecx,%edx
  80a5de:	eb cb                	jmp    80a5ab <sys_init+0x56>
  80a5e0:	c7 05 64 5f b3 00 e4 	movl   $0xb3ace4,0xb35f64
  80a5e7:	ac b3 00 
    }
}
  80a5ea:	5b                   	pop    %ebx
  80a5eb:	5e                   	pop    %esi
  80a5ec:	5d                   	pop    %ebp
  80a5ed:	c3                   	ret    

0080a5ee <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80a5ee:	55                   	push   %ebp
  80a5ef:	89 e5                	mov    %esp,%ebp
  80a5f1:	53                   	push   %ebx
  80a5f2:	83 ec 14             	sub    $0x14,%esp
  80a5f5:	8b 4d 08             	mov    0x8(%ebp),%ecx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80a5f8:	a1 80 ad b3 00       	mov    0xb3ad80,%eax
    if (!se) {
  80a5fd:	85 c0                	test   %eax,%eax
  80a5ff:	75 13                	jne    80a614 <sys_sem_new+0x26>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80a601:	c7 04 24 a0 35 81 00 	movl   $0x8135a0,(%esp)
  80a608:	e8 26 4b 00 00       	call   80f133 <cprintf>
	return SYS_SEM_NULL;
  80a60d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a612:	eb 5d                	jmp    80a671 <sys_sem_new+0x83>
    }
    LIST_REMOVE(se, link);
  80a614:	8b 50 0c             	mov    0xc(%eax),%edx
  80a617:	85 d2                	test   %edx,%edx
  80a619:	74 06                	je     80a621 <sys_sem_new+0x33>
  80a61b:	8b 58 10             	mov    0x10(%eax),%ebx
  80a61e:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a621:	8b 50 10             	mov    0x10(%eax),%edx
  80a624:	8b 58 0c             	mov    0xc(%eax),%ebx
  80a627:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80a629:	83 38 00             	cmpl   $0x0,(%eax)
  80a62c:	75 24                	jne    80a652 <sys_sem_new+0x64>
  80a62e:	c7 44 24 0c 15 37 81 	movl   $0x813715,0xc(%esp)
  80a635:	00 
  80a636:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80a63d:	00 
  80a63e:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80a645:	00 
  80a646:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80a64d:	e8 e8 49 00 00       	call   80f03a <_panic>
    se->freed = 0;
  80a652:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80a658:	0f b6 c9             	movzbl %cl,%ecx
  80a65b:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80a65f:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80a663:	2d a0 ad b3 00       	sub    $0xb3ada0,%eax
  80a668:	c1 f8 02             	sar    $0x2,%eax
  80a66b:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80a671:	83 c4 14             	add    $0x14,%esp
  80a674:	5b                   	pop    %ebx
  80a675:	5d                   	pop    %ebp
  80a676:	c3                   	ret    

0080a677 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  80a677:	55                   	push   %ebp
  80a678:	89 e5                	mov    %esp,%ebp
  80a67a:	83 ec 18             	sub    $0x18,%esp
  80a67d:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a680:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a683:	83 3c 95 a0 ad b3 00 	cmpl   $0x0,0xb3ada0(,%edx,4)
  80a68a:	00 
  80a68b:	74 24                	je     80a6b1 <sys_sem_free+0x3a>
  80a68d:	c7 44 24 0c 51 37 81 	movl   $0x813751,0xc(%esp)
  80a694:	00 
  80a695:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80a69c:	00 
  80a69d:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80a6a4:	00 
  80a6a5:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80a6ac:	e8 89 49 00 00       	call   80f03a <_panic>
    sems[sem].freed = 1;
  80a6b1:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  80a6b4:	c1 e1 02             	shl    $0x2,%ecx
  80a6b7:	8d 91 a0 ad b3 00    	lea    0xb3ada0(%ecx),%edx
  80a6bd:	c7 81 a0 ad b3 00 01 	movl   $0x1,0xb3ada0(%ecx)
  80a6c4:	00 00 00 
    sems[sem].gen++;
  80a6c7:	83 42 04 01          	addl   $0x1,0x4(%edx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a6cb:	8b 0d 80 ad b3 00    	mov    0xb3ad80,%ecx
  80a6d1:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80a6d4:	85 c9                	test   %ecx,%ecx
  80a6d6:	74 0d                	je     80a6e5 <sys_sem_free+0x6e>
  80a6d8:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a6db:	8d 14 95 ac ad b3 00 	lea    0xb3adac(,%edx,4),%edx
  80a6e2:	89 51 10             	mov    %edx,0x10(%ecx)
  80a6e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a6ec:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a6ef:	8d 0c 8d a0 ad b3 00 	lea    0xb3ada0(,%ecx,4),%ecx
  80a6f6:	89 0d 80 ad b3 00    	mov    %ecx,0xb3ad80
  80a6fc:	01 d0                	add    %edx,%eax
  80a6fe:	c7 04 85 b0 ad b3 00 	movl   $0xb3ad80,0xb3adb0(,%eax,4)
  80a705:	80 ad b3 00 
}
  80a709:	c9                   	leave  
  80a70a:	c3                   	ret    

0080a70b <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80a70b:	55                   	push   %ebp
  80a70c:	89 e5                	mov    %esp,%ebp
  80a70e:	57                   	push   %edi
  80a70f:	56                   	push   %esi
  80a710:	53                   	push   %ebx
  80a711:	83 ec 1c             	sub    $0x1c,%esp
  80a714:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a717:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a71d:	83 b8 80 5f b3 00 00 	cmpl   $0x0,0xb35f80(%eax)
  80a724:	74 24                	je     80a74a <sys_mbox_free+0x3f>
  80a726:	c7 44 24 0c 62 37 81 	movl   $0x813762,0xc(%esp)
  80a72d:	00 
  80a72e:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80a735:	00 
  80a736:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80a73d:	00 
  80a73e:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80a745:	e8 f0 48 00 00       	call   80f03a <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a74a:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a750:	8b 86 0c 60 b3 00    	mov    0xb3600c(%esi),%eax
  80a756:	89 04 24             	mov    %eax,(%esp)
  80a759:	e8 19 ff ff ff       	call   80a677 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a75e:	8b 86 10 60 b3 00    	mov    0xb36010(%esi),%eax
  80a764:	89 04 24             	mov    %eax,(%esp)
  80a767:	e8 0b ff ff ff       	call   80a677 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a76c:	a1 64 5f b3 00       	mov    0xb35f64,%eax
  80a771:	89 86 14 60 b3 00    	mov    %eax,0xb36014(%esi)
  80a777:	85 c0                	test   %eax,%eax
  80a779:	74 0e                	je     80a789 <sys_mbox_free+0x7e>
  80a77b:	89 f2                	mov    %esi,%edx
  80a77d:	81 c2 14 60 b3 00    	add    $0xb36014,%edx
  80a783:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a789:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a78f:	8d 83 80 5f b3 00    	lea    0xb35f80(%ebx),%eax
  80a795:	a3 64 5f b3 00       	mov    %eax,0xb35f64
  80a79a:	c7 83 18 60 b3 00 64 	movl   $0xb35f64,0xb36018(%ebx)
  80a7a1:	5f b3 00 
    mboxes[mbox].freed = 1;
  80a7a4:	c7 83 80 5f b3 00 01 	movl   $0x1,0xb35f80(%ebx)
  80a7ab:	00 00 00 
}
  80a7ae:	83 c4 1c             	add    $0x1c,%esp
  80a7b1:	5b                   	pop    %ebx
  80a7b2:	5e                   	pop    %esi
  80a7b3:	5f                   	pop    %edi
  80a7b4:	5d                   	pop    %ebp
  80a7b5:	c3                   	ret    

0080a7b6 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80a7b6:	55                   	push   %ebp
  80a7b7:	89 e5                	mov    %esp,%ebp
  80a7b9:	56                   	push   %esi
  80a7ba:	53                   	push   %ebx
  80a7bb:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80a7be:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a7c2:	7e 24                	jle    80a7e8 <sys_mbox_new+0x32>
  80a7c4:	c7 44 24 0c 76 37 81 	movl   $0x813776,0xc(%esp)
  80a7cb:	00 
  80a7cc:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80a7d3:	00 
  80a7d4:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80a7db:	00 
  80a7dc:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80a7e3:	e8 52 48 00 00       	call   80f03a <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a7e8:	8b 1d 64 5f b3 00    	mov    0xb35f64,%ebx
    if (!mbe) {
  80a7ee:	85 db                	test   %ebx,%ebx
  80a7f0:	75 16                	jne    80a808 <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a7f2:	c7 04 24 c8 35 81 00 	movl   $0x8135c8,(%esp)
  80a7f9:	e8 35 49 00 00       	call   80f133 <cprintf>
	return SYS_MBOX_NULL;
  80a7fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a803:	e9 c1 00 00 00       	jmp    80a8c9 <sys_mbox_new+0x113>
    }
    LIST_REMOVE(mbe, link);
  80a808:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a80e:	85 c0                	test   %eax,%eax
  80a810:	74 0c                	je     80a81e <sys_mbox_new+0x68>
  80a812:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a818:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a81e:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a824:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a82a:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a82c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a82f:	75 24                	jne    80a855 <sys_mbox_new+0x9f>
  80a831:	c7 44 24 0c 87 37 81 	movl   $0x813787,0xc(%esp)
  80a838:	00 
  80a839:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80a840:	00 
  80a841:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80a848:	00 
  80a849:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80a850:	e8 e5 47 00 00       	call   80f03a <_panic>
    mbe->freed = 0;
  80a855:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80a85b:	89 de                	mov    %ebx,%esi
  80a85d:	81 ee 80 5f b3 00    	sub    $0xb35f80,%esi
  80a863:	c1 fe 02             	sar    $0x2,%esi
  80a866:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
    mbe->head = -1;
  80a86c:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a873:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a87a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80a881:	e8 68 fd ff ff       	call   80a5ee <sys_sem_new>
  80a886:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a88c:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a893:	e8 56 fd ff ff       	call   80a5ee <sys_sem_new>
  80a898:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a89e:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a8a5:	74 05                	je     80a8ac <sys_mbox_new+0xf6>
  80a8a7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a8aa:	75 1b                	jne    80a8c7 <sys_mbox_new+0x111>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80a8ac:	89 34 24             	mov    %esi,(%esp)
  80a8af:	e8 57 fe ff ff       	call   80a70b <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a8b4:	c7 04 24 f0 35 81 00 	movl   $0x8135f0,(%esp)
  80a8bb:	e8 73 48 00 00       	call   80f133 <cprintf>
	return SYS_MBOX_NULL;
  80a8c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a8c5:	eb 02                	jmp    80a8c9 <sys_mbox_new+0x113>
    }
    return i;
  80a8c7:	89 f0                	mov    %esi,%eax
}
  80a8c9:	83 c4 10             	add    $0x10,%esp
  80a8cc:	5b                   	pop    %ebx
  80a8cd:	5e                   	pop    %esi
  80a8ce:	5d                   	pop    %ebp
  80a8cf:	c3                   	ret    

0080a8d0 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80a8d0:	55                   	push   %ebp
  80a8d1:	89 e5                	mov    %esp,%ebp
  80a8d3:	83 ec 18             	sub    $0x18,%esp
  80a8d6:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a8d9:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a8dc:	83 3c 95 a0 ad b3 00 	cmpl   $0x0,0xb3ada0(,%edx,4)
  80a8e3:	00 
  80a8e4:	74 24                	je     80a90a <sys_sem_signal+0x3a>
  80a8e6:	c7 44 24 0c 51 37 81 	movl   $0x813751,0xc(%esp)
  80a8ed:	00 
  80a8ee:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80a8f5:	00 
  80a8f6:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80a8fd:	00 
  80a8fe:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80a905:	e8 30 47 00 00       	call   80f03a <_panic>
    sems[sem].counter++;
  80a90a:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a90d:	8d 14 95 a0 ad b3 00 	lea    0xb3ada0(,%edx,4),%edx
  80a914:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a919:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a91e:	74 23                	je     80a943 <sys_sem_signal+0x73>
	sems[sem].waiters = 0;
  80a920:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a927:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a92a:	66 c7 04 8d aa ad b3 	movw   $0x0,0xb3adaa(,%ecx,4)
  80a931:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a934:	8d 04 8d a8 ad b3 00 	lea    0xb3ada8(,%ecx,4),%eax
  80a93b:	89 04 24             	mov    %eax,(%esp)
  80a93e:	e8 3c 05 00 00       	call   80ae7f <thread_wakeup>
    }
}
  80a943:	c9                   	leave  
  80a944:	c3                   	ret    

0080a945 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80a945:	55                   	push   %ebp
  80a946:	89 e5                	mov    %esp,%ebp
  80a948:	57                   	push   %edi
  80a949:	56                   	push   %esi
  80a94a:	53                   	push   %ebx
  80a94b:	83 ec 2c             	sub    $0x2c,%esp
  80a94e:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a951:	8b 45 08             	mov    0x8(%ebp),%eax
  80a954:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a957:	83 3c 85 a0 ad b3 00 	cmpl   $0x0,0xb3ada0(,%eax,4)
  80a95e:	00 
  80a95f:	74 24                	je     80a985 <sys_arch_sem_wait+0x40>
  80a961:	c7 44 24 0c 51 37 81 	movl   $0x813751,0xc(%esp)
  80a968:	00 
  80a969:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80a970:	00 
  80a971:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80a978:	00 
  80a979:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80a980:	e8 b5 46 00 00       	call   80f03a <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80a985:	8b 45 08             	mov    0x8(%ebp),%eax
  80a988:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a98b:	8b 04 85 a4 ad b3 00 	mov    0xb3ada4(,%eax,4),%eax
  80a992:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80a995:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80a99a:	8b 45 08             	mov    0x8(%ebp),%eax
  80a99d:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a9a0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a9a3:	e9 90 00 00 00       	jmp    80aa38 <sys_arch_sem_wait+0xf3>
	if (sems[sem].counter > 0) {
  80a9a8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a9ab:	0f b7 04 85 a8 ad b3 	movzwl 0xb3ada8(,%eax,4),%eax
  80a9b2:	00 
  80a9b3:	66 85 c0             	test   %ax,%ax
  80a9b6:	74 18                	je     80a9d0 <sys_arch_sem_wait+0x8b>
	    sems[sem].counter--;
  80a9b8:	8b 55 08             	mov    0x8(%ebp),%edx
  80a9bb:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a9be:	83 e8 01             	sub    $0x1,%eax
  80a9c1:	66 89 04 95 a8 ad b3 	mov    %ax,0xb3ada8(,%edx,4)
  80a9c8:	00 
	    return waited;
  80a9c9:	89 f8                	mov    %edi,%eax
  80a9cb:	e9 84 00 00 00       	jmp    80aa54 <sys_arch_sem_wait+0x10f>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a9d0:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a9d3:	74 7a                	je     80aa4f <sys_arch_sem_wait+0x10a>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80a9d5:	e8 c3 54 00 00       	call   80fe9d <sys_time_msec>
  80a9da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a9dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a9e2:	85 f6                	test   %esi,%esi
  80a9e4:	74 07                	je     80a9ed <sys_arch_sem_wait+0xa8>
  80a9e6:	89 f0                	mov    %esi,%eax
  80a9e8:	29 f8                	sub    %edi,%eax
  80a9ea:	03 45 e4             	add    -0x1c(%ebp),%eax
	    sems[sem].waiters = 1;
  80a9ed:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80a9f0:	8d 1c 8d a0 ad b3 00 	lea    0xb3ada0(,%ecx,4),%ebx
  80a9f7:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a9fd:	89 44 24 08          	mov    %eax,0x8(%esp)
  80aa01:	8b 43 08             	mov    0x8(%ebx),%eax
  80aa04:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aa08:	8d 43 08             	lea    0x8(%ebx),%eax
  80aa0b:	89 04 24             	mov    %eax,(%esp)
  80aa0e:	e8 a6 06 00 00       	call   80b0b9 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80aa13:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aa16:	39 43 04             	cmp    %eax,0x4(%ebx)
  80aa19:	74 13                	je     80aa2e <sys_arch_sem_wait+0xe9>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80aa1b:	c7 04 24 1c 36 81 00 	movl   $0x81361c,(%esp)
  80aa22:	e8 0c 47 00 00       	call   80f133 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80aa27:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aa2c:	eb 26                	jmp    80aa54 <sys_arch_sem_wait+0x10f>
	    }
	    uint32_t b = sys_time_msec();
  80aa2e:	e8 6a 54 00 00       	call   80fe9d <sys_time_msec>
	    waited += (b - a);
  80aa33:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80aa36:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80aa38:	39 f7                	cmp    %esi,%edi
  80aa3a:	0f 82 68 ff ff ff    	jb     80a9a8 <sys_arch_sem_wait+0x63>
  80aa40:	85 f6                	test   %esi,%esi
  80aa42:	0f 84 60 ff ff ff    	je     80a9a8 <sys_arch_sem_wait+0x63>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80aa48:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aa4d:	eb 05                	jmp    80aa54 <sys_arch_sem_wait+0x10f>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80aa4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80aa54:	83 c4 2c             	add    $0x2c,%esp
  80aa57:	5b                   	pop    %ebx
  80aa58:	5e                   	pop    %esi
  80aa59:	5f                   	pop    %edi
  80aa5a:	5d                   	pop    %ebp
  80aa5b:	c3                   	ret    

0080aa5c <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80aa5c:	55                   	push   %ebp
  80aa5d:	89 e5                	mov    %esp,%ebp
  80aa5f:	56                   	push   %esi
  80aa60:	53                   	push   %ebx
  80aa61:	83 ec 10             	sub    $0x10,%esp
  80aa64:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80aa67:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80aa6d:	83 b8 80 5f b3 00 00 	cmpl   $0x0,0xb35f80(%eax)
  80aa74:	74 24                	je     80aa9a <sys_mbox_trypost+0x3e>
  80aa76:	c7 44 24 0c 62 37 81 	movl   $0x813762,0xc(%esp)
  80aa7d:	00 
  80aa7e:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80aa85:	00 
  80aa86:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80aa8d:	00 
  80aa8e:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80aa95:	e8 a0 45 00 00       	call   80f03a <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80aa9a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80aaa1:	00 
  80aaa2:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80aaa8:	8b 86 10 60 b3 00    	mov    0xb36010(%esi),%eax
  80aaae:	89 04 24             	mov    %eax,(%esp)
  80aab1:	e8 8f fe ff ff       	call   80a945 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80aab6:	8b 86 88 5f b3 00    	mov    0xb35f88(%esi),%eax
  80aabc:	81 c6 80 5f b3 00    	add    $0xb35f80,%esi
  80aac2:	3b 46 04             	cmp    0x4(%esi),%eax
  80aac5:	74 53                	je     80ab1a <sys_mbox_trypost+0xbe>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80aac7:	89 f2                	mov    %esi,%edx
  80aac9:	8d 70 01             	lea    0x1(%eax),%esi
  80aacc:	89 f1                	mov    %esi,%ecx
  80aace:	c1 f9 1f             	sar    $0x1f,%ecx
  80aad1:	c1 e9 1b             	shr    $0x1b,%ecx
  80aad4:	01 ce                	add    %ecx,%esi
  80aad6:	83 e6 1f             	and    $0x1f,%esi
  80aad9:	29 ce                	sub    %ecx,%esi
  80aadb:	89 72 08             	mov    %esi,0x8(%edx)
    mboxes[mbox].msg[slot] = msg;
  80aade:	6b cb 27             	imul   $0x27,%ebx,%ecx
  80aae1:	01 c1                	add    %eax,%ecx
  80aae3:	8b 75 0c             	mov    0xc(%ebp),%esi
  80aae6:	89 34 8d 8c 5f b3 00 	mov    %esi,0xb35f8c(,%ecx,4)

    if (mboxes[mbox].head == -1)
  80aaed:	83 7a 04 ff          	cmpl   $0xffffffff,0x4(%edx)
  80aaf1:	75 0c                	jne    80aaff <sys_mbox_trypost+0xa3>
	mboxes[mbox].head = slot;
  80aaf3:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80aaf9:	89 82 84 5f b3 00    	mov    %eax,0xb35f84(%edx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80aaff:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80ab05:	8b 83 0c 60 b3 00    	mov    0xb3600c(%ebx),%eax
  80ab0b:	89 04 24             	mov    %eax,(%esp)
  80ab0e:	e8 bd fd ff ff       	call   80a8d0 <sys_sem_signal>

    return ERR_OK;
  80ab13:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab18:	eb 05                	jmp    80ab1f <sys_mbox_trypost+0xc3>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80ab1a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80ab1f:	83 c4 10             	add    $0x10,%esp
  80ab22:	5b                   	pop    %ebx
  80ab23:	5e                   	pop    %esi
  80ab24:	5d                   	pop    %ebp
  80ab25:	c3                   	ret    

0080ab26 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80ab26:	55                   	push   %ebp
  80ab27:	89 e5                	mov    %esp,%ebp
  80ab29:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80ab2c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ab2f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ab33:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab36:	89 04 24             	mov    %eax,(%esp)
  80ab39:	e8 1e ff ff ff       	call   80aa5c <sys_mbox_trypost>
  80ab3e:	84 c0                	test   %al,%al
  80ab40:	74 24                	je     80ab66 <sys_mbox_post+0x40>
  80ab42:	c7 44 24 0c 48 36 81 	movl   $0x813648,0xc(%esp)
  80ab49:	00 
  80ab4a:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80ab51:	00 
  80ab52:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80ab59:	00 
  80ab5a:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80ab61:	e8 d4 44 00 00       	call   80f03a <_panic>
}
  80ab66:	c9                   	leave  
  80ab67:	c3                   	ret    

0080ab68 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80ab68:	55                   	push   %ebp
  80ab69:	89 e5                	mov    %esp,%ebp
  80ab6b:	57                   	push   %edi
  80ab6c:	56                   	push   %esi
  80ab6d:	53                   	push   %ebx
  80ab6e:	83 ec 1c             	sub    $0x1c,%esp
  80ab71:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ab74:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80ab77:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ab7d:	83 b8 80 5f b3 00 00 	cmpl   $0x0,0xb35f80(%eax)
  80ab84:	74 24                	je     80abaa <sys_arch_mbox_fetch+0x42>
  80ab86:	c7 44 24 0c 62 37 81 	movl   $0x813762,0xc(%esp)
  80ab8d:	00 
  80ab8e:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  80ab95:	00 
  80ab96:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80ab9d:	00 
  80ab9e:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80aba5:	e8 90 44 00 00       	call   80f03a <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80abaa:	8b 45 10             	mov    0x10(%ebp),%eax
  80abad:	89 44 24 04          	mov    %eax,0x4(%esp)
  80abb1:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80abb7:	8b 80 0c 60 b3 00    	mov    0xb3600c(%eax),%eax
  80abbd:	89 04 24             	mov    %eax,(%esp)
  80abc0:	e8 80 fd ff ff       	call   80a945 <sys_arch_sem_wait>
  80abc5:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80abc7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80abca:	0f 84 88 00 00 00    	je     80ac58 <sys_arch_mbox_fetch+0xf0>
	return waited;

    int slot = mboxes[mbox].head;
  80abd0:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80abd6:	8b 80 84 5f b3 00    	mov    0xb35f84(%eax),%eax
    if (slot == -1)
  80abdc:	83 f8 ff             	cmp    $0xffffffff,%eax
  80abdf:	75 1c                	jne    80abfd <sys_arch_mbox_fetch+0x95>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80abe1:	c7 44 24 08 70 36 81 	movl   $0x813670,0x8(%esp)
  80abe8:	00 
  80abe9:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80abf0:	00 
  80abf1:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80abf8:	e8 3d 44 00 00       	call   80f03a <_panic>
    if (msg)
  80abfd:	85 ff                	test   %edi,%edi
  80abff:	74 0e                	je     80ac0f <sys_arch_mbox_fetch+0xa7>
	*msg = mboxes[mbox].msg[slot];
  80ac01:	6b d3 27             	imul   $0x27,%ebx,%edx
  80ac04:	01 c2                	add    %eax,%edx
  80ac06:	8b 14 95 8c 5f b3 00 	mov    0xb35f8c(,%edx,4),%edx
  80ac0d:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80ac0f:	83 c0 01             	add    $0x1,%eax
  80ac12:	99                   	cltd   
  80ac13:	c1 ea 1b             	shr    $0x1b,%edx
  80ac16:	01 d0                	add    %edx,%eax
  80ac18:	83 e0 1f             	and    $0x1f,%eax
  80ac1b:	29 d0                	sub    %edx,%eax
  80ac1d:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80ac23:	89 82 84 5f b3 00    	mov    %eax,0xb35f84(%edx)
  80ac29:	81 c2 80 5f b3 00    	add    $0xb35f80,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80ac2f:	3b 42 08             	cmp    0x8(%edx),%eax
  80ac32:	75 10                	jne    80ac44 <sys_arch_mbox_fetch+0xdc>
	mboxes[mbox].head = -1;
  80ac34:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ac3a:	c7 80 84 5f b3 00 ff 	movl   $0xffffffff,0xb35f84(%eax)
  80ac41:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80ac44:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80ac4a:	8b 83 10 60 b3 00    	mov    0xb36010(%ebx),%eax
  80ac50:	89 04 24             	mov    %eax,(%esp)
  80ac53:	e8 78 fc ff ff       	call   80a8d0 <sys_sem_signal>
    return waited;
}
  80ac58:	89 f0                	mov    %esi,%eax
  80ac5a:	83 c4 1c             	add    $0x1c,%esp
  80ac5d:	5b                   	pop    %ebx
  80ac5e:	5e                   	pop    %esi
  80ac5f:	5f                   	pop    %edi
  80ac60:	5d                   	pop    %ebp
  80ac61:	c3                   	ret    

0080ac62 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80ac62:	55                   	push   %ebp
  80ac63:	89 e5                	mov    %esp,%ebp
  80ac65:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80ac68:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80ac6f:	ff 
  80ac70:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ac73:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ac77:	8b 45 08             	mov    0x8(%ebp),%eax
  80ac7a:	89 04 24             	mov    %eax,(%esp)
  80ac7d:	e8 e6 fe ff ff       	call   80ab68 <sys_arch_mbox_fetch>
}
  80ac82:	c9                   	leave  
  80ac83:	c3                   	ret    

0080ac84 <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80ac84:	55                   	push   %ebp
  80ac85:	89 e5                	mov    %esp,%ebp
  80ac87:	83 ec 28             	sub    $0x28,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80ac8a:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80ac91:	e8 4c 68 00 00       	call   8114e2 <malloc>
    if (lt == 0)
  80ac96:	85 c0                	test   %eax,%eax
  80ac98:	75 1c                	jne    80acb6 <sys_thread_new+0x32>
	panic("sys_thread_new: cannot allocate thread struct");
  80ac9a:	c7 44 24 08 98 36 81 	movl   $0x813698,0x8(%esp)
  80aca1:	00 
  80aca2:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80aca9:	00 
  80acaa:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80acb1:	e8 84 43 00 00       	call   80f03a <_panic>

    if (stacksize > PGSIZE)
  80acb6:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80acbd:	7e 23                	jle    80ace2 <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80acbf:	8b 45 14             	mov    0x14(%ebp),%eax
  80acc2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80acc6:	c7 44 24 08 92 37 81 	movl   $0x813792,0x8(%esp)
  80accd:	00 
  80acce:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80acd5:	00 
  80acd6:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80acdd:	e8 58 43 00 00       	call   80f03a <_panic>

    lt->func = thread;
  80ace2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ace5:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80ace7:	8b 55 10             	mov    0x10(%ebp),%edx
  80acea:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80aced:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80acf1:	c7 44 24 08 e0 a4 80 	movl   $0x80a4e0,0x8(%esp)
  80acf8:	00 
  80acf9:	8b 45 08             	mov    0x8(%ebp),%eax
  80acfc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ad00:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ad03:	89 04 24             	mov    %eax,(%esp)
  80ad06:	e8 e2 01 00 00       	call   80aeed <thread_create>

    if (r < 0)
  80ad0b:	85 c0                	test   %eax,%eax
  80ad0d:	79 28                	jns    80ad37 <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80ad0f:	89 04 24             	mov    %eax,(%esp)
  80ad12:	e8 39 05 00 00       	call   80b250 <e2s>
  80ad17:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ad1b:	c7 44 24 08 c8 36 81 	movl   $0x8136c8,0x8(%esp)
  80ad22:	00 
  80ad23:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80ad2a:	00 
  80ad2b:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80ad32:	e8 03 43 00 00       	call   80f03a <_panic>

    return tid;
}
  80ad37:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ad3a:	c9                   	leave  
  80ad3b:	c3                   	ret    

0080ad3c <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80ad3c:	55                   	push   %ebp
  80ad3d:	89 e5                	mov    %esp,%ebp
  80ad3f:	57                   	push   %edi
  80ad40:	56                   	push   %esi
  80ad41:	53                   	push   %ebx
  80ad42:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80ad45:	e8 29 01 00 00       	call   80ae73 <thread_id>
  80ad4a:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80ad4c:	bf 01 ff 00 ff       	mov    $0xff00ff01,%edi
  80ad51:	f7 e7                	mul    %edi
  80ad53:	c1 ea 08             	shr    $0x8,%edx
  80ad56:	89 d7                	mov    %edx,%edi
  80ad58:	89 d0                	mov    %edx,%eax
  80ad5a:	c1 e0 08             	shl    $0x8,%eax
  80ad5d:	01 c7                	add    %eax,%edi
  80ad5f:	89 f0                	mov    %esi,%eax
  80ad61:	29 f8                	sub    %edi,%eax
  80ad63:	89 c7                	mov    %eax,%edi
  80ad65:	8b 1c 85 60 5b b3 00 	mov    0xb35b60(,%eax,4),%ebx
  80ad6c:	eb 0b                	jmp    80ad79 <sys_arch_timeouts+0x3d>
	if (t->tid == tid)
  80ad6e:	39 33                	cmp    %esi,(%ebx)
  80ad70:	0f 84 b6 00 00 00    	je     80ae2c <sys_arch_timeouts+0xf0>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80ad76:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80ad79:	85 db                	test   %ebx,%ebx
  80ad7b:	75 f1                	jne    80ad6e <sys_arch_timeouts+0x32>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80ad7d:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80ad84:	e8 59 67 00 00       	call   8114e2 <malloc>
  80ad89:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80ad8b:	85 c0                	test   %eax,%eax
  80ad8d:	75 1c                	jne    80adab <sys_arch_timeouts+0x6f>
	panic("sys_arch_timeouts: cannot malloc");
  80ad8f:	c7 44 24 08 f4 36 81 	movl   $0x8136f4,0x8(%esp)
  80ad96:	00 
  80ad97:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80ad9e:	00 
  80ad9f:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80ada6:	e8 8f 42 00 00       	call   80f03a <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80adab:	c7 04 24 00 a5 80 00 	movl   $0x80a500,(%esp)
  80adb2:	e8 0a 01 00 00       	call   80aec1 <thread_onhalt>
    if (r < 0)
  80adb7:	85 c0                	test   %eax,%eax
  80adb9:	79 28                	jns    80ade3 <sys_arch_timeouts+0xa7>
	panic("thread_onhalt failed: %s", e2s(r));
  80adbb:	89 04 24             	mov    %eax,(%esp)
  80adbe:	e8 8d 04 00 00       	call   80b250 <e2s>
  80adc3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80adc7:	c7 44 24 08 a1 37 81 	movl   $0x8137a1,0x8(%esp)
  80adce:	00 
  80adcf:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80add6:	00 
  80add7:	c7 04 24 34 37 81 00 	movl   $0x813734,(%esp)
  80adde:	e8 57 42 00 00       	call   80f03a <_panic>

    t->tid = tid;
  80ade3:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80ade5:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80adec:	00 
  80aded:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80adf4:	00 
  80adf5:	8d 43 04             	lea    0x4(%ebx),%eax
  80adf8:	89 04 24             	mov    %eax,(%esp)
  80adfb:	e8 f7 4a 00 00       	call   80f8f7 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80ae00:	8b 04 bd 60 5b b3 00 	mov    0xb35b60(,%edi,4),%eax
  80ae07:	89 43 08             	mov    %eax,0x8(%ebx)
  80ae0a:	85 c0                	test   %eax,%eax
  80ae0c:	74 0d                	je     80ae1b <sys_arch_timeouts+0xdf>
  80ae0e:	8b 04 bd 60 5b b3 00 	mov    0xb35b60(,%edi,4),%eax
  80ae15:	8d 53 08             	lea    0x8(%ebx),%edx
  80ae18:	89 50 0c             	mov    %edx,0xc(%eax)
  80ae1b:	89 1c bd 60 5b b3 00 	mov    %ebx,0xb35b60(,%edi,4)
  80ae22:	8d 04 bd 60 5b b3 00 	lea    0xb35b60(,%edi,4),%eax
  80ae29:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80ae2c:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80ae2f:	83 c4 1c             	add    $0x1c,%esp
  80ae32:	5b                   	pop    %ebx
  80ae33:	5e                   	pop    %esi
  80ae34:	5f                   	pop    %edi
  80ae35:	5d                   	pop    %ebp
  80ae36:	c3                   	ret    

0080ae37 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80ae37:	55                   	push   %ebp
  80ae38:	89 e5                	mov    %esp,%ebp
}
  80ae3a:	5d                   	pop    %ebp
  80ae3b:	c3                   	ret    

0080ae3c <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80ae3c:	55                   	push   %ebp
  80ae3d:	89 e5                	mov    %esp,%ebp
}
  80ae3f:	5d                   	pop    %ebp
  80ae40:	c3                   	ret    
  80ae41:	66 90                	xchg   %ax,%ax
  80ae43:	66 90                	xchg   %ax,%ax
  80ae45:	66 90                	xchg   %ax,%ax
  80ae47:	66 90                	xchg   %ax,%ax
  80ae49:	66 90                	xchg   %ax,%ax
  80ae4b:	66 90                	xchg   %ax,%ax
  80ae4d:	66 90                	xchg   %ax,%ax
  80ae4f:	90                   	nop

0080ae50 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80ae50:	55                   	push   %ebp
  80ae51:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80ae53:	c7 05 a8 c1 b3 00 00 	movl   $0x0,0xb3c1a8
  80ae5a:	00 00 00 
    tq->tq_last = 0;
  80ae5d:	c7 05 ac c1 b3 00 00 	movl   $0x0,0xb3c1ac
  80ae64:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80ae67:	c7 05 b4 c1 b3 00 00 	movl   $0x0,0xb3c1b4
  80ae6e:	00 00 00 
}
  80ae71:	5d                   	pop    %ebp
  80ae72:	c3                   	ret    

0080ae73 <thread_id>:

uint32_t
thread_id(void) {
  80ae73:	55                   	push   %ebp
  80ae74:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80ae76:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80ae7b:	8b 00                	mov    (%eax),%eax
}
  80ae7d:	5d                   	pop    %ebp
  80ae7e:	c3                   	ret    

0080ae7f <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80ae7f:	55                   	push   %ebp
  80ae80:	89 e5                	mov    %esp,%ebp
  80ae82:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80ae85:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
    while (tc) {
  80ae8a:	eb 0c                	jmp    80ae98 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80ae8c:	39 50 48             	cmp    %edx,0x48(%eax)
  80ae8f:	75 04                	jne    80ae95 <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80ae91:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80ae95:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80ae98:	85 c0                	test   %eax,%eax
  80ae9a:	75 f0                	jne    80ae8c <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80ae9c:	5d                   	pop    %ebp
  80ae9d:	c3                   	ret    

0080ae9e <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80ae9e:	55                   	push   %ebp
  80ae9f:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80aea1:	8b 15 a8 c1 b3 00    	mov    0xb3c1a8,%edx
    int n = 0;
  80aea7:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80aeac:	eb 0d                	jmp    80aebb <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80aeae:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80aeb2:	80 f9 01             	cmp    $0x1,%cl
  80aeb5:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80aeb8:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80aebb:	85 d2                	test   %edx,%edx
  80aebd:	75 ef                	jne    80aeae <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80aebf:	5d                   	pop    %ebp
  80aec0:	c3                   	ret    

0080aec1 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80aec1:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80aec6:	8b 50 60             	mov    0x60(%eax),%edx
  80aec9:	83 fa 03             	cmp    $0x3,%edx
  80aecc:	7f 17                	jg     80aee5 <thread_onhalt+0x24>
    }
    return n;
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80aece:	55                   	push   %ebp
  80aecf:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80aed1:	8d 4a 01             	lea    0x1(%edx),%ecx
  80aed4:	89 48 60             	mov    %ecx,0x60(%eax)
  80aed7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80aeda:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80aede:	b8 00 00 00 00       	mov    $0x0,%eax
  80aee3:	eb 06                	jmp    80aeeb <thread_onhalt+0x2a>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80aee5:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80aeea:	c3                   	ret    

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80aeeb:	5d                   	pop    %ebp
  80aeec:	c3                   	ret    

0080aeed <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80aeed:	55                   	push   %ebp
  80aeee:	89 e5                	mov    %esp,%ebp
  80aef0:	57                   	push   %edi
  80aef1:	56                   	push   %esi
  80aef2:	53                   	push   %ebx
  80aef3:	83 ec 1c             	sub    $0x1c,%esp
  80aef6:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80aef9:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80af00:	e8 dd 65 00 00       	call   8114e2 <malloc>
  80af05:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80af07:	85 c0                	test   %eax,%eax
  80af09:	0f 84 16 01 00 00    	je     80b025 <thread_create+0x138>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80af0f:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80af16:	00 
  80af17:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80af1e:	00 
  80af1f:	89 04 24             	mov    %eax,(%esp)
  80af22:	e8 d0 49 00 00       	call   80f8f7 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80af27:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80af2e:	00 
  80af2f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80af32:	89 44 24 04          	mov    %eax,0x4(%esp)
  80af36:	8d 43 08             	lea    0x8(%ebx),%eax
  80af39:	89 04 24             	mov    %eax,(%esp)
  80af3c:	e8 b1 48 00 00       	call   80f7f2 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80af41:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80af45:	8b 15 b4 c1 b3 00    	mov    0xb3c1b4,%edx
  80af4b:	8d 42 01             	lea    0x1(%edx),%eax
  80af4e:	a3 b4 c1 b3 00       	mov    %eax,0xb3c1b4
    if (max_tid == (uint32_t)~0)
  80af53:	83 f8 ff             	cmp    $0xffffffff,%eax
  80af56:	75 1c                	jne    80af74 <thread_create+0x87>
	panic("alloc_tid: no more thread ids");
  80af58:	c7 44 24 08 ba 37 81 	movl   $0x8137ba,0x8(%esp)
  80af5f:	00 
  80af60:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80af67:	00 
  80af68:	c7 04 24 d8 37 81 00 	movl   $0x8137d8,(%esp)
  80af6f:	e8 c6 40 00 00       	call   80f03a <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80af74:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80af76:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80af7d:	e8 60 65 00 00       	call   8114e2 <malloc>
  80af82:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80af85:	85 c0                	test   %eax,%eax
  80af87:	75 12                	jne    80af9b <thread_create+0xae>
	free(tc);
  80af89:	89 1c 24             	mov    %ebx,(%esp)
  80af8c:	e8 7f 64 00 00       	call   811410 <free>
	return -E_NO_MEM;
  80af91:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80af96:	e9 96 00 00 00       	jmp    80b031 <thread_create+0x144>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80af9b:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80afa1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80afa8:	00 
  80afa9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80afb0:	00 
  80afb1:	89 3c 24             	mov    %edi,(%esp)
  80afb4:	e8 3e 49 00 00       	call   80f8f7 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80afb9:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80afc0:	00 
  80afc1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80afc8:	00 
  80afc9:	8d 43 30             	lea    0x30(%ebx),%eax
  80afcc:	89 04 24             	mov    %eax,(%esp)
  80afcf:	e8 23 49 00 00       	call   80f8f7 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80afd4:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80afd7:	c7 43 30 b7 b1 80 00 	movl   $0x80b1b7,0x30(%ebx)
    tc->tc_entry = entry;
  80afde:	8b 45 10             	mov    0x10(%ebp),%eax
  80afe1:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80afe4:	8b 45 14             	mov    0x14(%ebp),%eax
  80afe7:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80afea:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80aff1:	83 3d a8 c1 b3 00 00 	cmpl   $0x0,0xb3c1a8
  80aff8:	75 0e                	jne    80b008 <thread_create+0x11b>
	tq->tq_first = tc;
  80affa:	89 1d a8 c1 b3 00    	mov    %ebx,0xb3c1a8
	tq->tq_last = tc;
  80b000:	89 1d ac c1 b3 00    	mov    %ebx,0xb3c1ac
  80b006:	eb 0e                	jmp    80b016 <thread_create+0x129>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b008:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80b00d:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80b010:	89 1d ac c1 b3 00    	mov    %ebx,0xb3c1ac

    threadq_push(&thread_queue, tc);

    if (tid)
  80b016:	85 f6                	test   %esi,%esi
  80b018:	74 12                	je     80b02c <thread_create+0x13f>
	*tid = tc->tc_tid;
  80b01a:	8b 03                	mov    (%ebx),%eax
  80b01c:	89 06                	mov    %eax,(%esi)
    return 0;
  80b01e:	b8 00 00 00 00       	mov    $0x0,%eax
  80b023:	eb 0c                	jmp    80b031 <thread_create+0x144>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80b025:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80b02a:	eb 05                	jmp    80b031 <thread_create+0x144>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80b02c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b031:	83 c4 1c             	add    $0x1c,%esp
  80b034:	5b                   	pop    %ebx
  80b035:	5e                   	pop    %esi
  80b036:	5f                   	pop    %edi
  80b037:	5d                   	pop    %ebp
  80b038:	c3                   	ret    

0080b039 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80b039:	55                   	push   %ebp
  80b03a:	89 e5                	mov    %esp,%ebp
  80b03c:	53                   	push   %ebx
  80b03d:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80b040:	8b 1d a8 c1 b3 00    	mov    0xb3c1a8,%ebx
  80b046:	85 db                	test   %ebx,%ebx
  80b048:	74 69                	je     80b0b3 <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80b04a:	8b 43 64             	mov    0x64(%ebx),%eax
  80b04d:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
    tc->tc_queue_link = 0;
  80b052:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80b059:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b05e:	85 c0                	test   %eax,%eax
  80b060:	74 3e                	je     80b0a0 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80b062:	83 c0 30             	add    $0x30,%eax
  80b065:	89 04 24             	mov    %eax,(%esp)
  80b068:	e8 73 01 00 00       	call   80b1e0 <jos_setjmp>
  80b06d:	85 c0                	test   %eax,%eax
  80b06f:	75 42                	jne    80b0b3 <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80b071:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b076:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80b07d:	83 3d a8 c1 b3 00 00 	cmpl   $0x0,0xb3c1a8
  80b084:	75 0c                	jne    80b092 <thread_yield+0x59>
	tq->tq_first = tc;
  80b086:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
	tq->tq_last = tc;
  80b08b:	a3 ac c1 b3 00       	mov    %eax,0xb3c1ac
  80b090:	eb 0e                	jmp    80b0a0 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b092:	8b 15 ac c1 b3 00    	mov    0xb3c1ac,%edx
  80b098:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b09b:	a3 ac c1 b3 00       	mov    %eax,0xb3c1ac
    }

    cur_tc = next_tc;
  80b0a0:	89 1d b0 c1 b3 00    	mov    %ebx,0xb3c1b0
    jos_longjmp(&cur_tc->tc_jb, 1);
  80b0a6:	8d 43 30             	lea    0x30(%ebx),%eax
  80b0a9:	ba 01 00 00 00       	mov    $0x1,%edx
  80b0ae:	e8 5d 01 00 00       	call   80b210 <jos_longjmp>
}
  80b0b3:	83 c4 14             	add    $0x14,%esp
  80b0b6:	5b                   	pop    %ebx
  80b0b7:	5d                   	pop    %ebp
  80b0b8:	c3                   	ret    

0080b0b9 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80b0b9:	55                   	push   %ebp
  80b0ba:	89 e5                	mov    %esp,%ebp
  80b0bc:	57                   	push   %edi
  80b0bd:	56                   	push   %esi
  80b0be:	53                   	push   %ebx
  80b0bf:	83 ec 0c             	sub    $0xc,%esp
  80b0c2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b0c5:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80b0c8:	e8 d0 4d 00 00       	call   80fe9d <sys_time_msec>
  80b0cd:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80b0cf:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b0d4:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b0d7:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80b0db:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b0dd:	eb 26                	jmp    80b105 <thread_wait+0x4c>
	if (p < s)
  80b0df:	39 f0                	cmp    %esi,%eax
  80b0e1:	72 26                	jb     80b109 <thread_wait+0x50>
	    break;
	if (addr && *addr != val)
  80b0e3:	85 db                	test   %ebx,%ebx
  80b0e5:	74 07                	je     80b0ee <thread_wait+0x35>
  80b0e7:	8b 03                	mov    (%ebx),%eax
  80b0e9:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80b0ec:	75 1b                	jne    80b109 <thread_wait+0x50>
	    break;
	if (cur_tc->tc_wakeup)
  80b0ee:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b0f3:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80b0f7:	84 c0                	test   %al,%al
  80b0f9:	75 0e                	jne    80b109 <thread_wait+0x50>
	    break;

	thread_yield();
  80b0fb:	e8 39 ff ff ff       	call   80b039 <thread_yield>
	p = sys_time_msec();
  80b100:	e8 98 4d 00 00       	call   80fe9d <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b105:	39 f8                	cmp    %edi,%eax
  80b107:	72 d6                	jb     80b0df <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80b109:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b10e:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b115:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80b119:	83 c4 0c             	add    $0xc,%esp
  80b11c:	5b                   	pop    %ebx
  80b11d:	5e                   	pop    %esi
  80b11e:	5f                   	pop    %edi
  80b11f:	5d                   	pop    %ebp
  80b120:	c3                   	ret    

0080b121 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80b121:	55                   	push   %ebp
  80b122:	89 e5                	mov    %esp,%ebp
  80b124:	56                   	push   %esi
  80b125:	53                   	push   %ebx
  80b126:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80b129:	8b 1d a0 c1 b3 00    	mov    0xb3c1a0,%ebx
  80b12f:	85 db                	test   %ebx,%ebx
  80b131:	74 3a                	je     80b16d <thread_halt+0x4c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80b133:	8b 43 64             	mov    0x64(%ebx),%eax
  80b136:	a3 a0 c1 b3 00       	mov    %eax,0xb3c1a0
    tc->tc_queue_link = 0;
  80b13b:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80b142:	be 00 00 00 00       	mov    $0x0,%esi
  80b147:	eb 0c                	jmp    80b155 <thread_halt+0x34>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80b149:	8b 03                	mov    (%ebx),%eax
  80b14b:	89 04 24             	mov    %eax,(%esp)
  80b14e:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80b152:	83 c6 01             	add    $0x1,%esi
  80b155:	3b 73 60             	cmp    0x60(%ebx),%esi
  80b158:	7c ef                	jl     80b149 <thread_halt+0x28>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80b15a:	8b 43 04             	mov    0x4(%ebx),%eax
  80b15d:	89 04 24             	mov    %eax,(%esp)
  80b160:	e8 ab 62 00 00       	call   811410 <free>
    free(tc);
  80b165:	89 1c 24             	mov    %ebx,(%esp)
  80b168:	e8 a3 62 00 00       	call   811410 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80b16d:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b172:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80b179:	83 3d a0 c1 b3 00 00 	cmpl   $0x0,0xb3c1a0
  80b180:	75 0c                	jne    80b18e <thread_halt+0x6d>
	tq->tq_first = tc;
  80b182:	a3 a0 c1 b3 00       	mov    %eax,0xb3c1a0
	tq->tq_last = tc;
  80b187:	a3 a4 c1 b3 00       	mov    %eax,0xb3c1a4
  80b18c:	eb 0e                	jmp    80b19c <thread_halt+0x7b>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b18e:	8b 15 a4 c1 b3 00    	mov    0xb3c1a4,%edx
  80b194:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b197:	a3 a4 c1 b3 00       	mov    %eax,0xb3c1a4
    cur_tc = NULL;
  80b19c:	c7 05 b0 c1 b3 00 00 	movl   $0x0,0xb3c1b0
  80b1a3:	00 00 00 
    thread_yield();
  80b1a6:	e8 8e fe ff ff       	call   80b039 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80b1ab:	e8 71 3e 00 00       	call   80f021 <exit>
}
  80b1b0:	83 c4 10             	add    $0x10,%esp
  80b1b3:	5b                   	pop    %ebx
  80b1b4:	5e                   	pop    %esi
  80b1b5:	5d                   	pop    %ebp
  80b1b6:	c3                   	ret    

0080b1b7 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80b1b7:	55                   	push   %ebp
  80b1b8:	89 e5                	mov    %esp,%ebp
  80b1ba:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80b1bd:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b1c2:	8b 50 2c             	mov    0x2c(%eax),%edx
  80b1c5:	89 14 24             	mov    %edx,(%esp)
  80b1c8:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80b1cb:	e8 51 ff ff ff       	call   80b121 <thread_halt>
}
  80b1d0:	c9                   	leave  
  80b1d1:	c3                   	ret    
  80b1d2:	66 90                	xchg   %ax,%ax
  80b1d4:	66 90                	xchg   %ax,%ax
  80b1d6:	66 90                	xchg   %ax,%ax
  80b1d8:	66 90                	xchg   %ax,%ax
  80b1da:	66 90                	xchg   %ax,%ax
  80b1dc:	66 90                	xchg   %ax,%ax
  80b1de:	66 90                	xchg   %ax,%ax

0080b1e0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80b1e0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80b1e4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80b1e7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80b1e9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80b1ed:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80b1f0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80b1f3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80b1f6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80b1f9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80b1fc:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80b201:	c3                   	ret    
  80b202:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80b209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080b210 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80b210:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80b212:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80b215:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80b218:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80b21b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80b21e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80b221:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80b223:	ff e1                	jmp    *%ecx

0080b225 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80b225:	55                   	push   %ebp
  80b226:	89 e5                	mov    %esp,%ebp
  80b228:	83 ec 18             	sub    $0x18,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80b22b:	a1 00 c2 b3 00       	mov    0xb3c200,%eax
};

void
perror(const char *s) {
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80b230:	8b 04 85 20 50 81 00 	mov    0x815020(,%eax,4),%eax
  80b237:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b23b:	8b 45 08             	mov    0x8(%ebp),%eax
  80b23e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b242:	c7 04 24 f3 37 81 00 	movl   $0x8137f3,(%esp)
  80b249:	e8 e5 3e 00 00       	call   80f133 <cprintf>
}
  80b24e:	c9                   	leave  
  80b24f:	c3                   	ret    

0080b250 <e2s>:

const char *
e2s(int err) {
  80b250:	55                   	push   %ebp
  80b251:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80b253:	8b 45 08             	mov    0x8(%ebp),%eax
  80b256:	8b 04 85 20 50 81 00 	mov    0x815020(,%eax,4),%eax
}
  80b25d:	5d                   	pop    %ebp
  80b25e:	c3                   	ret    
  80b25f:	90                   	nop

0080b260 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80b260:	55                   	push   %ebp
  80b261:	89 e5                	mov    %esp,%ebp
  80b263:	57                   	push   %edi
  80b264:	56                   	push   %esi
  80b265:	53                   	push   %ebx
  80b266:	83 ec 2c             	sub    $0x2c,%esp
  80b269:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80b26c:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80b273:	00 
  80b274:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b27b:	10 
  80b27c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b283:	e8 8d 49 00 00       	call   80fc15 <sys_page_alloc>
    if (r < 0)
  80b288:	85 c0                	test   %eax,%eax
  80b28a:	79 1c                	jns    80b2a8 <low_level_output+0x48>
	panic("jif: could not allocate page of memory");
  80b28c:	c7 44 24 08 d8 3c 81 	movl   $0x813cd8,0x8(%esp)
  80b293:	00 
  80b294:	c7 44 24 04 56 00 00 	movl   $0x56,0x4(%esp)
  80b29b:	00 
  80b29c:	c7 04 24 29 3d 81 00 	movl   $0x813d29,(%esp)
  80b2a3:	e8 92 3d 00 00       	call   80f03a <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80b2a8:	8b 45 08             	mov    0x8(%ebp),%eax
  80b2ab:	8b 40 1c             	mov    0x1c(%eax),%eax
  80b2ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80b2b1:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80b2b6:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b2bb:	eb 57                	jmp    80b314 <low_level_output+0xb4>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80b2bd:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b2c1:	0f b7 d0             	movzwl %ax,%edx
  80b2c4:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80b2c7:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80b2cd:	7e 24                	jle    80b2f3 <low_level_output+0x93>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80b2cf:	89 74 24 10          	mov    %esi,0x10(%esp)
  80b2d3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80b2d7:	c7 44 24 08 00 3d 81 	movl   $0x813d00,0x8(%esp)
  80b2de:	00 
  80b2df:	c7 44 24 04 65 00 00 	movl   $0x65,0x4(%esp)
  80b2e6:	00 
  80b2e7:	c7 04 24 29 3d 81 00 	movl   $0x813d29,(%esp)
  80b2ee:	e8 47 3d 00 00       	call   80f03a <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80b2f3:	0f b7 c0             	movzwl %ax,%eax
  80b2f6:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b2fa:	8b 43 04             	mov    0x4(%ebx),%eax
  80b2fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b301:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80b304:	89 04 24             	mov    %eax,(%esp)
  80b307:	e8 a0 46 00 00       	call   80f9ac <memcpy>
	txsize += q->len;
  80b30c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b310:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b312:	8b 1b                	mov    (%ebx),%ebx
  80b314:	85 db                	test   %ebx,%ebx
  80b316:	75 a5                	jne    80b2bd <low_level_output+0x5d>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80b318:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80b31e:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80b325:	00 
  80b326:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80b32d:	10 
  80b32e:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80b335:	00 
  80b336:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b339:	8b 40 04             	mov    0x4(%eax),%eax
  80b33c:	89 04 24             	mov    %eax,(%esp)
  80b33f:	e8 f4 51 00 00       	call   810538 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80b344:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b34b:	10 
  80b34c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b353:	e8 64 49 00 00       	call   80fcbc <sys_page_unmap>

    return ERR_OK;
}
  80b358:	b8 00 00 00 00       	mov    $0x0,%eax
  80b35d:	83 c4 2c             	add    $0x2c,%esp
  80b360:	5b                   	pop    %ebx
  80b361:	5e                   	pop    %esi
  80b362:	5f                   	pop    %edi
  80b363:	5d                   	pop    %ebp
  80b364:	c3                   	ret    

0080b365 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80b365:	55                   	push   %ebp
  80b366:	89 e5                	mov    %esp,%ebp
  80b368:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80b36b:	8b 45 10             	mov    0x10(%ebp),%eax
  80b36e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b372:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b375:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b379:	8b 45 08             	mov    0x8(%ebp),%eax
  80b37c:	89 04 24             	mov    %eax,(%esp)
  80b37f:	e8 bf ef ff ff       	call   80a343 <etharp_output>
}
  80b384:	c9                   	leave  
  80b385:	c3                   	ret    

0080b386 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80b386:	55                   	push   %ebp
  80b387:	89 e5                	mov    %esp,%ebp
  80b389:	57                   	push   %edi
  80b38a:	56                   	push   %esi
  80b38b:	53                   	push   %ebx
  80b38c:	83 ec 2c             	sub    $0x2c,%esp
  80b38f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80b392:	8b 45 08             	mov    0x8(%ebp),%eax
  80b395:	8b 40 1c             	mov    0x1c(%eax),%eax
  80b398:	89 45 d8             	mov    %eax,-0x28(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80b39b:	8b 03                	mov    (%ebx),%eax
  80b39d:	89 c7                	mov    %eax,%edi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80b39f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80b3a6:	00 
  80b3a7:	0f b7 c0             	movzwl %ax,%eax
  80b3aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b3ae:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80b3b5:	e8 fb 9a ff ff       	call   804eb5 <pbuf_alloc>
  80b3ba:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80b3bd:	85 c0                	test   %eax,%eax
  80b3bf:	0f 84 c1 00 00 00    	je     80b486 <jif_input+0x100>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80b3c5:	8d 53 04             	lea    0x4(%ebx),%edx
  80b3c8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b3cb:	89 c3                	mov    %eax,%ebx
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
  80b3cd:	be 00 00 00 00       	mov    $0x0,%esi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80b3d2:	0f bf c7             	movswl %di,%eax
  80b3d5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80b3d8:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
	if (bytes > (len - copied))
  80b3dc:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80b3df:	29 f7                	sub    %esi,%edi
  80b3e1:	39 c7                	cmp    %eax,%edi
  80b3e3:	0f 4f f8             	cmovg  %eax,%edi
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80b3e6:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b3ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b3ed:	01 f0                	add    %esi,%eax
  80b3ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b3f3:	8b 43 04             	mov    0x4(%ebx),%eax
  80b3f6:	89 04 24             	mov    %eax,(%esp)
  80b3f9:	e8 ae 45 00 00       	call   80f9ac <memcpy>
	copied += bytes;
  80b3fe:	01 fe                	add    %edi,%esi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b400:	8b 1b                	mov    (%ebx),%ebx
  80b402:	85 db                	test   %ebx,%ebx
  80b404:	75 d2                	jne    80b3d8 <jif_input+0x52>
  80b406:	eb 5e                	jmp    80b466 <jif_input+0xe0>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80b408:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80b40b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b40f:	8b 45 08             	mov    0x8(%ebp),%eax
  80b412:	89 04 24             	mov    %eax,(%esp)
  80b415:	e8 49 e9 ff ff       	call   809d63 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80b41a:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80b421:	ff 
  80b422:	89 34 24             	mov    %esi,(%esp)
  80b425:	e8 c6 98 ff ff       	call   804cf0 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80b42a:	8b 45 08             	mov    0x8(%ebp),%eax
  80b42d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b431:	89 34 24             	mov    %esi,(%esp)
  80b434:	8b 45 08             	mov    0x8(%ebp),%eax
  80b437:	ff 50 10             	call   *0x10(%eax)
	break;
  80b43a:	eb 4a                	jmp    80b486 <jif_input+0x100>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80b43c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b43f:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b443:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80b446:	8b 00                	mov    (%eax),%eax
  80b448:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b44c:	8b 45 08             	mov    0x8(%ebp),%eax
  80b44f:	89 04 24             	mov    %eax,(%esp)
  80b452:	e8 5a e9 ff ff       	call   809db1 <etharp_arp_input>
	break;
  80b457:	eb 2d                	jmp    80b486 <jif_input+0x100>

    default:
	pbuf_free(p);
  80b459:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b45c:	89 04 24             	mov    %eax,(%esp)
  80b45f:	e8 70 99 ff ff       	call   804dd4 <pbuf_free>
  80b464:	eb 20                	jmp    80b486 <jif_input+0x100>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80b466:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b469:	8b 40 04             	mov    0x4(%eax),%eax
  80b46c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b470:	89 04 24             	mov    %eax,(%esp)
  80b473:	e8 ce c8 ff ff       	call   807d46 <htons>
  80b478:	66 3d 00 08          	cmp    $0x800,%ax
  80b47c:	74 8a                	je     80b408 <jif_input+0x82>
  80b47e:	66 3d 06 08          	cmp    $0x806,%ax
  80b482:	74 b8                	je     80b43c <jif_input+0xb6>
  80b484:	eb d3                	jmp    80b459 <jif_input+0xd3>
	break;

    default:
	pbuf_free(p);
    }
}
  80b486:	83 c4 2c             	add    $0x2c,%esp
  80b489:	5b                   	pop    %ebx
  80b48a:	5e                   	pop    %esi
  80b48b:	5f                   	pop    %edi
  80b48c:	5d                   	pop    %ebp
  80b48d:	c3                   	ret    

0080b48e <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80b48e:	55                   	push   %ebp
  80b48f:	89 e5                	mov    %esp,%ebp
  80b491:	57                   	push   %edi
  80b492:	56                   	push   %esi
  80b493:	53                   	push   %ebx
  80b494:	83 ec 2c             	sub    $0x2c,%esp
  80b497:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80b49a:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80b4a1:	e8 f9 92 ff ff       	call   80479f <mem_malloc>
  80b4a6:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80b4a8:	85 c0                	test   %eax,%eax
  80b4aa:	74 7c                	je     80b528 <jif_init+0x9a>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80b4ac:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80b4af:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80b4b2:	c7 43 14 65 b3 80 00 	movl   $0x80b365,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80b4b9:	c7 43 18 60 b2 80 00 	movl   $0x80b260,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80b4c0:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80b4c7:	00 
  80b4c8:	c7 44 24 04 62 4a 81 	movl   $0x814a62,0x4(%esp)
  80b4cf:	00 
  80b4d0:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80b4d3:	89 04 24             	mov    %eax,(%esp)
  80b4d6:	e8 d1 44 00 00       	call   80f9ac <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80b4db:	8d 43 25             	lea    0x25(%ebx),%eax
  80b4de:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80b4e0:	8b 17                	mov    (%edi),%edx
  80b4e2:	89 56 04             	mov    %edx,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80b4e5:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80b4e9:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80b4ef:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    // netif->hwaddr[1] = 0x54;
    // netif->hwaddr[2] = 0x00;
    // netif->hwaddr[3] = 0x12;
    // netif->hwaddr[4] = 0x34;
    // netif->hwaddr[5] = 0x56;
    sys_read_mac(netif->hwaddr);
  80b4f3:	89 04 24             	mov    %eax,(%esp)
  80b4f6:	e8 03 4a 00 00       	call   80fefe <sys_read_mac>
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80b4fb:	c7 04 24 0b 21 81 00 	movl   $0x81210b,(%esp)
  80b502:	e8 6e ca ff ff       	call   807f75 <inet_addr>
  80b507:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80b50a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b511:	00 
  80b512:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b515:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b519:	89 1c 24             	mov    %ebx,(%esp)
  80b51c:	e8 b3 eb ff ff       	call   80a0d4 <etharp_query>

    return ERR_OK;
  80b521:	b8 00 00 00 00       	mov    $0x0,%eax
  80b526:	eb 05                	jmp    80b52d <jif_init+0x9f>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80b528:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80b52d:	83 c4 2c             	add    $0x2c,%esp
  80b530:	5b                   	pop    %ebx
  80b531:	5e                   	pop    %esi
  80b532:	5f                   	pop    %edi
  80b533:	5d                   	pop    %ebp
  80b534:	c3                   	ret    

0080b535 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80b535:	55                   	push   %ebp
  80b536:	89 e5                	mov    %esp,%ebp
  80b538:	56                   	push   %esi
  80b539:	53                   	push   %ebx
  80b53a:	83 ec 30             	sub    $0x30,%esp
  80b53d:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80b540:	8b 45 10             	mov    0x10(%ebp),%eax
  80b543:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b547:	8b 45 08             	mov    0x8(%ebp),%eax
  80b54a:	89 04 24             	mov    %eax,(%esp)
  80b54d:	e8 48 10 00 00       	call   80c59a <netconn_alloc>
  80b552:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80b554:	85 c0                	test   %eax,%eax
  80b556:	0f 84 d8 00 00 00    	je     80b634 <netconn_new_with_proto_and_callback+0xff>
    msg.function = do_newconn;
  80b55c:	c7 45 e4 93 c4 80 00 	movl   $0x80c493,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80b563:	89 f0                	mov    %esi,%eax
  80b565:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80b568:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80b56b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b56e:	89 04 24             	mov    %eax,(%esp)
  80b571:	e8 95 71 ff ff       	call   80270b <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80b576:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b57a:	0f 84 b6 00 00 00    	je     80b636 <netconn_new_with_proto_and_callback+0x101>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80b580:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b584:	74 1c                	je     80b5a2 <netconn_new_with_proto_and_callback+0x6d>
  80b586:	c7 44 24 08 40 3d 81 	movl   $0x813d40,0x8(%esp)
  80b58d:	00 
  80b58e:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80b595:	00 
  80b596:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b59d:	e8 98 3a 00 00       	call   80f03a <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80b5a2:	8b 43 10             	mov    0x10(%ebx),%eax
  80b5a5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b5a8:	75 1c                	jne    80b5c6 <netconn_new_with_proto_and_callback+0x91>
  80b5aa:	c7 44 24 08 09 3e 81 	movl   $0x813e09,0x8(%esp)
  80b5b1:	00 
  80b5b2:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80b5b9:	00 
  80b5ba:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b5c1:	e8 74 3a 00 00       	call   80f03a <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80b5c6:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b5ca:	75 1c                	jne    80b5e8 <netconn_new_with_proto_and_callback+0xb3>
  80b5cc:	c7 44 24 08 22 3e 81 	movl   $0x813e22,0x8(%esp)
  80b5d3:	00 
  80b5d4:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80b5db:	00 
  80b5dc:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b5e3:	e8 52 3a 00 00       	call   80f03a <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80b5e8:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b5ec:	74 1c                	je     80b60a <netconn_new_with_proto_and_callback+0xd5>
  80b5ee:	c7 44 24 08 64 3d 81 	movl   $0x813d64,0x8(%esp)
  80b5f5:	00 
  80b5f6:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80b5fd:	00 
  80b5fe:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b605:	e8 30 3a 00 00       	call   80f03a <_panic>
      sys_sem_free(conn->op_completed);
  80b60a:	89 04 24             	mov    %eax,(%esp)
  80b60d:	e8 65 f0 ff ff       	call   80a677 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80b612:	8b 43 14             	mov    0x14(%ebx),%eax
  80b615:	89 04 24             	mov    %eax,(%esp)
  80b618:	e8 ee f0 ff ff       	call   80a70b <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80b61d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80b621:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80b628:	e8 f5 93 ff ff       	call   804a22 <memp_free>
      return NULL;
  80b62d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b632:	eb 04                	jmp    80b638 <netconn_new_with_proto_and_callback+0x103>
  80b634:	eb 02                	jmp    80b638 <netconn_new_with_proto_and_callback+0x103>
    }
  }
  return conn;
  80b636:	89 d8                	mov    %ebx,%eax
}
  80b638:	83 c4 30             	add    $0x30,%esp
  80b63b:	5b                   	pop    %ebx
  80b63c:	5e                   	pop    %esi
  80b63d:	5d                   	pop    %ebp
  80b63e:	c3                   	ret    

0080b63f <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80b63f:	55                   	push   %ebp
  80b640:	89 e5                	mov    %esp,%ebp
  80b642:	53                   	push   %ebx
  80b643:	83 ec 34             	sub    $0x34,%esp
  80b646:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80b649:	85 db                	test   %ebx,%ebx
  80b64b:	74 24                	je     80b671 <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80b64d:	c7 45 e4 ef c7 80 00 	movl   $0x80c7ef,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b654:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b657:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b65a:	89 04 24             	mov    %eax,(%esp)
  80b65d:	e8 a9 70 ff ff       	call   80270b <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80b662:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80b669:	89 1c 24             	mov    %ebx,(%esp)
  80b66c:	e8 e7 0f 00 00       	call   80c658 <netconn_free>

  return ERR_OK;
}
  80b671:	b8 00 00 00 00       	mov    $0x0,%eax
  80b676:	83 c4 34             	add    $0x34,%esp
  80b679:	5b                   	pop    %ebx
  80b67a:	5d                   	pop    %ebp
  80b67b:	c3                   	ret    

0080b67c <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80b67c:	55                   	push   %ebp
  80b67d:	89 e5                	mov    %esp,%ebp
  80b67f:	83 ec 18             	sub    $0x18,%esp
  80b682:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b685:	85 c0                	test   %eax,%eax
  80b687:	75 1c                	jne    80b6a5 <netconn_type+0x29>
  80b689:	c7 44 24 08 37 3e 81 	movl   $0x813e37,0x8(%esp)
  80b690:	00 
  80b691:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80b698:	00 
  80b699:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b6a0:	e8 95 39 00 00       	call   80f03a <_panic>
  80b6a5:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80b6a7:	c9                   	leave  
  80b6a8:	c3                   	ret    

0080b6a9 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80b6a9:	55                   	push   %ebp
  80b6aa:	89 e5                	mov    %esp,%ebp
  80b6ac:	53                   	push   %ebx
  80b6ad:	83 ec 34             	sub    $0x34,%esp
  80b6b0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b6b3:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b6b6:	8b 45 10             	mov    0x10(%ebp),%eax
  80b6b9:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b6bc:	85 db                	test   %ebx,%ebx
  80b6be:	75 1c                	jne    80b6dc <netconn_getaddr+0x33>
  80b6c0:	c7 44 24 08 52 3e 81 	movl   $0x813e52,0x8(%esp)
  80b6c7:	00 
  80b6c8:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80b6cf:	00 
  80b6d0:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b6d7:	e8 5e 39 00 00       	call   80f03a <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b6dc:	85 d2                	test   %edx,%edx
  80b6de:	75 1c                	jne    80b6fc <netconn_getaddr+0x53>
  80b6e0:	c7 44 24 08 70 3e 81 	movl   $0x813e70,0x8(%esp)
  80b6e7:	00 
  80b6e8:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80b6ef:	00 
  80b6f0:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b6f7:	e8 3e 39 00 00       	call   80f03a <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b6fc:	85 c0                	test   %eax,%eax
  80b6fe:	75 1c                	jne    80b71c <netconn_getaddr+0x73>
  80b700:	c7 44 24 08 8e 3e 81 	movl   $0x813e8e,0x8(%esp)
  80b707:	00 
  80b708:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80b70f:	00 
  80b710:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b717:	e8 1e 39 00 00       	call   80f03a <_panic>

  msg.function = do_getaddr;
  80b71c:	c7 45 e4 60 cc 80 00 	movl   $0x80cc60,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b723:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80b726:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80b729:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80b72c:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80b72f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b732:	89 04 24             	mov    %eax,(%esp)
  80b735:	e8 d1 6f ff ff       	call   80270b <tcpip_apimsg>

  return conn->err;
  80b73a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b73e:	83 c4 34             	add    $0x34,%esp
  80b741:	5b                   	pop    %ebx
  80b742:	5d                   	pop    %ebp
  80b743:	c3                   	ret    

0080b744 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b744:	55                   	push   %ebp
  80b745:	89 e5                	mov    %esp,%ebp
  80b747:	53                   	push   %ebx
  80b748:	83 ec 34             	sub    $0x34,%esp
  80b74b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b74e:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b751:	85 db                	test   %ebx,%ebx
  80b753:	75 1c                	jne    80b771 <netconn_bind+0x2d>
  80b755:	c7 44 24 08 ac 3e 81 	movl   $0x813eac,0x8(%esp)
  80b75c:	00 
  80b75d:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80b764:	00 
  80b765:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b76c:	e8 c9 38 00 00       	call   80f03a <_panic>

  msg.function = do_bind;
  80b771:	c7 45 e4 a1 c8 80 00 	movl   $0x80c8a1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b778:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b77b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b77e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b781:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80b785:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b788:	89 04 24             	mov    %eax,(%esp)
  80b78b:	e8 7b 6f ff ff       	call   80270b <tcpip_apimsg>
  return conn->err;
  80b790:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b794:	83 c4 34             	add    $0x34,%esp
  80b797:	5b                   	pop    %ebx
  80b798:	5d                   	pop    %ebp
  80b799:	c3                   	ret    

0080b79a <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b79a:	55                   	push   %ebp
  80b79b:	89 e5                	mov    %esp,%ebp
  80b79d:	53                   	push   %ebx
  80b79e:	83 ec 34             	sub    $0x34,%esp
  80b7a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b7a4:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b7a7:	85 db                	test   %ebx,%ebx
  80b7a9:	75 1c                	jne    80b7c7 <netconn_connect+0x2d>
  80b7ab:	c7 44 24 08 c7 3e 81 	movl   $0x813ec7,0x8(%esp)
  80b7b2:	00 
  80b7b3:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80b7ba:	00 
  80b7bb:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b7c2:	e8 73 38 00 00       	call   80f03a <_panic>

  msg.function = do_connect;
  80b7c7:	c7 45 e4 37 c9 80 00 	movl   $0x80c937,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b7ce:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b7d1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b7d4:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b7d7:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80b7db:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b7de:	89 04 24             	mov    %eax,(%esp)
  80b7e1:	e8 25 6f ff ff       	call   80270b <tcpip_apimsg>
  return conn->err;
  80b7e6:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b7ea:	83 c4 34             	add    $0x34,%esp
  80b7ed:	5b                   	pop    %ebx
  80b7ee:	5d                   	pop    %ebp
  80b7ef:	c3                   	ret    

0080b7f0 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b7f0:	55                   	push   %ebp
  80b7f1:	89 e5                	mov    %esp,%ebp
  80b7f3:	53                   	push   %ebx
  80b7f4:	83 ec 34             	sub    $0x34,%esp
  80b7f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b7fa:	85 db                	test   %ebx,%ebx
  80b7fc:	75 1c                	jne    80b81a <netconn_disconnect+0x2a>
  80b7fe:	c7 44 24 08 88 3d 81 	movl   $0x813d88,0x8(%esp)
  80b805:	00 
  80b806:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80b80d:	00 
  80b80e:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b815:	e8 20 38 00 00       	call   80f03a <_panic>

  msg.function = do_disconnect;
  80b81a:	c7 45 e4 fd c9 80 00 	movl   $0x80c9fd,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b821:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b824:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b827:	89 04 24             	mov    %eax,(%esp)
  80b82a:	e8 dc 6e ff ff       	call   80270b <tcpip_apimsg>
  return conn->err;
  80b82f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b833:	83 c4 34             	add    $0x34,%esp
  80b836:	5b                   	pop    %ebx
  80b837:	5d                   	pop    %ebp
  80b838:	c3                   	ret    

0080b839 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b839:	55                   	push   %ebp
  80b83a:	89 e5                	mov    %esp,%ebp
  80b83c:	53                   	push   %ebx
  80b83d:	83 ec 34             	sub    $0x34,%esp
  80b840:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b843:	85 db                	test   %ebx,%ebx
  80b845:	75 1c                	jne    80b863 <netconn_listen_with_backlog+0x2a>
  80b847:	c7 44 24 08 e5 3e 81 	movl   $0x813ee5,0x8(%esp)
  80b84e:	00 
  80b84f:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80b856:	00 
  80b857:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b85e:	e8 d7 37 00 00       	call   80f03a <_panic>

  msg.function = do_listen;
  80b863:	c7 45 e4 34 ca 80 00 	movl   $0x80ca34,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b86a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b86d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b870:	89 04 24             	mov    %eax,(%esp)
  80b873:	e8 93 6e ff ff       	call   80270b <tcpip_apimsg>
  return conn->err;
  80b878:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b87c:	83 c4 34             	add    $0x34,%esp
  80b87f:	5b                   	pop    %ebx
  80b880:	5d                   	pop    %ebp
  80b881:	c3                   	ret    

0080b882 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b882:	55                   	push   %ebp
  80b883:	89 e5                	mov    %esp,%ebp
  80b885:	53                   	push   %ebx
  80b886:	83 ec 24             	sub    $0x24,%esp
  80b889:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b88c:	85 db                	test   %ebx,%ebx
  80b88e:	75 1c                	jne    80b8ac <netconn_accept+0x2a>
  80b890:	c7 44 24 08 02 3f 81 	movl   $0x813f02,0x8(%esp)
  80b897:	00 
  80b898:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80b89f:	00 
  80b8a0:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b8a7:	e8 8e 37 00 00       	call   80f03a <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b8ac:	8b 43 18             	mov    0x18(%ebx),%eax
  80b8af:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b8b2:	75 1c                	jne    80b8d0 <netconn_accept+0x4e>
  80b8b4:	c7 44 24 08 ac 3d 81 	movl   $0x813dac,0x8(%esp)
  80b8bb:	00 
  80b8bc:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80b8c3:	00 
  80b8c4:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b8cb:	e8 6a 37 00 00       	call   80f03a <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b8d0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b8d7:	00 
  80b8d8:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b8db:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b8df:	89 04 24             	mov    %eax,(%esp)
  80b8e2:	e8 81 f2 ff ff       	call   80ab68 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b8e7:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b8ea:	85 c0                	test   %eax,%eax
  80b8ec:	74 15                	je     80b903 <netconn_accept+0x81>
  80b8ee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b8f5:	00 
  80b8f6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b8fd:	00 
  80b8fe:	89 1c 24             	mov    %ebx,(%esp)
  80b901:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b903:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b906:	83 c4 24             	add    $0x24,%esp
  80b909:	5b                   	pop    %ebx
  80b90a:	5d                   	pop    %ebp
  80b90b:	c3                   	ret    

0080b90c <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b90c:	55                   	push   %ebp
  80b90d:	89 e5                	mov    %esp,%ebp
  80b90f:	53                   	push   %ebx
  80b910:	83 ec 34             	sub    $0x34,%esp
  80b913:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b916:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b91d:	85 db                	test   %ebx,%ebx
  80b91f:	75 1c                	jne    80b93d <netconn_recv+0x31>
  80b921:	c7 44 24 08 1f 3f 81 	movl   $0x813f1f,0x8(%esp)
  80b928:	00 
  80b929:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80b930:	00 
  80b931:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80b938:	e8 fd 36 00 00       	call   80f03a <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b93d:	8b 43 14             	mov    0x14(%ebx),%eax
  80b940:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b943:	75 0e                	jne    80b953 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80b945:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b949:	b8 00 00 00 00       	mov    $0x0,%eax
  80b94e:	e9 58 01 00 00       	jmp    80baab <netconn_recv+0x19f>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b953:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b957:	0f 8c 49 01 00 00    	jl     80baa6 <netconn_recv+0x19a>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b95d:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b960:	0f 85 f5 00 00 00    	jne    80ba5b <netconn_recv+0x14f>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b966:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b96a:	75 0e                	jne    80b97a <netconn_recv+0x6e>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80b96c:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b970:	b8 00 00 00 00       	mov    $0x0,%eax
  80b975:	e9 31 01 00 00       	jmp    80baab <netconn_recv+0x19f>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b97a:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80b981:	e8 3c 90 ff ff       	call   8049c2 <memp_malloc>
  80b986:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b989:	85 c0                	test   %eax,%eax
  80b98b:	75 09                	jne    80b996 <netconn_recv+0x8a>
      conn->err = ERR_MEM;
  80b98d:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b991:	e9 15 01 00 00       	jmp    80baab <netconn_recv+0x19f>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b996:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b99d:	00 
  80b99e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b9a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b9a5:	8b 43 14             	mov    0x14(%ebx),%eax
  80b9a8:	89 04 24             	mov    %eax,(%esp)
  80b9ab:	e8 b8 f1 ff ff       	call   80ab68 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b9b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b9b3:	85 c0                	test   %eax,%eax
  80b9b5:	74 0a                	je     80b9c1 <netconn_recv+0xb5>
      len = p->tot_len;
  80b9b7:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b9bb:	66 29 53 20          	sub    %dx,0x20(%ebx)
  80b9bf:	eb 05                	jmp    80b9c6 <netconn_recv+0xba>
    } else {
      len = 0;
  80b9c1:	ba 00 00 00 00       	mov    $0x0,%edx
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b9c6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b9c9:	85 c0                	test   %eax,%eax
  80b9cb:	74 14                	je     80b9e1 <netconn_recv+0xd5>
  80b9cd:	0f b7 d2             	movzwl %dx,%edx
  80b9d0:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b9d4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b9db:	00 
  80b9dc:	89 1c 24             	mov    %ebx,(%esp)
  80b9df:	ff d0                	call   *%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b9e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b9e4:	85 c0                	test   %eax,%eax
  80b9e6:	75 2b                	jne    80ba13 <netconn_recv+0x107>
      memp_free(MEMP_NETBUF, buf);
  80b9e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b9eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b9ef:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80b9f6:	e8 27 90 ff ff       	call   804a22 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
        conn->err = ERR_CLSD;
      }
      return NULL;
  80b9fb:	b8 00 00 00 00       	mov    $0x0,%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80ba00:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ba04:	0f 85 a1 00 00 00    	jne    80baab <netconn_recv+0x19f>
        conn->err = ERR_CLSD;
  80ba0a:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80ba0e:	e9 98 00 00 00       	jmp    80baab <netconn_recv+0x19f>
      }
      return NULL;
    }

    buf->p = p;
  80ba13:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80ba16:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80ba18:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ba1b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80ba1e:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80ba21:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80ba27:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80ba2e:	c7 45 e4 d2 cb 80 00 	movl   $0x80cbd2,-0x1c(%ebp)
    msg.msg.conn = conn;
  80ba35:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80ba38:	85 c0                	test   %eax,%eax
  80ba3a:	74 0c                	je     80ba48 <netconn_recv+0x13c>
      msg.msg.msg.r.len = buf->p->tot_len;
  80ba3c:	8b 00                	mov    (%eax),%eax
  80ba3e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80ba42:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80ba46:	eb 06                	jmp    80ba4e <netconn_recv+0x142>
    } else {
      msg.msg.msg.r.len = 1;
  80ba48:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80ba4e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ba51:	89 04 24             	mov    %eax,(%esp)
  80ba54:	e8 b2 6c ff ff       	call   80270b <tcpip_apimsg>
  80ba59:	eb 46                	jmp    80baa1 <netconn_recv+0x195>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80ba5b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ba62:	00 
  80ba63:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80ba66:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ba6a:	89 04 24             	mov    %eax,(%esp)
  80ba6d:	e8 f6 f0 ff ff       	call   80ab68 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80ba72:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ba75:	85 c0                	test   %eax,%eax
  80ba77:	74 28                	je     80baa1 <netconn_recv+0x195>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80ba79:	8b 10                	mov    (%eax),%edx
  80ba7b:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80ba7f:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80ba83:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80ba86:	85 d2                	test   %edx,%edx
  80ba88:	74 17                	je     80baa1 <netconn_recv+0x195>
  80ba8a:	8b 00                	mov    (%eax),%eax
  80ba8c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80ba90:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ba94:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80ba9b:	00 
  80ba9c:	89 1c 24             	mov    %ebx,(%esp)
  80ba9f:	ff d2                	call   *%edx
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80baa1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80baa4:	eb 05                	jmp    80baab <netconn_recv+0x19f>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80baa6:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80baab:	83 c4 34             	add    $0x34,%esp
  80baae:	5b                   	pop    %ebx
  80baaf:	5d                   	pop    %ebp
  80bab0:	c3                   	ret    

0080bab1 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80bab1:	55                   	push   %ebp
  80bab2:	89 e5                	mov    %esp,%ebp
  80bab4:	53                   	push   %ebx
  80bab5:	83 ec 34             	sub    $0x34,%esp
  80bab8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80babb:	85 db                	test   %ebx,%ebx
  80babd:	75 1c                	jne    80badb <netconn_send+0x2a>
  80babf:	c7 44 24 08 3a 3f 81 	movl   $0x813f3a,0x8(%esp)
  80bac6:	00 
  80bac7:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80bace:	00 
  80bacf:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80bad6:	e8 5f 35 00 00       	call   80f03a <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80badb:	c7 45 e4 1a cb 80 00 	movl   $0x80cb1a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bae2:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80bae5:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bae8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80baeb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80baee:	89 04 24             	mov    %eax,(%esp)
  80baf1:	e8 15 6c ff ff       	call   80270b <tcpip_apimsg>
  return conn->err;
  80baf6:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80bafa:	83 c4 34             	add    $0x34,%esp
  80bafd:	5b                   	pop    %ebx
  80bafe:	5d                   	pop    %ebp
  80baff:	c3                   	ret    

0080bb00 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80bb00:	55                   	push   %ebp
  80bb01:	89 e5                	mov    %esp,%ebp
  80bb03:	83 ec 18             	sub    $0x18,%esp
  80bb06:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb09:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80bb0c:	85 c0                	test   %eax,%eax
  80bb0e:	74 1b                	je     80bb2b <netconn_sendto+0x2b>
    buf->addr = addr;
  80bb10:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80bb13:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80bb16:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80bb1a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb1e:	8b 45 08             	mov    0x8(%ebp),%eax
  80bb21:	89 04 24             	mov    %eax,(%esp)
  80bb24:	e8 88 ff ff ff       	call   80bab1 <netconn_send>
  80bb29:	eb 05                	jmp    80bb30 <netconn_sendto+0x30>
  }
  return ERR_VAL;
  80bb2b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80bb30:	c9                   	leave  
  80bb31:	c3                   	ret    

0080bb32 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80bb32:	55                   	push   %ebp
  80bb33:	89 e5                	mov    %esp,%ebp
  80bb35:	53                   	push   %ebx
  80bb36:	83 ec 34             	sub    $0x34,%esp
  80bb39:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bb3c:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80bb3f:	85 db                	test   %ebx,%ebx
  80bb41:	75 1c                	jne    80bb5f <netconn_write+0x2d>
  80bb43:	c7 44 24 08 55 3f 81 	movl   $0x813f55,0x8(%esp)
  80bb4a:	00 
  80bb4b:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80bb52:	00 
  80bb53:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80bb5a:	e8 db 34 00 00       	call   80f03a <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80bb5f:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bb62:	74 1c                	je     80bb80 <netconn_write+0x4e>
  80bb64:	c7 44 24 08 d0 3d 81 	movl   $0x813dd0,0x8(%esp)
  80bb6b:	00 
  80bb6c:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80bb73:	00 
  80bb74:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80bb7b:	e8 ba 34 00 00       	call   80f03a <_panic>

  msg.function = do_write;
  80bb80:	c7 45 e4 13 cc 80 00 	movl   $0x80cc13,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bb87:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80bb8a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bb8d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80bb90:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80bb93:	8b 45 10             	mov    0x10(%ebp),%eax
  80bb96:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80bb99:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bb9c:	89 04 24             	mov    %eax,(%esp)
  80bb9f:	e8 67 6b ff ff       	call   80270b <tcpip_apimsg>
  return conn->err;
  80bba4:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80bba8:	83 c4 34             	add    $0x34,%esp
  80bbab:	5b                   	pop    %ebx
  80bbac:	5d                   	pop    %ebp
  80bbad:	c3                   	ret    

0080bbae <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80bbae:	55                   	push   %ebp
  80bbaf:	89 e5                	mov    %esp,%ebp
  80bbb1:	53                   	push   %ebx
  80bbb2:	83 ec 34             	sub    $0x34,%esp
  80bbb5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80bbb8:	85 db                	test   %ebx,%ebx
  80bbba:	75 1c                	jne    80bbd8 <netconn_close+0x2a>
  80bbbc:	c7 44 24 08 71 3f 81 	movl   $0x813f71,0x8(%esp)
  80bbc3:	00 
  80bbc4:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80bbcb:	00 
  80bbcc:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80bbd3:	e8 62 34 00 00       	call   80f03a <_panic>

  msg.function = do_close;
  80bbd8:	c7 45 e4 21 cd 80 00 	movl   $0x80cd21,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bbdf:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80bbe2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bbe5:	89 04 24             	mov    %eax,(%esp)
  80bbe8:	e8 1e 6b ff ff       	call   80270b <tcpip_apimsg>
  return conn->err;
  80bbed:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80bbf1:	83 c4 34             	add    $0x34,%esp
  80bbf4:	5b                   	pop    %ebx
  80bbf5:	5d                   	pop    %ebp
  80bbf6:	c3                   	ret    
  80bbf7:	66 90                	xchg   %ax,%ax
  80bbf9:	66 90                	xchg   %ax,%ax
  80bbfb:	66 90                	xchg   %ax,%ax
  80bbfd:	66 90                	xchg   %ax,%ax
  80bbff:	90                   	nop

0080bc00 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80bc00:	55                   	push   %ebp
  80bc01:	89 e5                	mov    %esp,%ebp
  80bc03:	56                   	push   %esi
  80bc04:	53                   	push   %ebx
  80bc05:	83 ec 10             	sub    $0x10,%esp
  80bc08:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bc0b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bc0e:	8b 75 10             	mov    0x10(%ebp),%esi
  80bc11:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80bc14:	85 c0                	test   %eax,%eax
  80bc16:	75 1c                	jne    80bc34 <recv_tcp+0x34>
  80bc18:	c7 44 24 08 90 3f 81 	movl   $0x813f90,0x8(%esp)
  80bc1f:	00 
  80bc20:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80bc27:	00 
  80bc28:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80bc2f:	e8 06 34 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80bc34:	85 db                	test   %ebx,%ebx
  80bc36:	75 1c                	jne    80bc54 <recv_tcp+0x54>
  80bc38:	c7 44 24 08 b4 3f 81 	movl   $0x813fb4,0x8(%esp)
  80bc3f:	00 
  80bc40:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80bc47:	00 
  80bc48:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80bc4f:	e8 e6 33 00 00       	call   80f03a <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80bc54:	39 43 08             	cmp    %eax,0x8(%ebx)
  80bc57:	74 1c                	je     80bc75 <recv_tcp+0x75>
  80bc59:	c7 44 24 08 f1 40 81 	movl   $0x8140f1,0x8(%esp)
  80bc60:	00 
  80bc61:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80bc68:	00 
  80bc69:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80bc70:	e8 c5 33 00 00       	call   80f03a <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80bc75:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bc79:	74 49                	je     80bcc4 <recv_tcp+0xc4>
    return ERR_VAL;
  }

  conn->err = err;
  80bc7b:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80bc7e:	85 f6                	test   %esi,%esi
  80bc80:	74 0a                	je     80bc8c <recv_tcp+0x8c>
    len = p->tot_len;
  80bc82:	0f b7 56 08          	movzwl 0x8(%esi),%edx
    SYS_ARCH_INC(conn->recv_avail, len);
  80bc86:	66 01 53 20          	add    %dx,0x20(%ebx)
  80bc8a:	eb 05                	jmp    80bc91 <recv_tcp+0x91>
  } else {
    len = 0;
  80bc8c:	ba 00 00 00 00       	mov    $0x0,%edx
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80bc91:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bc94:	85 c0                	test   %eax,%eax
  80bc96:	74 14                	je     80bcac <recv_tcp+0xac>
  80bc98:	0f b7 d2             	movzwl %dx,%edx
  80bc9b:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bc9f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bca6:	00 
  80bca7:	89 1c 24             	mov    %ebx,(%esp)
  80bcaa:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80bcac:	89 74 24 04          	mov    %esi,0x4(%esp)
  80bcb0:	8b 43 14             	mov    0x14(%ebx),%eax
  80bcb3:	89 04 24             	mov    %eax,(%esp)
  80bcb6:	e8 a1 ed ff ff       	call   80aa5c <sys_mbox_trypost>
  80bcbb:	84 c0                	test   %al,%al
  80bcbd:	0f 95 c0             	setne  %al
    return ERR_MEM;
  80bcc0:	f7 d8                	neg    %eax
  80bcc2:	eb 05                	jmp    80bcc9 <recv_tcp+0xc9>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80bcc4:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80bcc9:	83 c4 10             	add    $0x10,%esp
  80bccc:	5b                   	pop    %ebx
  80bccd:	5e                   	pop    %esi
  80bcce:	5d                   	pop    %ebp
  80bccf:	c3                   	ret    

0080bcd0 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80bcd0:	55                   	push   %ebp
  80bcd1:	89 e5                	mov    %esp,%ebp
  80bcd3:	57                   	push   %edi
  80bcd4:	56                   	push   %esi
  80bcd5:	53                   	push   %ebx
  80bcd6:	83 ec 1c             	sub    $0x1c,%esp
  80bcd9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bcdc:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bcdf:	8b 7d 10             	mov    0x10(%ebp),%edi
  80bce2:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80bce5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80bce8:	85 c0                	test   %eax,%eax
  80bcea:	75 1c                	jne    80bd08 <recv_udp+0x38>
  80bcec:	c7 44 24 08 d4 3f 81 	movl   $0x813fd4,0x8(%esp)
  80bcf3:	00 
  80bcf4:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80bcfb:	00 
  80bcfc:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80bd03:	e8 32 33 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80bd08:	85 db                	test   %ebx,%ebx
  80bd0a:	75 1c                	jne    80bd28 <recv_udp+0x58>
  80bd0c:	c7 44 24 08 f8 3f 81 	movl   $0x813ff8,0x8(%esp)
  80bd13:	00 
  80bd14:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80bd1b:	00 
  80bd1c:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80bd23:	e8 12 33 00 00       	call   80f03a <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80bd28:	39 43 08             	cmp    %eax,0x8(%ebx)
  80bd2b:	74 1c                	je     80bd49 <recv_udp+0x79>
  80bd2d:	c7 44 24 08 0f 41 81 	movl   $0x81410f,0x8(%esp)
  80bd34:	00 
  80bd35:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80bd3c:	00 
  80bd3d:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80bd44:	e8 f1 32 00 00       	call   80f03a <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80bd49:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bd4d:	75 0a                	jne    80bd59 <recv_udp+0x89>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80bd4f:	89 3c 24             	mov    %edi,(%esp)
  80bd52:	e8 7d 90 ff ff       	call   804dd4 <pbuf_free>
    return;
  80bd57:	eb 6e                	jmp    80bdc7 <recv_udp+0xf7>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80bd59:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80bd60:	e8 5d 8c ff ff       	call   8049c2 <memp_malloc>
  80bd65:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80bd67:	85 c0                	test   %eax,%eax
  80bd69:	75 0a                	jne    80bd75 <recv_udp+0xa5>
    pbuf_free(p);
  80bd6b:	89 3c 24             	mov    %edi,(%esp)
  80bd6e:	e8 61 90 ff ff       	call   804dd4 <pbuf_free>
    return;
  80bd73:	eb 52                	jmp    80bdc7 <recv_udp+0xf7>
  } else {
    buf->p = p;
  80bd75:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80bd77:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80bd7a:	8b 45 14             	mov    0x14(%ebp),%eax
  80bd7d:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80bd80:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80bd84:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80bd88:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80bd8c:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80bd90:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bd93:	85 c0                	test   %eax,%eax
  80bd95:	74 15                	je     80bdac <recv_udp+0xdc>
  80bd97:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80bd9b:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bd9f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bda6:	00 
  80bda7:	89 1c 24             	mov    %ebx,(%esp)
  80bdaa:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80bdac:	89 74 24 04          	mov    %esi,0x4(%esp)
  80bdb0:	8b 43 14             	mov    0x14(%ebx),%eax
  80bdb3:	89 04 24             	mov    %eax,(%esp)
  80bdb6:	e8 a1 ec ff ff       	call   80aa5c <sys_mbox_trypost>
  80bdbb:	84 c0                	test   %al,%al
  80bdbd:	74 08                	je     80bdc7 <recv_udp+0xf7>
    netbuf_delete(buf);
  80bdbf:	89 34 24             	mov    %esi,(%esp)
  80bdc2:	e8 65 6a ff ff       	call   80282c <netbuf_delete>
    return;
  }
}
  80bdc7:	83 c4 1c             	add    $0x1c,%esp
  80bdca:	5b                   	pop    %ebx
  80bdcb:	5e                   	pop    %esi
  80bdcc:	5f                   	pop    %edi
  80bdcd:	5d                   	pop    %ebp
  80bdce:	c3                   	ret    

0080bdcf <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80bdcf:	55                   	push   %ebp
  80bdd0:	89 e5                	mov    %esp,%ebp
  80bdd2:	57                   	push   %edi
  80bdd3:	56                   	push   %esi
  80bdd4:	53                   	push   %ebx
  80bdd5:	83 ec 1c             	sub    $0x1c,%esp
  80bdd8:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80bddb:	85 db                	test   %ebx,%ebx
  80bddd:	0f 84 cd 00 00 00    	je     80beb0 <recv_raw+0xe1>
  80bde3:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bde7:	0f 84 c3 00 00 00    	je     80beb0 <recv_raw+0xe1>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80bded:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bdf4:	00 
  80bdf5:	8b 45 10             	mov    0x10(%ebp),%eax
  80bdf8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80bdfc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be00:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80be07:	e8 a9 90 ff ff       	call   804eb5 <pbuf_alloc>
  80be0c:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80be0e:	85 c0                	test   %eax,%eax
  80be10:	0f 84 9a 00 00 00    	je     80beb0 <recv_raw+0xe1>
      if (pbuf_copy(q, p) != ERR_OK) {
  80be16:	8b 45 10             	mov    0x10(%ebp),%eax
  80be19:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be1d:	89 34 24             	mov    %esi,(%esp)
  80be20:	e8 bf 95 ff ff       	call   8053e4 <pbuf_copy>
  80be25:	84 c0                	test   %al,%al
  80be27:	74 73                	je     80be9c <recv_raw+0xcd>
        pbuf_free(q);
  80be29:	89 34 24             	mov    %esi,(%esp)
  80be2c:	e8 a3 8f ff ff       	call   804dd4 <pbuf_free>
  80be31:	eb 7d                	jmp    80beb0 <recv_raw+0xe1>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80be33:	89 34 24             	mov    %esi,(%esp)
  80be36:	e8 99 8f ff ff       	call   804dd4 <pbuf_free>
        return 0;
  80be3b:	90                   	nop
  80be3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80be40:	eb 6e                	jmp    80beb0 <recv_raw+0xe1>
      }

      buf->p = q;
  80be42:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80be44:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80be47:	8b 46 04             	mov    0x4(%esi),%eax
  80be4a:	83 c0 0c             	add    $0xc,%eax
  80be4d:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80be50:	8b 45 0c             	mov    0xc(%ebp),%eax
  80be53:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80be57:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80be5b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80be5f:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80be63:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80be66:	85 c0                	test   %eax,%eax
  80be68:	74 15                	je     80be7f <recv_raw+0xb0>
  80be6a:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80be6e:	89 54 24 08          	mov    %edx,0x8(%esp)
  80be72:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80be79:	00 
  80be7a:	89 1c 24             	mov    %ebx,(%esp)
  80be7d:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80be7f:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80be83:	8b 43 14             	mov    0x14(%ebx),%eax
  80be86:	89 04 24             	mov    %eax,(%esp)
  80be89:	e8 ce eb ff ff       	call   80aa5c <sys_mbox_trypost>
  80be8e:	84 c0                	test   %al,%al
  80be90:	74 1e                	je     80beb0 <recv_raw+0xe1>
        netbuf_delete(buf);
  80be92:	89 3c 24             	mov    %edi,(%esp)
  80be95:	e8 92 69 ff ff       	call   80282c <netbuf_delete>
  80be9a:	eb 14                	jmp    80beb0 <recv_raw+0xe1>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80be9c:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80bea3:	e8 1a 8b ff ff       	call   8049c2 <memp_malloc>
  80bea8:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80beaa:	85 c0                	test   %eax,%eax
  80beac:	75 94                	jne    80be42 <recv_raw+0x73>
  80beae:	eb 83                	jmp    80be33 <recv_raw+0x64>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80beb0:	b8 00 00 00 00       	mov    $0x0,%eax
  80beb5:	83 c4 1c             	add    $0x1c,%esp
  80beb8:	5b                   	pop    %ebx
  80beb9:	5e                   	pop    %esi
  80beba:	5f                   	pop    %edi
  80bebb:	5d                   	pop    %ebp
  80bebc:	c3                   	ret    

0080bebd <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80bebd:	55                   	push   %ebp
  80bebe:	89 e5                	mov    %esp,%ebp
  80bec0:	53                   	push   %ebx
  80bec1:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80bec4:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80bec7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80becb:	89 1c 24             	mov    %ebx,(%esp)
  80bece:	e8 99 9f ff ff       	call   805e6c <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80bed3:	c7 44 24 04 00 bc 80 	movl   $0x80bc00,0x4(%esp)
  80beda:	00 
  80bedb:	89 1c 24             	mov    %ebx,(%esp)
  80bede:	e8 97 9f ff ff       	call   805e7a <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80bee3:	c7 44 24 04 ec c3 80 	movl   $0x80c3ec,0x4(%esp)
  80beea:	00 
  80beeb:	89 1c 24             	mov    %ebx,(%esp)
  80beee:	e8 98 9f ff ff       	call   805e8b <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80bef3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80befa:	00 
  80befb:	c7 44 24 04 9e c3 80 	movl   $0x80c39e,0x4(%esp)
  80bf02:	00 
  80bf03:	89 1c 24             	mov    %ebx,(%esp)
  80bf06:	e8 b0 9f ff ff       	call   805ebb <tcp_poll>
  tcp_err(pcb, err_tcp);
  80bf0b:	c7 44 24 04 69 bf 80 	movl   $0x80bf69,0x4(%esp)
  80bf12:	00 
  80bf13:	89 1c 24             	mov    %ebx,(%esp)
  80bf16:	e8 81 9f ff ff       	call   805e9c <tcp_err>
}
  80bf1b:	83 c4 14             	add    $0x14,%esp
  80bf1e:	5b                   	pop    %ebx
  80bf1f:	5d                   	pop    %ebp
  80bf20:	c3                   	ret    

0080bf21 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80bf21:	55                   	push   %ebp
  80bf22:	89 e5                	mov    %esp,%ebp
  80bf24:	53                   	push   %ebx
  80bf25:	83 ec 14             	sub    $0x14,%esp
  80bf28:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bf2b:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80bf2e:	85 db                	test   %ebx,%ebx
  80bf30:	74 2c                	je     80bf5e <do_connected+0x3d>
    return ERR_VAL;
  }

  conn->err = err;
  80bf32:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80bf35:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bf38:	75 0b                	jne    80bf45 <do_connected+0x24>
  80bf3a:	84 c0                	test   %al,%al
  80bf3c:	75 07                	jne    80bf45 <do_connected+0x24>
    setup_tcp(conn);
  80bf3e:	89 d8                	mov    %ebx,%eax
  80bf40:	e8 78 ff ff ff       	call   80bebd <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80bf45:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80bf4c:	8b 43 10             	mov    0x10(%ebx),%eax
  80bf4f:	89 04 24             	mov    %eax,(%esp)
  80bf52:	e8 79 e9 ff ff       	call   80a8d0 <sys_sem_signal>
  return ERR_OK;
  80bf57:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf5c:	eb 05                	jmp    80bf63 <do_connected+0x42>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80bf5e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80bf63:	83 c4 14             	add    $0x14,%esp
  80bf66:	5b                   	pop    %ebx
  80bf67:	5d                   	pop    %ebp
  80bf68:	c3                   	ret    

0080bf69 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80bf69:	55                   	push   %ebp
  80bf6a:	89 e5                	mov    %esp,%ebp
  80bf6c:	53                   	push   %ebx
  80bf6d:	83 ec 14             	sub    $0x14,%esp
  80bf70:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bf73:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bf76:	85 db                	test   %ebx,%ebx
  80bf78:	75 1c                	jne    80bf96 <err_tcp+0x2d>
  80bf7a:	c7 44 24 08 2d 41 81 	movl   $0x81412d,0x8(%esp)
  80bf81:	00 
  80bf82:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80bf89:	00 
  80bf8a:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80bf91:	e8 a4 30 00 00       	call   80f03a <_panic>

  conn->pcb.tcp = NULL;
  80bf96:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80bf9d:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bfa0:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bfa4:	74 2f                	je     80bfd5 <err_tcp+0x6c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bfa6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bfa9:	85 c0                	test   %eax,%eax
  80bfab:	74 15                	je     80bfc2 <err_tcp+0x59>
  80bfad:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bfb4:	00 
  80bfb5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bfbc:	00 
  80bfbd:	89 1c 24             	mov    %ebx,(%esp)
  80bfc0:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80bfc2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bfc9:	00 
  80bfca:	8b 43 14             	mov    0x14(%ebx),%eax
  80bfcd:	89 04 24             	mov    %eax,(%esp)
  80bfd0:	e8 51 eb ff ff       	call   80ab26 <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80bfd5:	8b 43 10             	mov    0x10(%ebx),%eax
  80bfd8:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bfdb:	74 15                	je     80bff2 <err_tcp+0x89>
  80bfdd:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80bfe1:	75 0f                	jne    80bff2 <err_tcp+0x89>
    conn->state = NETCONN_NONE;
  80bfe3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80bfea:	89 04 24             	mov    %eax,(%esp)
  80bfed:	e8 de e8 ff ff       	call   80a8d0 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bff2:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bff6:	74 2f                	je     80c027 <err_tcp+0xbe>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bff8:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bffb:	85 c0                	test   %eax,%eax
  80bffd:	74 15                	je     80c014 <err_tcp+0xab>
  80bfff:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c006:	00 
  80c007:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c00e:	00 
  80c00f:	89 1c 24             	mov    %ebx,(%esp)
  80c012:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80c014:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c01b:	00 
  80c01c:	8b 43 18             	mov    0x18(%ebx),%eax
  80c01f:	89 04 24             	mov    %eax,(%esp)
  80c022:	e8 ff ea ff ff       	call   80ab26 <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80c027:	8b 43 04             	mov    0x4(%ebx),%eax
  80c02a:	83 f8 04             	cmp    $0x4,%eax
  80c02d:	74 05                	je     80c034 <err_tcp+0xcb>
  80c02f:	83 f8 01             	cmp    $0x1,%eax
  80c032:	75 12                	jne    80c046 <err_tcp+0xdd>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80c034:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80c03b:	8b 43 10             	mov    0x10(%ebx),%eax
  80c03e:	89 04 24             	mov    %eax,(%esp)
  80c041:	e8 8a e8 ff ff       	call   80a8d0 <sys_sem_signal>
  }
}
  80c046:	83 c4 14             	add    $0x14,%esp
  80c049:	5b                   	pop    %ebx
  80c04a:	5d                   	pop    %ebp
  80c04b:	c3                   	ret    

0080c04c <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80c04c:	55                   	push   %ebp
  80c04d:	89 e5                	mov    %esp,%ebp
  80c04f:	57                   	push   %edi
  80c050:	56                   	push   %esi
  80c051:	53                   	push   %ebx
  80c052:	83 ec 1c             	sub    $0x1c,%esp
  80c055:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80c057:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80c05b:	74 1c                	je     80c079 <do_writemore+0x2d>
  80c05d:	c7 44 24 08 3a 41 81 	movl   $0x81413a,0x8(%esp)
  80c064:	00 
  80c065:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80c06c:	00 
  80c06d:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c074:	e8 c1 2f 00 00       	call   80f03a <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80c079:	8b 40 24             	mov    0x24(%eax),%eax
  80c07c:	8b 53 28             	mov    0x28(%ebx),%edx
  80c07f:	89 d1                	mov    %edx,%ecx
  80c081:	03 48 04             	add    0x4(%eax),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80c084:	8b 78 08             	mov    0x8(%eax),%edi
  80c087:	89 fe                	mov    %edi,%esi
  80c089:	29 d6                	sub    %edx,%esi
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80c08b:	29 d7                	sub    %edx,%edi
  80c08d:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  80c093:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80c098:	0f 4f fa             	cmovg  %edx,%edi
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80c09b:	8b 53 08             	mov    0x8(%ebx),%edx
  80c09e:	0f b7 72 6e          	movzwl 0x6e(%edx),%esi
  80c0a2:	66 39 f7             	cmp    %si,%di
  80c0a5:	0f 46 f7             	cmovbe %edi,%esi
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80c0a8:	0f b7 f6             	movzwl %si,%esi
  80c0ab:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80c0af:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c0b3:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c0b7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c0bb:	89 14 24             	mov    %edx,(%esp)
  80c0be:	e8 02 c6 ff ff       	call   8086c5 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80c0c3:	89 f2                	mov    %esi,%edx
  80c0c5:	03 53 28             	add    0x28(%ebx),%edx
  80c0c8:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80c0cb:	3b 51 08             	cmp    0x8(%ecx),%edx
  80c0ce:	7e 1c                	jle    80c0ec <do_writemore+0xa0>
  80c0d0:	c7 44 24 08 57 41 81 	movl   $0x814157,0x8(%esp)
  80c0d7:	00 
  80c0d8:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80c0df:	00 
  80c0e0:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c0e7:	e8 4e 2f 00 00       	call   80f03a <_panic>
  if (err == ERR_OK) {
  80c0ec:	84 c0                	test   %al,%al
  80c0ee:	75 6f                	jne    80c15f <do_writemore+0x113>
    conn->write_offset += len;
  80c0f0:	89 53 28             	mov    %edx,0x28(%ebx)
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80c0f3:	bf 00 00 00 00       	mov    $0x0,%edi

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80c0f8:	3b 51 08             	cmp    0x8(%ecx),%edx
  80c0fb:	75 13                	jne    80c110 <do_writemore+0xc4>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80c0fd:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80c104:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80c10b:	bf 01 00 00 00       	mov    $0x1,%edi
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80c110:	8b 43 08             	mov    0x8(%ebx),%eax
  80c113:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80c117:	74 12                	je     80c12b <do_writemore+0xdf>
  80c119:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80c11d:	75 0c                	jne    80c12b <do_writemore+0xdf>
  80c11f:	8b 50 74             	mov    0x74(%eax),%edx
  80c122:	85 d2                	test   %edx,%edx
  80c124:	74 69                	je     80c18f <do_writemore+0x143>
  80c126:	83 3a 00             	cmpl   $0x0,(%edx)
  80c129:	74 64                	je     80c18f <do_writemore+0x143>
  80c12b:	89 04 24             	mov    %eax,(%esp)
  80c12e:	e8 fe c5 ff ff       	call   808731 <tcp_output>
    conn->err = err;
  80c133:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80c136:	84 c0                	test   %al,%al
  80c138:	75 3b                	jne    80c175 <do_writemore+0x129>
  80c13a:	8b 43 08             	mov    0x8(%ebx),%eax
  80c13d:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c143:	77 30                	ja     80c175 <do_writemore+0x129>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80c145:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c148:	85 c0                	test   %eax,%eax
  80c14a:	74 29                	je     80c175 <do_writemore+0x129>
  80c14c:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c150:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c157:	00 
  80c158:	89 1c 24             	mov    %ebx,(%esp)
  80c15b:	ff d0                	call   *%eax
  80c15d:	eb 16                	jmp    80c175 <do_writemore+0x129>
    }
  } else if (err == ERR_MEM) {
  80c15f:	3c ff                	cmp    $0xff,%al
  80c161:	75 0d                	jne    80c170 <do_writemore+0x124>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80c163:	8b 43 08             	mov    0x8(%ebx),%eax
  80c166:	89 04 24             	mov    %eax,(%esp)
  80c169:	e8 c3 c5 ff ff       	call   808731 <tcp_output>
  80c16e:	eb 25                	jmp    80c195 <do_writemore+0x149>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80c170:	88 43 0c             	mov    %al,0xc(%ebx)
  80c173:	eb 06                	jmp    80c17b <do_writemore+0x12f>
    write_finished = 1;
  }

  if (write_finished) {
  80c175:	89 f8                	mov    %edi,%eax
  80c177:	84 c0                	test   %al,%al
  80c179:	74 1a                	je     80c195 <do_writemore+0x149>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80c17b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80c182:	8b 43 10             	mov    0x10(%ebx),%eax
  80c185:	89 04 24             	mov    %eax,(%esp)
  80c188:	e8 43 e7 ff ff       	call   80a8d0 <sys_sem_signal>
  80c18d:	eb 06                	jmp    80c195 <do_writemore+0x149>
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80c18f:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80c193:	eb a5                	jmp    80c13a <do_writemore+0xee>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80c195:	b8 00 00 00 00       	mov    $0x0,%eax
  80c19a:	83 c4 1c             	add    $0x1c,%esp
  80c19d:	5b                   	pop    %ebx
  80c19e:	5e                   	pop    %esi
  80c19f:	5f                   	pop    %edi
  80c1a0:	5d                   	pop    %ebp
  80c1a1:	c3                   	ret    

0080c1a2 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80c1a2:	55                   	push   %ebp
  80c1a3:	89 e5                	mov    %esp,%ebp
  80c1a5:	53                   	push   %ebx
  80c1a6:	83 ec 14             	sub    $0x14,%esp
  80c1a9:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80c1ab:	85 c0                	test   %eax,%eax
  80c1ad:	75 1c                	jne    80c1cb <do_close_internal+0x29>
  80c1af:	c7 44 24 08 48 3f 81 	movl   $0x813f48,0x8(%esp)
  80c1b6:	00 
  80c1b7:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80c1be:	00 
  80c1bf:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c1c6:	e8 6f 2e 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80c1cb:	83 38 10             	cmpl   $0x10,(%eax)
  80c1ce:	74 1c                	je     80c1ec <do_close_internal+0x4a>
  80c1d0:	c7 44 24 08 75 41 81 	movl   $0x814175,0x8(%esp)
  80c1d7:	00 
  80c1d8:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80c1df:	00 
  80c1e0:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c1e7:	e8 4e 2e 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80c1ec:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80c1f0:	74 1c                	je     80c20e <do_close_internal+0x6c>
  80c1f2:	c7 44 24 08 18 40 81 	movl   $0x814018,0x8(%esp)
  80c1f9:	00 
  80c1fa:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80c201:	00 
  80c202:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c209:	e8 2c 2e 00 00       	call   80f03a <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80c20e:	8b 40 08             	mov    0x8(%eax),%eax
  80c211:	85 c0                	test   %eax,%eax
  80c213:	75 1c                	jne    80c231 <do_close_internal+0x8f>
  80c215:	c7 44 24 08 93 41 81 	movl   $0x814193,0x8(%esp)
  80c21c:	00 
  80c21d:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80c224:	00 
  80c225:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c22c:	e8 09 2e 00 00       	call   80f03a <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80c231:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c238:	00 
  80c239:	89 04 24             	mov    %eax,(%esp)
  80c23c:	e8 2b 9c ff ff       	call   805e6c <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80c241:	8b 43 08             	mov    0x8(%ebx),%eax
  80c244:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80c248:	75 12                	jne    80c25c <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80c24a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c251:	00 
  80c252:	89 04 24             	mov    %eax,(%esp)
  80c255:	e8 53 9c ff ff       	call   805ead <tcp_accept>
  80c25a:	eb 64                	jmp    80c2c0 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80c25c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c263:	00 
  80c264:	89 04 24             	mov    %eax,(%esp)
  80c267:	e8 0e 9c ff ff       	call   805e7a <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80c26c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c273:	00 
  80c274:	8b 43 08             	mov    0x8(%ebx),%eax
  80c277:	89 04 24             	mov    %eax,(%esp)
  80c27a:	e8 2e 9c ff ff       	call   805ead <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80c27f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c286:	00 
  80c287:	8b 43 08             	mov    0x8(%ebx),%eax
  80c28a:	89 04 24             	mov    %eax,(%esp)
  80c28d:	e8 f9 9b ff ff       	call   805e8b <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80c292:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80c299:	00 
  80c29a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2a1:	00 
  80c2a2:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2a5:	89 04 24             	mov    %eax,(%esp)
  80c2a8:	e8 0e 9c ff ff       	call   805ebb <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80c2ad:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2b4:	00 
  80c2b5:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2b8:	89 04 24             	mov    %eax,(%esp)
  80c2bb:	e8 dc 9b ff ff       	call   805e9c <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80c2c0:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2c3:	89 04 24             	mov    %eax,(%esp)
  80c2c6:	e8 6e 9d ff ff       	call   806039 <tcp_close>
  if (err == ERR_OK) {
  80c2cb:	84 c0                	test   %al,%al
  80c2cd:	75 57                	jne    80c326 <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80c2cf:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80c2d6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80c2dd:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c2e1:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c2e4:	85 c0                	test   %eax,%eax
  80c2e6:	74 31                	je     80c319 <do_close_internal+0x177>
  80c2e8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c2ef:	00 
  80c2f0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2f7:	00 
  80c2f8:	89 1c 24             	mov    %ebx,(%esp)
  80c2fb:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80c2fd:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c300:	85 c0                	test   %eax,%eax
  80c302:	74 15                	je     80c319 <do_close_internal+0x177>
  80c304:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c30b:	00 
  80c30c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c313:	00 
  80c314:	89 1c 24             	mov    %ebx,(%esp)
  80c317:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80c319:	8b 43 10             	mov    0x10(%ebx),%eax
  80c31c:	89 04 24             	mov    %eax,(%esp)
  80c31f:	e8 ac e5 ff ff       	call   80a8d0 <sys_sem_signal>
  80c324:	eb 72                	jmp    80c398 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80c326:	8b 43 08             	mov    0x8(%ebx),%eax
  80c329:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80c32d:	75 1c                	jne    80c34b <do_close_internal+0x1a9>
  80c32f:	c7 44 24 08 3c 40 81 	movl   $0x81403c,0x8(%esp)
  80c336:	00 
  80c337:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80c33e:	00 
  80c33f:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c346:	e8 ef 2c 00 00       	call   80f03a <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80c34b:	c7 44 24 04 ec c3 80 	movl   $0x80c3ec,0x4(%esp)
  80c352:	00 
  80c353:	89 04 24             	mov    %eax,(%esp)
  80c356:	e8 30 9b ff ff       	call   805e8b <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80c35b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80c362:	00 
  80c363:	c7 44 24 04 9e c3 80 	movl   $0x80c39e,0x4(%esp)
  80c36a:	00 
  80c36b:	8b 43 08             	mov    0x8(%ebx),%eax
  80c36e:	89 04 24             	mov    %eax,(%esp)
  80c371:	e8 45 9b ff ff       	call   805ebb <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80c376:	c7 44 24 04 69 bf 80 	movl   $0x80bf69,0x4(%esp)
  80c37d:	00 
  80c37e:	8b 43 08             	mov    0x8(%ebx),%eax
  80c381:	89 04 24             	mov    %eax,(%esp)
  80c384:	e8 13 9b ff ff       	call   805e9c <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80c389:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c38d:	8b 43 08             	mov    0x8(%ebx),%eax
  80c390:	89 04 24             	mov    %eax,(%esp)
  80c393:	e8 d4 9a ff ff       	call   805e6c <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80c398:	83 c4 14             	add    $0x14,%esp
  80c39b:	5b                   	pop    %ebx
  80c39c:	5d                   	pop    %ebp
  80c39d:	c3                   	ret    

0080c39e <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80c39e:	55                   	push   %ebp
  80c39f:	89 e5                	mov    %esp,%ebp
  80c3a1:	83 ec 18             	sub    $0x18,%esp
  80c3a4:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c3a7:	85 c0                	test   %eax,%eax
  80c3a9:	75 1c                	jne    80c3c7 <poll_tcp+0x29>
  80c3ab:	c7 44 24 08 2d 41 81 	movl   $0x81412d,0x8(%esp)
  80c3b2:	00 
  80c3b3:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80c3ba:	00 
  80c3bb:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c3c2:	e8 73 2c 00 00       	call   80f03a <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c3c7:	8b 50 04             	mov    0x4(%eax),%edx
  80c3ca:	83 fa 01             	cmp    $0x1,%edx
  80c3cd:	75 07                	jne    80c3d6 <poll_tcp+0x38>
    do_writemore(conn);
  80c3cf:	e8 78 fc ff ff       	call   80c04c <do_writemore>
  80c3d4:	eb 0f                	jmp    80c3e5 <poll_tcp+0x47>
  } else if (conn->state == NETCONN_CLOSE) {
  80c3d6:	83 fa 04             	cmp    $0x4,%edx
  80c3d9:	75 0a                	jne    80c3e5 <poll_tcp+0x47>
    do_close_internal(conn);
  80c3db:	90                   	nop
  80c3dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c3e0:	e8 bd fd ff ff       	call   80c1a2 <do_close_internal>
  }

  return ERR_OK;
}
  80c3e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80c3ea:	c9                   	leave  
  80c3eb:	c3                   	ret    

0080c3ec <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80c3ec:	55                   	push   %ebp
  80c3ed:	89 e5                	mov    %esp,%ebp
  80c3ef:	56                   	push   %esi
  80c3f0:	53                   	push   %ebx
  80c3f1:	83 ec 10             	sub    $0x10,%esp
  80c3f4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c3f7:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c3fa:	85 db                	test   %ebx,%ebx
  80c3fc:	75 1c                	jne    80c41a <sent_tcp+0x2e>
  80c3fe:	c7 44 24 08 2d 41 81 	movl   $0x81412d,0x8(%esp)
  80c405:	00 
  80c406:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80c40d:	00 
  80c40e:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c415:	e8 20 2c 00 00       	call   80f03a <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c41a:	8b 43 04             	mov    0x4(%ebx),%eax
  80c41d:	83 f8 01             	cmp    $0x1,%eax
  80c420:	75 2b                	jne    80c44d <sent_tcp+0x61>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80c422:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c426:	75 1c                	jne    80c444 <sent_tcp+0x58>
  80c428:	c7 44 24 08 a6 41 81 	movl   $0x8141a6,0x8(%esp)
  80c42f:	00 
  80c430:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80c437:	00 
  80c438:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c43f:	e8 f6 2b 00 00       	call   80f03a <_panic>
    do_writemore(conn);
  80c444:	89 d8                	mov    %ebx,%eax
  80c446:	e8 01 fc ff ff       	call   80c04c <do_writemore>
  80c44b:	eb 33                	jmp    80c480 <sent_tcp+0x94>
  } else if (conn->state == NETCONN_CLOSE) {
  80c44d:	83 f8 04             	cmp    $0x4,%eax
  80c450:	75 2e                	jne    80c480 <sent_tcp+0x94>
    do_close_internal(conn);
  80c452:	89 d8                	mov    %ebx,%eax
  80c454:	e8 49 fd ff ff       	call   80c1a2 <do_close_internal>
  80c459:	eb 25                	jmp    80c480 <sent_tcp+0x94>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80c45b:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c461:	76 24                	jbe    80c487 <sent_tcp+0x9b>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80c463:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c466:	85 c0                	test   %eax,%eax
  80c468:	74 1d                	je     80c487 <sent_tcp+0x9b>
  80c46a:	0f b7 f6             	movzwl %si,%esi
  80c46d:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c471:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c478:	00 
  80c479:	89 1c 24             	mov    %ebx,(%esp)
  80c47c:	ff d0                	call   *%eax
  80c47e:	eb 07                	jmp    80c487 <sent_tcp+0x9b>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80c480:	8b 43 08             	mov    0x8(%ebx),%eax
  80c483:	85 c0                	test   %eax,%eax
  80c485:	75 d4                	jne    80c45b <sent_tcp+0x6f>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    }
  }
  
  return ERR_OK;
}
  80c487:	b8 00 00 00 00       	mov    $0x0,%eax
  80c48c:	83 c4 10             	add    $0x10,%esp
  80c48f:	5b                   	pop    %ebx
  80c490:	5e                   	pop    %esi
  80c491:	5d                   	pop    %ebp
  80c492:	c3                   	ret    

0080c493 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80c493:	55                   	push   %ebp
  80c494:	89 e5                	mov    %esp,%ebp
  80c496:	56                   	push   %esi
  80c497:	53                   	push   %ebx
  80c498:	83 ec 10             	sub    $0x10,%esp
  80c49b:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80c49e:	8b 03                	mov    (%ebx),%eax
  80c4a0:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c4a4:	0f 85 dc 00 00 00    	jne    80c586 <do_newconn+0xf3>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80c4aa:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80c4ae:	8b 33                	mov    (%ebx),%esi
  80c4b0:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80c4b4:	74 1c                	je     80c4d2 <do_newconn+0x3f>
  80c4b6:	c7 44 24 08 60 40 81 	movl   $0x814060,0x8(%esp)
  80c4bd:	00 
  80c4be:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80c4c5:	00 
  80c4c6:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c4cd:	e8 68 2b 00 00       	call   80f03a <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80c4d2:	8b 06                	mov    (%esi),%eax
  80c4d4:	25 f0 00 00 00       	and    $0xf0,%eax
  80c4d9:	83 f8 20             	cmp    $0x20,%eax
  80c4dc:	74 48                	je     80c526 <do_newconn+0x93>
  80c4de:	83 f8 40             	cmp    $0x40,%eax
  80c4e1:	74 0f                	je     80c4f2 <do_newconn+0x5f>
  80c4e3:	83 f8 10             	cmp    $0x10,%eax
  80c4e6:	0f 85 96 00 00 00    	jne    80c582 <do_newconn+0xef>
  80c4ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c4f0:	eb 6f                	jmp    80c561 <do_newconn+0xce>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80c4f2:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80c4f6:	89 04 24             	mov    %eax,(%esp)
  80c4f9:	e8 12 25 00 00       	call   80ea10 <raw_new>
  80c4fe:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80c501:	8b 03                	mov    (%ebx),%eax
  80c503:	8b 50 08             	mov    0x8(%eax),%edx
  80c506:	85 d2                	test   %edx,%edx
  80c508:	75 06                	jne    80c510 <do_newconn+0x7d>
       msg->conn->err = ERR_MEM;
  80c50a:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c50e:	eb 76                	jmp    80c586 <do_newconn+0xf3>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80c510:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c514:	c7 44 24 04 cf bd 80 	movl   $0x80bdcf,0x4(%esp)
  80c51b:	00 
  80c51c:	89 14 24             	mov    %edx,(%esp)
  80c51f:	e8 47 23 00 00       	call   80e86b <raw_recv>
  80c524:	eb 60                	jmp    80c586 <do_newconn+0xf3>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80c526:	e8 c9 d2 ff ff       	call   8097f4 <udp_new>
  80c52b:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80c52e:	8b 03                	mov    (%ebx),%eax
  80c530:	8b 50 08             	mov    0x8(%eax),%edx
  80c533:	85 d2                	test   %edx,%edx
  80c535:	75 06                	jne    80c53d <do_newconn+0xaa>
       msg->conn->err = ERR_MEM;
  80c537:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c53b:	eb 49                	jmp    80c586 <do_newconn+0xf3>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80c53d:	83 38 22             	cmpl   $0x22,(%eax)
  80c540:	75 04                	jne    80c546 <do_newconn+0xb3>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80c542:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80c546:	8b 03                	mov    (%ebx),%eax
  80c548:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c54c:	c7 44 24 04 d0 bc 80 	movl   $0x80bcd0,0x4(%esp)
  80c553:	00 
  80c554:	8b 40 08             	mov    0x8(%eax),%eax
  80c557:	89 04 24             	mov    %eax,(%esp)
  80c55a:	e8 3b d2 ff ff       	call   80979a <udp_recv>
  80c55f:	eb 25                	jmp    80c586 <do_newconn+0xf3>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80c561:	e8 4f a3 ff ff       	call   8068b5 <tcp_new>
  80c566:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80c569:	8b 03                	mov    (%ebx),%eax
  80c56b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c56f:	75 06                	jne    80c577 <do_newconn+0xe4>
       msg->conn->err = ERR_MEM;
  80c571:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c575:	eb 0f                	jmp    80c586 <do_newconn+0xf3>
       break;
     }
     setup_tcp(msg->conn);
  80c577:	e8 41 f9 ff ff       	call   80bebd <setup_tcp>
  80c57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c580:	eb 04                	jmp    80c586 <do_newconn+0xf3>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80c582:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80c586:	8b 03                	mov    (%ebx),%eax
  80c588:	8b 40 10             	mov    0x10(%eax),%eax
  80c58b:	89 04 24             	mov    %eax,(%esp)
  80c58e:	e8 3d e3 ff ff       	call   80a8d0 <sys_sem_signal>
}
  80c593:	83 c4 10             	add    $0x10,%esp
  80c596:	5b                   	pop    %ebx
  80c597:	5e                   	pop    %esi
  80c598:	5d                   	pop    %ebp
  80c599:	c3                   	ret    

0080c59a <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80c59a:	55                   	push   %ebp
  80c59b:	89 e5                	mov    %esp,%ebp
  80c59d:	53                   	push   %ebx
  80c59e:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80c5a1:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c5a8:	e8 15 84 ff ff       	call   8049c2 <memp_malloc>
  80c5ad:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80c5af:	85 c0                	test   %eax,%eax
  80c5b1:	0f 84 96 00 00 00    	je     80c64d <netconn_alloc+0xb3>
    return NULL;
  }

  conn->err = ERR_OK;
  80c5b7:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80c5bb:	8b 45 08             	mov    0x8(%ebp),%eax
  80c5be:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80c5c0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80c5c7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c5ce:	e8 1b e0 ff ff       	call   80a5ee <sys_sem_new>
  80c5d3:	89 43 10             	mov    %eax,0x10(%ebx)
  80c5d6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c5d9:	75 17                	jne    80c5f2 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80c5db:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c5df:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c5e6:	e8 37 84 ff ff       	call   804a22 <memp_free>
    return NULL;
  80c5eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80c5f0:	eb 60                	jmp    80c652 <netconn_alloc+0xb8>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80c5f2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c5f9:	e8 b8 e1 ff ff       	call   80a7b6 <sys_mbox_new>
  80c5fe:	89 43 14             	mov    %eax,0x14(%ebx)
  80c601:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c604:	75 22                	jne    80c628 <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80c606:	8b 43 10             	mov    0x10(%ebx),%eax
  80c609:	89 04 24             	mov    %eax,(%esp)
  80c60c:	e8 66 e0 ff ff       	call   80a677 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80c611:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c615:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c61c:	e8 01 84 ff ff       	call   804a22 <memp_free>
    return NULL;
  80c621:	b8 00 00 00 00       	mov    $0x0,%eax
  80c626:	eb 2a                	jmp    80c652 <netconn_alloc+0xb8>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80c628:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80c62f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80c636:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80c63d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c640:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80c643:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  80c649:	89 d8                	mov    %ebx,%eax
  80c64b:	eb 05                	jmp    80c652 <netconn_alloc+0xb8>
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  80c64d:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80c652:	83 c4 14             	add    $0x14,%esp
  80c655:	5b                   	pop    %ebx
  80c656:	5d                   	pop    %ebp
  80c657:	c3                   	ret    

0080c658 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80c658:	55                   	push   %ebp
  80c659:	89 e5                	mov    %esp,%ebp
  80c65b:	56                   	push   %esi
  80c65c:	53                   	push   %ebx
  80c65d:	83 ec 20             	sub    $0x20,%esp
  80c660:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80c663:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c667:	74 1c                	je     80c685 <netconn_free+0x2d>
  80c669:	c7 44 24 08 80 40 81 	movl   $0x814080,0x8(%esp)
  80c670:	00 
  80c671:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80c678:	00 
  80c679:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c680:	e8 b5 29 00 00       	call   80f03a <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c685:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80c688:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c68c:	75 23                	jne    80c6b1 <netconn_free+0x59>
  80c68e:	eb 47                	jmp    80c6d7 <netconn_free+0x7f>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80c690:	83 3b 10             	cmpl   $0x10,(%ebx)
  80c693:	75 11                	jne    80c6a6 <netconn_free+0x4e>
        if(mem != NULL) {
  80c695:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c698:	85 c0                	test   %eax,%eax
  80c69a:	74 15                	je     80c6b1 <netconn_free+0x59>
          pbuf_free((struct pbuf *)mem);
  80c69c:	89 04 24             	mov    %eax,(%esp)
  80c69f:	e8 30 87 ff ff       	call   804dd4 <pbuf_free>
  80c6a4:	eb 0b                	jmp    80c6b1 <netconn_free+0x59>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80c6a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c6a9:	89 04 24             	mov    %eax,(%esp)
  80c6ac:	e8 7b 61 ff ff       	call   80282c <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c6b1:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c6b5:	8b 43 14             	mov    0x14(%ebx),%eax
  80c6b8:	89 04 24             	mov    %eax,(%esp)
  80c6bb:	e8 a2 e5 ff ff       	call   80ac62 <sys_arch_mbox_tryfetch>
  80c6c0:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c6c3:	75 cb                	jne    80c690 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80c6c5:	8b 43 14             	mov    0x14(%ebx),%eax
  80c6c8:	89 04 24             	mov    %eax,(%esp)
  80c6cb:	e8 3b e0 ff ff       	call   80a70b <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80c6d0:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c6d7:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c6db:	74 36                	je     80c713 <netconn_free+0xbb>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c6dd:	8d 75 f4             	lea    -0xc(%ebp),%esi
  80c6e0:	eb 0b                	jmp    80c6ed <netconn_free+0x95>
      netconn_delete((struct netconn *)mem);
  80c6e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c6e5:	89 04 24             	mov    %eax,(%esp)
  80c6e8:	e8 52 ef ff ff       	call   80b63f <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c6ed:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c6f1:	8b 43 18             	mov    0x18(%ebx),%eax
  80c6f4:	89 04 24             	mov    %eax,(%esp)
  80c6f7:	e8 66 e5 ff ff       	call   80ac62 <sys_arch_mbox_tryfetch>
  80c6fc:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c6ff:	75 e1                	jne    80c6e2 <netconn_free+0x8a>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80c701:	8b 43 18             	mov    0x18(%ebx),%eax
  80c704:	89 04 24             	mov    %eax,(%esp)
  80c707:	e8 ff df ff ff       	call   80a70b <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80c70c:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80c713:	8b 43 10             	mov    0x10(%ebx),%eax
  80c716:	89 04 24             	mov    %eax,(%esp)
  80c719:	e8 59 df ff ff       	call   80a677 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80c71e:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80c725:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c729:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c730:	e8 ed 82 ff ff       	call   804a22 <memp_free>
}
  80c735:	83 c4 20             	add    $0x20,%esp
  80c738:	5b                   	pop    %ebx
  80c739:	5e                   	pop    %esi
  80c73a:	5d                   	pop    %ebp
  80c73b:	c3                   	ret    

0080c73c <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80c73c:	55                   	push   %ebp
  80c73d:	89 e5                	mov    %esp,%ebp
  80c73f:	57                   	push   %edi
  80c740:	56                   	push   %esi
  80c741:	53                   	push   %ebx
  80c742:	83 ec 1c             	sub    $0x1c,%esp
  80c745:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c748:	8b 7d 10             	mov    0x10(%ebp),%edi
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80c74b:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c74f:	75 1c                	jne    80c76d <accept_function+0x31>
  80c751:	c7 44 24 08 b0 40 81 	movl   $0x8140b0,0x8(%esp)
  80c758:	00 
  80c759:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80c760:	00 
  80c761:	c7 04 24 da 40 81 00 	movl   $0x8140da,(%esp)
  80c768:	e8 cd 28 00 00       	call   80f03a <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80c76d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c770:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c774:	8b 03                	mov    (%ebx),%eax
  80c776:	89 04 24             	mov    %eax,(%esp)
  80c779:	e8 1c fe ff ff       	call   80c59a <netconn_alloc>
  80c77e:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80c780:	85 c0                	test   %eax,%eax
  80c782:	74 57                	je     80c7db <accept_function+0x9f>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80c784:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c787:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80c78a:	89 f0                	mov    %esi,%eax
  80c78c:	e8 2c f7 ff ff       	call   80bebd <setup_tcp>
  newconn->err = err;
  80c791:	89 f8                	mov    %edi,%eax
  80c793:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c796:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c799:	85 c0                	test   %eax,%eax
  80c79b:	74 15                	je     80c7b2 <accept_function+0x76>
  80c79d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c7a4:	00 
  80c7a5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c7ac:	00 
  80c7ad:	89 1c 24             	mov    %ebx,(%esp)
  80c7b0:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80c7b2:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c7b6:	8b 43 18             	mov    0x18(%ebx),%eax
  80c7b9:	89 04 24             	mov    %eax,(%esp)
  80c7bc:	e8 9b e2 ff ff       	call   80aa5c <sys_mbox_trypost>
  80c7c1:	84 c0                	test   %al,%al
  80c7c3:	74 1d                	je     80c7e2 <accept_function+0xa6>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80c7c5:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80c7cc:	89 34 24             	mov    %esi,(%esp)
  80c7cf:	e8 84 fe ff ff       	call   80c658 <netconn_free>
    return ERR_MEM;
  80c7d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c7d9:	eb 0c                	jmp    80c7e7 <accept_function+0xab>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80c7db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c7e0:	eb 05                	jmp    80c7e7 <accept_function+0xab>
       so do nothing here! */
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
  80c7e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c7e7:	83 c4 1c             	add    $0x1c,%esp
  80c7ea:	5b                   	pop    %ebx
  80c7eb:	5e                   	pop    %esi
  80c7ec:	5f                   	pop    %edi
  80c7ed:	5d                   	pop    %ebp
  80c7ee:	c3                   	ret    

0080c7ef <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80c7ef:	55                   	push   %ebp
  80c7f0:	89 e5                	mov    %esp,%ebp
  80c7f2:	53                   	push   %ebx
  80c7f3:	83 ec 14             	sub    $0x14,%esp
  80c7f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80c7f9:	8b 03                	mov    (%ebx),%eax
  80c7fb:	8b 48 08             	mov    0x8(%eax),%ecx
  80c7fe:	85 c9                	test   %ecx,%ecx
  80c800:	74 4b                	je     80c84d <do_delconn+0x5e>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c802:	8b 10                	mov    (%eax),%edx
  80c804:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c80a:	83 fa 20             	cmp    $0x20,%edx
  80c80d:	74 18                	je     80c827 <do_delconn+0x38>
  80c80f:	83 fa 40             	cmp    $0x40,%edx
  80c812:	74 07                	je     80c81b <do_delconn+0x2c>
  80c814:	83 fa 10             	cmp    $0x10,%edx
  80c817:	75 34                	jne    80c84d <do_delconn+0x5e>
  80c819:	eb 22                	jmp    80c83d <do_delconn+0x4e>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80c81b:	89 0c 24             	mov    %ecx,(%esp)
  80c81e:	66 90                	xchg   %ax,%ax
  80c820:	e8 a5 21 00 00       	call   80e9ca <raw_remove>
      break;
  80c825:	eb 26                	jmp    80c84d <do_delconn+0x5e>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80c827:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80c82e:	8b 03                	mov    (%ebx),%eax
  80c830:	8b 40 08             	mov    0x8(%eax),%eax
  80c833:	89 04 24             	mov    %eax,(%esp)
  80c836:	e8 73 cf ff ff       	call   8097ae <udp_remove>
      break;
  80c83b:	eb 10                	jmp    80c84d <do_delconn+0x5e>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80c83d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c844:	8b 03                	mov    (%ebx),%eax
  80c846:	e8 57 f9 ff ff       	call   80c1a2 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80c84b:	eb 4e                	jmp    80c89b <do_delconn+0xac>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80c84d:	8b 13                	mov    (%ebx),%edx
  80c84f:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c852:	85 c0                	test   %eax,%eax
  80c854:	74 33                	je     80c889 <do_delconn+0x9a>
  80c856:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c85d:	00 
  80c85e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c865:	00 
  80c866:	89 14 24             	mov    %edx,(%esp)
  80c869:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80c86b:	8b 13                	mov    (%ebx),%edx
  80c86d:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c870:	85 c0                	test   %eax,%eax
  80c872:	74 15                	je     80c889 <do_delconn+0x9a>
  80c874:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c87b:	00 
  80c87c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c883:	00 
  80c884:	89 14 24             	mov    %edx,(%esp)
  80c887:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80c889:	8b 03                	mov    (%ebx),%eax
  80c88b:	8b 40 10             	mov    0x10(%eax),%eax
  80c88e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c891:	74 08                	je     80c89b <do_delconn+0xac>
    sys_sem_signal(msg->conn->op_completed);
  80c893:	89 04 24             	mov    %eax,(%esp)
  80c896:	e8 35 e0 ff ff       	call   80a8d0 <sys_sem_signal>
  }
}
  80c89b:	83 c4 14             	add    $0x14,%esp
  80c89e:	5b                   	pop    %ebx
  80c89f:	5d                   	pop    %ebp
  80c8a0:	c3                   	ret    

0080c8a1 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80c8a1:	55                   	push   %ebp
  80c8a2:	89 e5                	mov    %esp,%ebp
  80c8a4:	56                   	push   %esi
  80c8a5:	53                   	push   %ebx
  80c8a6:	83 ec 10             	sub    $0x10,%esp
  80c8a9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c8ac:	8b 33                	mov    (%ebx),%esi
  80c8ae:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c8b2:	7c 6f                	jl     80c923 <do_bind+0x82>
    if (msg->conn->pcb.tcp != NULL) {
  80c8b4:	8b 56 08             	mov    0x8(%esi),%edx
  80c8b7:	85 d2                	test   %edx,%edx
  80c8b9:	74 64                	je     80c91f <do_bind+0x7e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c8bb:	8b 06                	mov    (%esi),%eax
  80c8bd:	25 f0 00 00 00       	and    $0xf0,%eax
  80c8c2:	83 f8 20             	cmp    $0x20,%eax
  80c8c5:	74 20                	je     80c8e7 <do_bind+0x46>
  80c8c7:	83 f8 40             	cmp    $0x40,%eax
  80c8ca:	74 07                	je     80c8d3 <do_bind+0x32>
  80c8cc:	83 f8 10             	cmp    $0x10,%eax
  80c8cf:	75 52                	jne    80c923 <do_bind+0x82>
  80c8d1:	eb 30                	jmp    80c903 <do_bind+0x62>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c8d3:	8b 43 04             	mov    0x4(%ebx),%eax
  80c8d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c8da:	89 14 24             	mov    %edx,(%esp)
  80c8dd:	e8 4a 1f 00 00       	call   80e82c <raw_bind>
  80c8e2:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c8e5:	eb 3c                	jmp    80c923 <do_bind+0x82>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c8e7:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c8eb:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c8ef:	8b 43 04             	mov    0x4(%ebx),%eax
  80c8f2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c8f6:	89 14 24             	mov    %edx,(%esp)
  80c8f9:	e8 13 cb ff ff       	call   809411 <udp_bind>
  80c8fe:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c901:	eb 20                	jmp    80c923 <do_bind+0x82>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c903:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c907:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c90b:	8b 43 04             	mov    0x4(%ebx),%eax
  80c90e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c912:	89 14 24             	mov    %edx,(%esp)
  80c915:	e8 c9 90 ff ff       	call   8059e3 <tcp_bind>
  80c91a:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c91d:	eb 04                	jmp    80c923 <do_bind+0x82>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80c91f:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c923:	8b 03                	mov    (%ebx),%eax
  80c925:	8b 40 10             	mov    0x10(%eax),%eax
  80c928:	89 04 24             	mov    %eax,(%esp)
  80c92b:	e8 a0 df ff ff       	call   80a8d0 <sys_sem_signal>
}
  80c930:	83 c4 10             	add    $0x10,%esp
  80c933:	5b                   	pop    %ebx
  80c934:	5e                   	pop    %esi
  80c935:	5d                   	pop    %ebp
  80c936:	c3                   	ret    

0080c937 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80c937:	55                   	push   %ebp
  80c938:	89 e5                	mov    %esp,%ebp
  80c93a:	56                   	push   %esi
  80c93b:	53                   	push   %ebx
  80c93c:	83 ec 10             	sub    $0x10,%esp
  80c93f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80c942:	8b 33                	mov    (%ebx),%esi
  80c944:	8b 56 08             	mov    0x8(%esi),%edx
  80c947:	85 d2                	test   %edx,%edx
  80c949:	75 10                	jne    80c95b <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80c94b:	8b 46 10             	mov    0x10(%esi),%eax
  80c94e:	89 04 24             	mov    %eax,(%esp)
  80c951:	e8 7a df ff ff       	call   80a8d0 <sys_sem_signal>
    return;
  80c956:	e9 9b 00 00 00       	jmp    80c9f6 <do_connect+0xbf>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c95b:	8b 06                	mov    (%esi),%eax
  80c95d:	25 f0 00 00 00       	and    $0xf0,%eax
  80c962:	83 f8 20             	cmp    $0x20,%eax
  80c965:	74 31                	je     80c998 <do_connect+0x61>
  80c967:	83 f8 40             	cmp    $0x40,%eax
  80c96a:	74 0b                	je     80c977 <do_connect+0x40>
  80c96c:	83 f8 10             	cmp    $0x10,%eax
  80c96f:	0f 85 81 00 00 00    	jne    80c9f6 <do_connect+0xbf>
  80c975:	eb 4a                	jmp    80c9c1 <do_connect+0x8a>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c977:	8b 43 04             	mov    0x4(%ebx),%eax
  80c97a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c97e:	89 14 24             	mov    %edx,(%esp)
  80c981:	e8 c5 1e 00 00       	call   80e84b <raw_connect>
  80c986:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c989:	8b 03                	mov    (%ebx),%eax
  80c98b:	8b 40 10             	mov    0x10(%eax),%eax
  80c98e:	89 04 24             	mov    %eax,(%esp)
  80c991:	e8 3a df ff ff       	call   80a8d0 <sys_sem_signal>
    break;
  80c996:	eb 5e                	jmp    80c9f6 <do_connect+0xbf>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c998:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c99c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c9a0:	8b 43 04             	mov    0x4(%ebx),%eax
  80c9a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c9a7:	89 14 24             	mov    %edx,(%esp)
  80c9aa:	e8 56 cd ff ff       	call   809705 <udp_connect>
  80c9af:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c9b2:	8b 03                	mov    (%ebx),%eax
  80c9b4:	8b 40 10             	mov    0x10(%eax),%eax
  80c9b7:	89 04 24             	mov    %eax,(%esp)
  80c9ba:	e8 11 df ff ff       	call   80a8d0 <sys_sem_signal>
    break;
  80c9bf:	eb 35                	jmp    80c9f6 <do_connect+0xbf>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80c9c1:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80c9c8:	8b 03                	mov    (%ebx),%eax
  80c9ca:	e8 ee f4 ff ff       	call   80bebd <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80c9cf:	8b 33                	mov    (%ebx),%esi
  80c9d1:	c7 44 24 0c 21 bf 80 	movl   $0x80bf21,0xc(%esp)
  80c9d8:	00 
  80c9d9:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c9dd:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c9e1:	8b 43 04             	mov    0x4(%ebx),%eax
  80c9e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c9e8:	8b 46 08             	mov    0x8(%esi),%eax
  80c9eb:	89 04 24             	mov    %eax,(%esp)
  80c9ee:	e8 0d 9f ff ff       	call   806900 <tcp_connect>
  80c9f3:	88 46 0c             	mov    %al,0xc(%esi)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80c9f6:	83 c4 10             	add    $0x10,%esp
  80c9f9:	5b                   	pop    %ebx
  80c9fa:	5e                   	pop    %esi
  80c9fb:	5d                   	pop    %ebp
  80c9fc:	c3                   	ret    

0080c9fd <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80c9fd:	55                   	push   %ebp
  80c9fe:	89 e5                	mov    %esp,%ebp
  80ca00:	53                   	push   %ebx
  80ca01:	83 ec 14             	sub    $0x14,%esp
  80ca04:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80ca07:	8b 03                	mov    (%ebx),%eax
  80ca09:	8b 10                	mov    (%eax),%edx
  80ca0b:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80ca11:	83 fa 20             	cmp    $0x20,%edx
  80ca14:	75 0b                	jne    80ca21 <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80ca16:	8b 40 08             	mov    0x8(%eax),%eax
  80ca19:	89 04 24             	mov    %eax,(%esp)
  80ca1c:	e8 5e cd ff ff       	call   80977f <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80ca21:	8b 03                	mov    (%ebx),%eax
  80ca23:	8b 40 10             	mov    0x10(%eax),%eax
  80ca26:	89 04 24             	mov    %eax,(%esp)
  80ca29:	e8 a2 de ff ff       	call   80a8d0 <sys_sem_signal>
}
  80ca2e:	83 c4 14             	add    $0x14,%esp
  80ca31:	5b                   	pop    %ebx
  80ca32:	5d                   	pop    %ebp
  80ca33:	c3                   	ret    

0080ca34 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80ca34:	55                   	push   %ebp
  80ca35:	89 e5                	mov    %esp,%ebp
  80ca37:	57                   	push   %edi
  80ca38:	56                   	push   %esi
  80ca39:	53                   	push   %ebx
  80ca3a:	83 ec 1c             	sub    $0x1c,%esp
  80ca3d:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ca40:	8b 03                	mov    (%ebx),%eax
  80ca42:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ca46:	0f 8c b9 00 00 00    	jl     80cb05 <do_listen+0xd1>
    if (msg->conn->pcb.tcp != NULL) {
  80ca4c:	8b 50 08             	mov    0x8(%eax),%edx
  80ca4f:	85 d2                	test   %edx,%edx
  80ca51:	0f 84 ae 00 00 00    	je     80cb05 <do_listen+0xd1>
      if (msg->conn->type == NETCONN_TCP) {
  80ca57:	83 38 10             	cmpl   $0x10,(%eax)
  80ca5a:	0f 85 a5 00 00 00    	jne    80cb05 <do_listen+0xd1>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80ca60:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80ca64:	0f 85 97 00 00 00    	jne    80cb01 <do_listen+0xcd>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80ca6a:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80ca71:	00 
  80ca72:	89 14 24             	mov    %edx,(%esp)
  80ca75:	e8 2c 91 ff ff       	call   805ba6 <tcp_listen_with_backlog>
  80ca7a:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80ca7c:	85 c0                	test   %eax,%eax
  80ca7e:	75 08                	jne    80ca88 <do_listen+0x54>
            msg->conn->err = ERR_MEM;
  80ca80:	8b 03                	mov    (%ebx),%eax
  80ca82:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80ca86:	eb 7d                	jmp    80cb05 <do_listen+0xd1>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80ca88:	8b 03                	mov    (%ebx),%eax
  80ca8a:	8b 40 14             	mov    0x14(%eax),%eax
  80ca8d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ca90:	74 11                	je     80caa3 <do_listen+0x6f>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80ca92:	89 04 24             	mov    %eax,(%esp)
  80ca95:	e8 71 dc ff ff       	call   80a70b <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80ca9a:	8b 03                	mov    (%ebx),%eax
  80ca9c:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80caa3:	8b 3b                	mov    (%ebx),%edi
  80caa5:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80caa9:	75 1a                	jne    80cac5 <do_listen+0x91>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80caab:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80cab2:	e8 ff dc ff ff       	call   80a7b6 <sys_mbox_new>
  80cab7:	89 47 18             	mov    %eax,0x18(%edi)
  80caba:	83 f8 ff             	cmp    $0xffffffff,%eax
  80cabd:	75 06                	jne    80cac5 <do_listen+0x91>
                msg->conn->err = ERR_MEM;
  80cabf:	8b 03                	mov    (%ebx),%eax
  80cac1:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80cac5:	8b 03                	mov    (%ebx),%eax
  80cac7:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cacb:	75 38                	jne    80cb05 <do_listen+0xd1>
              msg->conn->state = NETCONN_LISTEN;
  80cacd:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80cad4:	8b 03                	mov    (%ebx),%eax
  80cad6:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80cad9:	8b 03                	mov    (%ebx),%eax
  80cadb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cadf:	8b 40 08             	mov    0x8(%eax),%eax
  80cae2:	89 04 24             	mov    %eax,(%esp)
  80cae5:	e8 82 93 ff ff       	call   805e6c <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80caea:	c7 44 24 04 3c c7 80 	movl   $0x80c73c,0x4(%esp)
  80caf1:	00 
  80caf2:	8b 03                	mov    (%ebx),%eax
  80caf4:	8b 40 08             	mov    0x8(%eax),%eax
  80caf7:	89 04 24             	mov    %eax,(%esp)
  80cafa:	e8 ae 93 ff ff       	call   805ead <tcp_accept>
  80caff:	eb 04                	jmp    80cb05 <do_listen+0xd1>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80cb01:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80cb05:	8b 03                	mov    (%ebx),%eax
  80cb07:	8b 40 10             	mov    0x10(%eax),%eax
  80cb0a:	89 04 24             	mov    %eax,(%esp)
  80cb0d:	e8 be dd ff ff       	call   80a8d0 <sys_sem_signal>
}
  80cb12:	83 c4 1c             	add    $0x1c,%esp
  80cb15:	5b                   	pop    %ebx
  80cb16:	5e                   	pop    %esi
  80cb17:	5f                   	pop    %edi
  80cb18:	5d                   	pop    %ebp
  80cb19:	c3                   	ret    

0080cb1a <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80cb1a:	55                   	push   %ebp
  80cb1b:	89 e5                	mov    %esp,%ebp
  80cb1d:	57                   	push   %edi
  80cb1e:	56                   	push   %esi
  80cb1f:	53                   	push   %ebx
  80cb20:	83 ec 1c             	sub    $0x1c,%esp
  80cb23:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cb26:	8b 1e                	mov    (%esi),%ebx
  80cb28:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80cb2c:	0f 8c 8b 00 00 00    	jl     80cbbd <do_send+0xa3>
    if (msg->conn->pcb.tcp != NULL) {
  80cb32:	8b 43 08             	mov    0x8(%ebx),%eax
  80cb35:	85 c0                	test   %eax,%eax
  80cb37:	0f 84 80 00 00 00    	je     80cbbd <do_send+0xa3>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80cb3d:	8b 13                	mov    (%ebx),%edx
  80cb3f:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80cb45:	83 fa 20             	cmp    $0x20,%edx
  80cb48:	74 39                	je     80cb83 <do_send+0x69>
  80cb4a:	83 fa 40             	cmp    $0x40,%edx
  80cb4d:	75 6e                	jne    80cbbd <do_send+0xa3>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80cb4f:	8b 56 04             	mov    0x4(%esi),%edx
  80cb52:	8b 4a 08             	mov    0x8(%edx),%ecx
  80cb55:	85 c9                	test   %ecx,%ecx
  80cb57:	75 13                	jne    80cb6c <do_send+0x52>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80cb59:	8b 12                	mov    (%edx),%edx
  80cb5b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cb5f:	89 04 24             	mov    %eax,(%esp)
  80cb62:	e8 42 1e 00 00       	call   80e9a9 <raw_send>
  80cb67:	88 43 0c             	mov    %al,0xc(%ebx)
  80cb6a:	eb 51                	jmp    80cbbd <do_send+0xa3>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80cb6c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80cb70:	8b 12                	mov    (%edx),%edx
  80cb72:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cb76:	89 04 24             	mov    %eax,(%esp)
  80cb79:	e8 01 1d 00 00       	call   80e87f <raw_sendto>
  80cb7e:	88 43 0c             	mov    %al,0xc(%ebx)
  80cb81:	eb 3a                	jmp    80cbbd <do_send+0xa3>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80cb83:	8b 56 04             	mov    0x4(%esi),%edx
  80cb86:	8b 4a 08             	mov    0x8(%edx),%ecx
  80cb89:	85 c9                	test   %ecx,%ecx
  80cb8b:	75 13                	jne    80cba0 <do_send+0x86>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80cb8d:	8b 12                	mov    (%edx),%edx
  80cb8f:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cb93:	89 04 24             	mov    %eax,(%esp)
  80cb96:	e8 41 cb ff ff       	call   8096dc <udp_send>
  80cb9b:	88 43 0c             	mov    %al,0xc(%ebx)
  80cb9e:	eb 1d                	jmp    80cbbd <do_send+0xa3>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80cba0:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80cba4:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80cba8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80cbac:	8b 12                	mov    (%edx),%edx
  80cbae:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cbb2:	89 04 24             	mov    %eax,(%esp)
  80cbb5:	e8 d9 ca ff ff       	call   809693 <udp_sendto>
  80cbba:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80cbbd:	8b 06                	mov    (%esi),%eax
  80cbbf:	8b 40 10             	mov    0x10(%eax),%eax
  80cbc2:	89 04 24             	mov    %eax,(%esp)
  80cbc5:	e8 06 dd ff ff       	call   80a8d0 <sys_sem_signal>
}
  80cbca:	83 c4 1c             	add    $0x1c,%esp
  80cbcd:	5b                   	pop    %ebx
  80cbce:	5e                   	pop    %esi
  80cbcf:	5f                   	pop    %edi
  80cbd0:	5d                   	pop    %ebp
  80cbd1:	c3                   	ret    

0080cbd2 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80cbd2:	55                   	push   %ebp
  80cbd3:	89 e5                	mov    %esp,%ebp
  80cbd5:	53                   	push   %ebx
  80cbd6:	83 ec 14             	sub    $0x14,%esp
  80cbd9:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cbdc:	8b 03                	mov    (%ebx),%eax
  80cbde:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80cbe2:	7c 1c                	jl     80cc00 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80cbe4:	8b 50 08             	mov    0x8(%eax),%edx
  80cbe7:	85 d2                	test   %edx,%edx
  80cbe9:	74 15                	je     80cc00 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80cbeb:	83 38 10             	cmpl   $0x10,(%eax)
  80cbee:	75 10                	jne    80cc00 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80cbf0:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80cbf4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cbf8:	89 14 24             	mov    %edx,(%esp)
  80cbfb:	e8 a4 90 ff ff       	call   805ca4 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80cc00:	8b 03                	mov    (%ebx),%eax
  80cc02:	8b 40 10             	mov    0x10(%eax),%eax
  80cc05:	89 04 24             	mov    %eax,(%esp)
  80cc08:	e8 c3 dc ff ff       	call   80a8d0 <sys_sem_signal>
}
  80cc0d:	83 c4 14             	add    $0x14,%esp
  80cc10:	5b                   	pop    %ebx
  80cc11:	5d                   	pop    %ebp
  80cc12:	c3                   	ret    

0080cc13 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80cc13:	55                   	push   %ebp
  80cc14:	89 e5                	mov    %esp,%ebp
  80cc16:	83 ec 18             	sub    $0x18,%esp
  80cc19:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cc1c:	8b 02                	mov    (%edx),%eax
  80cc1e:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80cc22:	7c 2d                	jl     80cc51 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80cc24:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cc28:	74 23                	je     80cc4d <do_write+0x3a>
  80cc2a:	83 38 10             	cmpl   $0x10,(%eax)
  80cc2d:	75 1e                	jne    80cc4d <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80cc2f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80cc36:	8b 02                	mov    (%edx),%eax
  80cc38:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80cc3b:	8b 02                	mov    (%edx),%eax
  80cc3d:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80cc44:	8b 02                	mov    (%edx),%eax
  80cc46:	e8 01 f4 ff ff       	call   80c04c <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80cc4b:	eb 11                	jmp    80cc5e <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80cc4d:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80cc51:	8b 02                	mov    (%edx),%eax
  80cc53:	8b 40 10             	mov    0x10(%eax),%eax
  80cc56:	89 04 24             	mov    %eax,(%esp)
  80cc59:	e8 72 dc ff ff       	call   80a8d0 <sys_sem_signal>
}
  80cc5e:	c9                   	leave  
  80cc5f:	c3                   	ret    

0080cc60 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80cc60:	55                   	push   %ebp
  80cc61:	89 e5                	mov    %esp,%ebp
  80cc63:	83 ec 18             	sub    $0x18,%esp
  80cc66:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80cc69:	8b 08                	mov    (%eax),%ecx
  80cc6b:	8b 51 08             	mov    0x8(%ecx),%edx
  80cc6e:	85 d2                	test   %edx,%edx
  80cc70:	0f 84 98 00 00 00    	je     80cd0e <do_getaddr+0xae>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80cc76:	8b 48 04             	mov    0x4(%eax),%ecx
  80cc79:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cc7d:	74 06                	je     80cc85 <do_getaddr+0x25>
  80cc7f:	8b 12                	mov    (%edx),%edx
  80cc81:	89 11                	mov    %edx,(%ecx)
  80cc83:	eb 05                	jmp    80cc8a <do_getaddr+0x2a>
  80cc85:	8b 52 04             	mov    0x4(%edx),%edx
  80cc88:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80cc8a:	8b 08                	mov    (%eax),%ecx
  80cc8c:	8b 11                	mov    (%ecx),%edx
  80cc8e:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80cc94:	83 fa 20             	cmp    $0x20,%edx
  80cc97:	74 27                	je     80ccc0 <do_getaddr+0x60>
  80cc99:	83 fa 40             	cmp    $0x40,%edx
  80cc9c:	74 07                	je     80cca5 <do_getaddr+0x45>
  80cc9e:	83 fa 10             	cmp    $0x10,%edx
  80cca1:	75 6f                	jne    80cd12 <do_getaddr+0xb2>
  80cca3:	eb 4b                	jmp    80ccf0 <do_getaddr+0x90>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80cca5:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cca9:	74 0f                	je     80ccba <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80ccab:	8b 50 08             	mov    0x8(%eax),%edx
  80ccae:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ccb1:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80ccb5:	66 89 0a             	mov    %cx,(%edx)
  80ccb8:	eb 58                	jmp    80cd12 <do_getaddr+0xb2>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80ccba:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80ccbe:	eb 52                	jmp    80cd12 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80ccc0:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ccc4:	74 0f                	je     80ccd5 <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80ccc6:	8b 50 08             	mov    0x8(%eax),%edx
  80ccc9:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cccc:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80ccd0:	66 89 0a             	mov    %cx,(%edx)
  80ccd3:	eb 3d                	jmp    80cd12 <do_getaddr+0xb2>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80ccd5:	8b 51 08             	mov    0x8(%ecx),%edx
  80ccd8:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80ccdc:	75 06                	jne    80cce4 <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80ccde:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80cce2:	eb 2e                	jmp    80cd12 <do_getaddr+0xb2>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80cce4:	8b 48 08             	mov    0x8(%eax),%ecx
  80cce7:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80cceb:	66 89 11             	mov    %dx,(%ecx)
  80ccee:	eb 22                	jmp    80cd12 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80ccf0:	8b 50 08             	mov    0x8(%eax),%edx
  80ccf3:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ccf7:	74 09                	je     80cd02 <do_getaddr+0xa2>
  80ccf9:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ccfc:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80cd00:	eb 07                	jmp    80cd09 <do_getaddr+0xa9>
  80cd02:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cd05:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80cd09:	66 89 0a             	mov    %cx,(%edx)
      break;
  80cd0c:	eb 04                	jmp    80cd12 <do_getaddr+0xb2>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80cd0e:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80cd12:	8b 00                	mov    (%eax),%eax
  80cd14:	8b 40 10             	mov    0x10(%eax),%eax
  80cd17:	89 04 24             	mov    %eax,(%esp)
  80cd1a:	e8 b1 db ff ff       	call   80a8d0 <sys_sem_signal>
}
  80cd1f:	c9                   	leave  
  80cd20:	c3                   	ret    

0080cd21 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80cd21:	55                   	push   %ebp
  80cd22:	89 e5                	mov    %esp,%ebp
  80cd24:	83 ec 18             	sub    $0x18,%esp
  80cd27:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80cd2a:	8b 02                	mov    (%edx),%eax
  80cd2c:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cd30:	74 15                	je     80cd47 <do_close+0x26>
  80cd32:	83 38 10             	cmpl   $0x10,(%eax)
  80cd35:	75 10                	jne    80cd47 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80cd37:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80cd3e:	8b 02                	mov    (%edx),%eax
  80cd40:	e8 5d f4 ff ff       	call   80c1a2 <do_close_internal>
  80cd45:	eb 11                	jmp    80cd58 <do_close+0x37>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80cd47:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80cd4b:	8b 02                	mov    (%edx),%eax
  80cd4d:	8b 40 10             	mov    0x10(%eax),%eax
  80cd50:	89 04 24             	mov    %eax,(%esp)
  80cd53:	e8 78 db ff ff       	call   80a8d0 <sys_sem_signal>
  }
}
  80cd58:	c9                   	leave  
  80cd59:	c3                   	ret    
  80cd5a:	66 90                	xchg   %ax,%ax
  80cd5c:	66 90                	xchg   %ax,%ax
  80cd5e:	66 90                	xchg   %ax,%ax

0080cd60 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80cd60:	55                   	push   %ebp
  80cd61:	89 e5                	mov    %esp,%ebp
  80cd63:	57                   	push   %edi
  80cd64:	56                   	push   %esi
  80cd65:	53                   	push   %ebx
  80cd66:	83 ec 1c             	sub    $0x1c,%esp
  80cd69:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80cd6b:	8b 35 d0 c1 b3 00    	mov    0xb3c1d0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80cd71:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80cd75:	89 04 24             	mov    %eax,(%esp)
  80cd78:	e8 d6 af ff ff       	call   807d53 <ntohs>
  80cd7d:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80cd81:	76 7f                	jbe    80ce02 <tcp_parseopt+0xa2>
{
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80cd83:	83 c6 14             	add    $0x14,%esi
  80cd86:	bb 00 00 00 00       	mov    $0x0,%ebx
  80cd8b:	eb 4f                	jmp    80cddc <tcp_parseopt+0x7c>

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80cd8d:	0f b6 d3             	movzbl %bl,%edx
  80cd90:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80cd94:	84 c0                	test   %al,%al
  80cd96:	74 6a                	je     80ce02 <tcp_parseopt+0xa2>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80cd98:	3c 01                	cmp    $0x1,%al
  80cd9a:	75 05                	jne    80cda1 <tcp_parseopt+0x41>
        ++c;
  80cd9c:	83 c3 01             	add    $0x1,%ebx
  80cd9f:	eb 3b                	jmp    80cddc <tcp_parseopt+0x7c>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80cda1:	3c 02                	cmp    $0x2,%al
  80cda3:	75 2c                	jne    80cdd1 <tcp_parseopt+0x71>
  80cda5:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80cdaa:	75 25                	jne    80cdd1 <tcp_parseopt+0x71>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80cdac:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80cdb1:	c1 e0 08             	shl    $0x8,%eax
  80cdb4:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80cdb9:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80cdbb:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cdbe:	66 81 fa b4 05       	cmp    $0x5b4,%dx
  80cdc3:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80cdc8:	0f 43 c2             	cmovae %edx,%eax
  80cdcb:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80cdcf:	eb 31                	jmp    80ce02 <tcp_parseopt+0xa2>
      } else {
        if (opts[c + 1] == 0) {
  80cdd1:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80cdd6:	84 c0                	test   %al,%al
  80cdd8:	74 28                	je     80ce02 <tcp_parseopt+0xa2>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80cdda:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80cddc:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80cde1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cde5:	89 04 24             	mov    %eax,(%esp)
  80cde8:	e8 66 af ff ff       	call   807d53 <ntohs>
  80cded:	0f b6 d3             	movzbl %bl,%edx
  80cdf0:	66 c1 e8 0c          	shr    $0xc,%ax
  80cdf4:	0f b7 c0             	movzwl %ax,%eax
  80cdf7:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80cdfe:	39 c2                	cmp    %eax,%edx
  80ce00:	7c 8b                	jl     80cd8d <tcp_parseopt+0x2d>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80ce02:	83 c4 1c             	add    $0x1c,%esp
  80ce05:	5b                   	pop    %ebx
  80ce06:	5e                   	pop    %esi
  80ce07:	5f                   	pop    %edi
  80ce08:	5d                   	pop    %ebp
  80ce09:	c3                   	ret    

0080ce0a <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80ce0a:	55                   	push   %ebp
  80ce0b:	89 e5                	mov    %esp,%ebp
  80ce0d:	57                   	push   %edi
  80ce0e:	56                   	push   %esi
  80ce0f:	53                   	push   %ebx
  80ce10:	83 ec 2c             	sub    $0x2c,%esp
  80ce13:	89 c7                	mov    %eax,%edi
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80ce15:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80ce1c:	0f 84 45 04 00 00    	je     80d267 <tcp_receive+0x45d>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80ce22:	0f b7 58 5c          	movzwl 0x5c(%eax),%ebx
  80ce26:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80ce29:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80ce2e:	39 c2                	cmp    %eax,%edx
  80ce30:	78 26                	js     80ce58 <tcp_receive+0x4e>
  80ce32:	39 c2                	cmp    %eax,%edx
  80ce34:	75 0b                	jne    80ce41 <tcp_receive+0x37>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80ce36:	8b 0d c4 c1 b3 00    	mov    0xb3c1c4,%ecx
  80ce3c:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80ce3f:	78 17                	js     80ce58 <tcp_receive+0x4e>
  80ce41:	8b 0d c4 c1 b3 00    	mov    0xb3c1c4,%ecx
  80ce47:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80ce4a:	75 3a                	jne    80ce86 <tcp_receive+0x7c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80ce4c:	8b 0d d0 c1 b3 00    	mov    0xb3c1d0,%ecx
  80ce52:	66 3b 59 0e          	cmp    0xe(%ecx),%bx
  80ce56:	73 2e                	jae    80ce86 <tcp_receive+0x7c>
      pcb->snd_wnd = tcphdr->wnd;
  80ce58:	8b 0d d0 c1 b3 00    	mov    0xb3c1d0,%ecx
  80ce5e:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  80ce62:	66 89 4f 5c          	mov    %cx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80ce66:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80ce69:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80ce6e:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80ce71:	66 85 c9             	test   %cx,%cx
  80ce74:	74 10                	je     80ce86 <tcp_receive+0x7c>
  80ce76:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80ce7d:	74 07                	je     80ce86 <tcp_receive+0x7c>
          pcb->persist_backoff = 0;
  80ce7f:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80ce86:	8b 4f 48             	mov    0x48(%edi),%ecx
  80ce89:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80ce8e:	39 c1                	cmp    %eax,%ecx
  80ce90:	0f 85 a9 00 00 00    	jne    80cf3f <tcp_receive+0x135>
      pcb->acked = 0;
  80ce96:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80ce9c:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80cea0:	03 47 60             	add    0x60(%edi),%eax
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80cea3:	0f b7 db             	movzwl %bx,%ebx
  80cea6:	01 da                	add    %ebx,%edx
    }

    if (pcb->lastack == ackno) {
      pcb->acked = 0;

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80cea8:	39 d0                	cmp    %edx,%eax
  80ceaa:	0f 85 e9 02 00 00    	jne    80d199 <tcp_receive+0x38f>
        ++pcb->dupacks;
  80ceb0:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80ceb4:	83 c0 01             	add    $0x1,%eax
  80ceb7:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80ceba:	3c 02                	cmp    $0x2,%al
  80cebc:	0f 86 d7 02 00 00    	jbe    80d199 <tcp_receive+0x38f>
  80cec2:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80cec6:	0f 84 cd 02 00 00    	je     80d199 <tcp_receive+0x38f>
          if (!(pcb->flags & TF_INFR)) {
  80cecc:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80ced0:	75 51                	jne    80cf23 <tcp_receive+0x119>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80ced2:	89 3c 24             	mov    %edi,(%esp)
  80ced5:	e8 9c be ff ff       	call   808d76 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80ceda:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80cede:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80cee2:	66 39 d0             	cmp    %dx,%ax
  80cee5:	76 09                	jbe    80cef0 <tcp_receive+0xe6>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80cee7:	66 d1 ea             	shr    %dx
  80ceea:	66 89 57 50          	mov    %dx,0x50(%edi)
  80ceee:	eb 07                	jmp    80cef7 <tcp_receive+0xed>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80cef0:	66 d1 e8             	shr    %ax
  80cef3:	66 89 47 50          	mov    %ax,0x50(%edi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80cef7:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80cefb:	0f b7 4f 50          	movzwl 0x50(%edi),%ecx
  80ceff:	0f b7 d0             	movzwl %ax,%edx
  80cf02:	01 d2                	add    %edx,%edx
  80cf04:	39 d1                	cmp    %edx,%ecx
  80cf06:	7d 07                	jge    80cf0f <tcp_receive+0x105>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80cf08:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80cf0b:	66 89 57 50          	mov    %dx,0x50(%edi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80cf0f:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80cf12:	66 03 47 50          	add    0x50(%edi),%ax
  80cf16:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80cf1a:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80cf1e:	e9 76 02 00 00       	jmp    80d199 <tcp_receive+0x38f>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80cf23:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80cf27:	89 d0                	mov    %edx,%eax
  80cf29:	66 03 47 34          	add    0x34(%edi),%ax
  80cf2d:	66 39 c2             	cmp    %ax,%dx
  80cf30:	0f 83 63 02 00 00    	jae    80d199 <tcp_receive+0x38f>
              pcb->cwnd += pcb->mss;
  80cf36:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80cf3a:	e9 5a 02 00 00       	jmp    80d199 <tcp_receive+0x38f>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80cf3f:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cf42:	39 ca                	cmp    %ecx,%edx
  80cf44:	0f 88 a1 01 00 00    	js     80d0eb <tcp_receive+0x2e1>
  80cf4a:	89 c2                	mov    %eax,%edx
  80cf4c:	2b 57 58             	sub    0x58(%edi),%edx
  80cf4f:	85 d2                	test   %edx,%edx
  80cf51:	0f 8f 94 01 00 00    	jg     80d0eb <tcp_receive+0x2e1>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80cf57:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80cf5b:	f6 c2 04             	test   $0x4,%dl
  80cf5e:	74 0e                	je     80cf6e <tcp_receive+0x164>
        pcb->flags &= ~TF_INFR;
  80cf60:	83 e2 fb             	and    $0xfffffffb,%edx
  80cf63:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80cf66:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80cf6a:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80cf6e:	c6 47 46 00          	movb   $0x0,0x46(%edi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80cf72:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80cf76:	66 c1 fa 03          	sar    $0x3,%dx
  80cf7a:	66 03 57 42          	add    0x42(%edi),%dx
  80cf7e:	66 89 57 44          	mov    %dx,0x44(%edi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80cf82:	89 c2                	mov    %eax,%edx
  80cf84:	29 ca                	sub    %ecx,%edx
  80cf86:	66 89 57 6c          	mov    %dx,0x6c(%edi)

      pcb->snd_buf += pcb->acked;
  80cf8a:	66 01 57 6e          	add    %dx,0x6e(%edi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80cf8e:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80cf92:	89 47 48             	mov    %eax,0x48(%edi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80cf95:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80cf99:	0f 86 cd 00 00 00    	jbe    80d06c <tcp_receive+0x262>
        if (pcb->cwnd < pcb->ssthresh) {
  80cf9f:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80cfa3:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80cfa7:	73 18                	jae    80cfc1 <tcp_receive+0x1b7>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80cfa9:	89 c8                	mov    %ecx,%eax
  80cfab:	66 03 47 34          	add    0x34(%edi),%ax
  80cfaf:	66 39 c1             	cmp    %ax,%cx
  80cfb2:	0f 83 b4 00 00 00    	jae    80d06c <tcp_receive+0x262>
            pcb->cwnd += pcb->mss;
  80cfb8:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80cfbc:	e9 ab 00 00 00       	jmp    80d06c <tcp_receive+0x262>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80cfc1:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80cfc5:	0f af c0             	imul   %eax,%eax
  80cfc8:	0f b7 d9             	movzwl %cx,%ebx
  80cfcb:	99                   	cltd   
  80cfcc:	f7 fb                	idiv   %ebx
  80cfce:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80cfd0:	66 39 c1             	cmp    %ax,%cx
  80cfd3:	0f 83 93 00 00 00    	jae    80d06c <tcp_receive+0x262>
            pcb->cwnd = new_cwnd;
  80cfd9:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80cfdd:	e9 8a 00 00 00       	jmp    80d06c <tcp_receive+0x262>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80cfe2:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80cfe5:	8b 03                	mov    (%ebx),%eax
  80cfe7:	89 47 78             	mov    %eax,0x78(%edi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80cfea:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80cfee:	8b 43 04             	mov    0x4(%ebx),%eax
  80cff1:	89 04 24             	mov    %eax,(%esp)
  80cff4:	e8 71 82 ff ff       	call   80526a <pbuf_clen>
  80cff9:	0f b6 c0             	movzbl %al,%eax
  80cffc:	66 39 c6             	cmp    %ax,%si
  80cfff:	73 1c                	jae    80d01d <tcp_receive+0x213>
  80d001:	c7 44 24 08 bc 41 81 	movl   $0x8141bc,0x8(%esp)
  80d008:	00 
  80d009:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  80d010:	00 
  80d011:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80d018:	e8 1d 20 00 00       	call   80f03a <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80d01d:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d021:	8b 43 04             	mov    0x4(%ebx),%eax
  80d024:	89 04 24             	mov    %eax,(%esp)
  80d027:	e8 3e 82 ff ff       	call   80526a <pbuf_clen>
  80d02c:	0f b6 c0             	movzbl %al,%eax
  80d02f:	29 c6                	sub    %eax,%esi
  80d031:	66 89 77 70          	mov    %si,0x70(%edi)
        tcp_seg_free(next);
  80d035:	89 1c 24             	mov    %ebx,(%esp)
  80d038:	e8 6c 8d ff ff       	call   805da9 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80d03d:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80d042:	74 28                	je     80d06c <tcp_receive+0x262>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80d044:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80d048:	75 22                	jne    80d06c <tcp_receive+0x262>
  80d04a:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80d04e:	75 1c                	jne    80d06c <tcp_receive+0x262>
  80d050:	c7 44 24 08 e4 41 81 	movl   $0x8141e4,0x8(%esp)
  80d057:	00 
  80d058:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  80d05f:	00 
  80d060:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80d067:	e8 ce 1f 00 00       	call   80f03a <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80d06c:	8b 47 78             	mov    0x78(%edi),%eax
  80d06f:	85 c0                	test   %eax,%eax
  80d071:	74 61                	je     80d0d4 <tcp_receive+0x2ca>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80d073:	8b 40 10             	mov    0x10(%eax),%eax
  80d076:	8b 40 04             	mov    0x4(%eax),%eax
  80d079:	89 04 24             	mov    %eax,(%esp)
  80d07c:	e8 19 af ff ff       	call   807f9a <ntohl>
  80d081:	89 c6                	mov    %eax,%esi
  80d083:	8b 47 78             	mov    0x78(%edi),%eax
  80d086:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80d08a:	8b 40 10             	mov    0x10(%eax),%eax
  80d08d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d091:	89 04 24             	mov    %eax,(%esp)
  80d094:	e8 ba ac ff ff       	call   807d53 <ntohs>
  80d099:	ba 01 00 00 00       	mov    $0x1,%edx
  80d09e:	a8 01                	test   $0x1,%al
  80d0a0:	75 1a                	jne    80d0bc <tcp_receive+0x2b2>
  80d0a2:	8b 47 78             	mov    0x78(%edi),%eax
  80d0a5:	8b 40 10             	mov    0x10(%eax),%eax
  80d0a8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d0ac:	89 04 24             	mov    %eax,(%esp)
  80d0af:	e8 9f ac ff ff       	call   807d53 <ntohs>
  80d0b4:	66 d1 e8             	shr    %ax
  80d0b7:	89 c2                	mov    %eax,%edx
  80d0b9:	83 e2 01             	and    $0x1,%edx
  80d0bc:	2b 35 c4 c1 b3 00    	sub    0xb3c1c4,%esi
  80d0c2:	01 d3                	add    %edx,%ebx
  80d0c4:	01 de                	add    %ebx,%esi
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80d0c6:	85 f6                	test   %esi,%esi
  80d0c8:	0f 8e 14 ff ff ff    	jle    80cfe2 <tcp_receive+0x1d8>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80d0ce:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80d0d2:	75 08                	jne    80d0dc <tcp_receive+0x2d2>
        pcb->rtime = -1;
  80d0d4:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80d0da:	eb 06                	jmp    80d0e2 <tcp_receive+0x2d8>
      else
        pcb->rtime = 0;
  80d0dc:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

      pcb->polltmr = 0;
  80d0e2:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80d0e6:	e9 ae 00 00 00       	jmp    80d199 <tcp_receive+0x38f>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80d0eb:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80d0f1:	e9 a3 00 00 00       	jmp    80d199 <tcp_receive+0x38f>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80d0f6:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80d0f9:	8b 03                	mov    (%ebx),%eax
  80d0fb:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80d0fe:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d102:	8b 43 04             	mov    0x4(%ebx),%eax
  80d105:	89 04 24             	mov    %eax,(%esp)
  80d108:	e8 5d 81 ff ff       	call   80526a <pbuf_clen>
  80d10d:	0f b6 c0             	movzbl %al,%eax
  80d110:	66 39 c6             	cmp    %ax,%si
  80d113:	73 1c                	jae    80d131 <tcp_receive+0x327>
  80d115:	c7 44 24 08 bc 41 81 	movl   $0x8141bc,0x8(%esp)
  80d11c:	00 
  80d11d:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  80d124:	00 
  80d125:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80d12c:	e8 09 1f 00 00       	call   80f03a <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80d131:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d135:	8b 43 04             	mov    0x4(%ebx),%eax
  80d138:	89 04 24             	mov    %eax,(%esp)
  80d13b:	e8 2a 81 ff ff       	call   80526a <pbuf_clen>
  80d140:	0f b6 c0             	movzbl %al,%eax
  80d143:	29 c6                	sub    %eax,%esi
  80d145:	66 89 77 70          	mov    %si,0x70(%edi)
      tcp_seg_free(next);
  80d149:	89 1c 24             	mov    %ebx,(%esp)
  80d14c:	e8 58 8c ff ff       	call   805da9 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80d151:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80d156:	74 29                	je     80d181 <tcp_receive+0x377>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80d158:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80d15c:	75 23                	jne    80d181 <tcp_receive+0x377>
  80d15e:	8b 47 74             	mov    0x74(%edi),%eax
  80d161:	85 c0                	test   %eax,%eax
  80d163:	75 23                	jne    80d188 <tcp_receive+0x37e>
  80d165:	c7 44 24 08 e4 41 81 	movl   $0x8141e4,0x8(%esp)
  80d16c:	00 
  80d16d:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  80d174:	00 
  80d175:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80d17c:	e8 b9 1e 00 00       	call   80f03a <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80d181:	8b 47 74             	mov    0x74(%edi),%eax
  80d184:	85 c0                	test   %eax,%eax
  80d186:	74 11                	je     80d199 <tcp_receive+0x38f>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80d188:	8b 40 10             	mov    0x10(%eax),%eax
  80d18b:	8b 40 04             	mov    0x4(%eax),%eax
  80d18e:	89 04 24             	mov    %eax,(%esp)
  80d191:	e8 ca ab ff ff       	call   807d60 <htonl>
  80d196:	89 47 54             	mov    %eax,0x54(%edi)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d199:	8b 47 74             	mov    0x74(%edi),%eax
  80d19c:	85 c0                	test   %eax,%eax
  80d19e:	74 6b                	je     80d20b <tcp_receive+0x401>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d1a0:	8b 35 c4 c1 b3 00    	mov    0xb3c1c4,%esi
  80d1a6:	8b 40 10             	mov    0x10(%eax),%eax
  80d1a9:	8b 40 04             	mov    0x4(%eax),%eax
  80d1ac:	89 04 24             	mov    %eax,(%esp)
  80d1af:	e8 e6 ad ff ff       	call   807f9a <ntohl>
  80d1b4:	89 c3                	mov    %eax,%ebx
  80d1b6:	8b 47 74             	mov    0x74(%edi),%eax
  80d1b9:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
  80d1bd:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80d1c0:	8b 40 10             	mov    0x10(%eax),%eax
  80d1c3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d1c7:	89 04 24             	mov    %eax,(%esp)
  80d1ca:	e8 84 ab ff ff       	call   807d53 <ntohs>
  80d1cf:	ba 01 00 00 00       	mov    $0x1,%edx
  80d1d4:	a8 01                	test   $0x1,%al
  80d1d6:	75 1a                	jne    80d1f2 <tcp_receive+0x3e8>
  80d1d8:	8b 47 74             	mov    0x74(%edi),%eax
  80d1db:	8b 40 10             	mov    0x10(%eax),%eax
  80d1de:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d1e2:	89 04 24             	mov    %eax,(%esp)
  80d1e5:	e8 69 ab ff ff       	call   807d53 <ntohs>
  80d1ea:	66 d1 e8             	shr    %ax
  80d1ed:	89 c2                	mov    %eax,%edx
  80d1ef:	83 e2 01             	and    $0x1,%edx
  80d1f2:	29 de                	sub    %ebx,%esi
  80d1f4:	03 55 e4             	add    -0x1c(%ebp),%edx
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d1f7:	39 d6                	cmp    %edx,%esi
  80d1f9:	78 10                	js     80d20b <tcp_receive+0x401>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d1fb:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80d200:	2b 47 58             	sub    0x58(%edi),%eax
  80d203:	85 c0                	test   %eax,%eax
  80d205:	0f 8e eb fe ff ff    	jle    80d0f6 <tcp_receive+0x2ec>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80d20b:	8b 47 38             	mov    0x38(%edi),%eax
  80d20e:	85 c0                	test   %eax,%eax
  80d210:	74 55                	je     80d267 <tcp_receive+0x45d>
  80d212:	8b 0d c4 c1 b3 00    	mov    0xb3c1c4,%ecx
  80d218:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80d21b:	79 4a                	jns    80d267 <tcp_receive+0x45d>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d21d:	0f b7 57 40          	movzwl 0x40(%edi),%edx
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80d221:	0f b7 0d 60 c2 b3 00 	movzwl 0xb3c260,%ecx
  80d228:	29 c1                	sub    %eax,%ecx
  80d22a:	89 c8                	mov    %ecx,%eax

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d22c:	89 d1                	mov    %edx,%ecx
  80d22e:	66 c1 f9 03          	sar    $0x3,%cx
  80d232:	29 c8                	sub    %ecx,%eax
      pcb->sa += m;
  80d234:	01 c2                	add    %eax,%edx
  80d236:	66 89 57 40          	mov    %dx,0x40(%edi)
      if (m < 0) {
        m = -m;
  80d23a:	89 c1                	mov    %eax,%ecx
  80d23c:	f7 d9                	neg    %ecx
  80d23e:	66 85 c0             	test   %ax,%ax
  80d241:	0f 48 c1             	cmovs  %ecx,%eax
      }
      m = m - (pcb->sv >> 2);
  80d244:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80d248:	89 cb                	mov    %ecx,%ebx
  80d24a:	66 c1 fb 02          	sar    $0x2,%bx
  80d24e:	29 d9                	sub    %ebx,%ecx
      pcb->sv += m;
  80d250:	01 c8                	add    %ecx,%eax
  80d252:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80d256:	66 c1 fa 03          	sar    $0x3,%dx
  80d25a:	01 d0                	add    %edx,%eax
  80d25c:	66 89 47 44          	mov    %ax,0x44(%edi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80d260:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80d267:	0f b7 1d be c1 b3 00 	movzwl 0xb3c1be,%ebx
  80d26e:	66 85 db             	test   %bx,%bx
  80d271:	0f 84 5b 07 00 00    	je     80d9d2 <tcp_receive+0xbc8>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80d277:	8b 57 24             	mov    0x24(%edi),%edx
  80d27a:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80d27f:	89 d1                	mov    %edx,%ecx
  80d281:	29 c1                	sub    %eax,%ecx
  80d283:	89 ce                	mov    %ecx,%esi
  80d285:	83 ee 01             	sub    $0x1,%esi
  80d288:	0f 88 41 01 00 00    	js     80d3cf <tcp_receive+0x5c5>
  80d28e:	8d 72 01             	lea    0x1(%edx),%esi
  80d291:	29 c6                	sub    %eax,%esi
  80d293:	0f b7 db             	movzwl %bx,%ebx
  80d296:	29 de                	sub    %ebx,%esi
  80d298:	85 f6                	test   %esi,%esi
  80d29a:	0f 8f 2f 01 00 00    	jg     80d3cf <tcp_receive+0x5c5>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80d2a0:	89 ca                	mov    %ecx,%edx
      p = inseg.p;
  80d2a2:	8b 1d d8 c1 b3 00    	mov    0xb3c1d8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80d2a8:	85 db                	test   %ebx,%ebx
  80d2aa:	75 1c                	jne    80d2c8 <tcp_receive+0x4be>
  80d2ac:	c7 44 24 08 3f 43 81 	movl   $0x81433f,0x8(%esp)
  80d2b3:	00 
  80d2b4:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  80d2bb:	00 
  80d2bc:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80d2c3:	e8 72 1d 00 00       	call   80f03a <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80d2c8:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80d2ce:	7e 1c                	jle    80d2ec <tcp_receive+0x4e2>
  80d2d0:	c7 44 24 08 4f 43 81 	movl   $0x81434f,0x8(%esp)
  80d2d7:	00 
  80d2d8:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  80d2df:	00 
  80d2e0:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80d2e7:	e8 4e 1d 00 00       	call   80f03a <_panic>
      if (inseg.p->len < off) {
  80d2ec:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d2f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d2f3:	39 c1                	cmp    %eax,%ecx
  80d2f5:	7e 75                	jle    80d36c <tcp_receive+0x562>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80d2f7:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80d2fb:	0f b7 c6             	movzwl %si,%eax
  80d2fe:	39 c1                	cmp    %eax,%ecx
  80d300:	7e 1c                	jle    80d31e <tcp_receive+0x514>
  80d302:	c7 44 24 08 5e 43 81 	movl   $0x81435e,0x8(%esp)
  80d309:	00 
  80d30a:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  80d311:	00 
  80d312:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80d319:	e8 1c 1d 00 00       	call   80f03a <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80d31e:	29 ce                	sub    %ecx,%esi
  80d320:	89 f1                	mov    %esi,%ecx
  80d322:	8b 45 e4             	mov    -0x1c(%ebp),%eax
        while (p->len < off) {
          off -= p->len;
  80d325:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80d327:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80d32b:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80d331:	8b 1b                	mov    (%ebx),%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80d333:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d337:	39 d0                	cmp    %edx,%eax
  80d339:	7c ea                	jl     80d325 <tcp_receive+0x51b>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80d33b:	f7 da                	neg    %edx
  80d33d:	0f bf c2             	movswl %dx,%eax
  80d340:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d344:	89 1c 24             	mov    %ebx,(%esp)
  80d347:	e8 a4 79 ff ff       	call   804cf0 <pbuf_header>
  80d34c:	84 c0                	test   %al,%al
  80d34e:	74 4d                	je     80d39d <tcp_receive+0x593>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d350:	c7 44 24 08 6e 43 81 	movl   $0x81436e,0x8(%esp)
  80d357:	00 
  80d358:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  80d35f:	00 
  80d360:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80d367:	e8 ce 1c 00 00       	call   80f03a <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80d36c:	f7 d9                	neg    %ecx
  80d36e:	0f bf c1             	movswl %cx,%eax
  80d371:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d375:	89 1c 24             	mov    %ebx,(%esp)
  80d378:	e8 73 79 ff ff       	call   804cf0 <pbuf_header>
  80d37d:	84 c0                	test   %al,%al
  80d37f:	74 1c                	je     80d39d <tcp_receive+0x593>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d381:	c7 44 24 08 6e 43 81 	movl   $0x81436e,0x8(%esp)
  80d388:	00 
  80d389:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  80d390:	00 
  80d391:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80d398:	e8 9d 1c 00 00       	call   80f03a <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80d39d:	8b 43 04             	mov    0x4(%ebx),%eax
  80d3a0:	a3 dc c1 b3 00       	mov    %eax,0xb3c1dc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80d3a5:	8b 47 24             	mov    0x24(%edi),%eax
  80d3a8:	0f b7 15 e0 c1 b3 00 	movzwl 0xb3c1e0,%edx
  80d3af:	66 03 15 c8 c1 b3 00 	add    0xb3c1c8,%dx
  80d3b6:	29 c2                	sub    %eax,%edx
  80d3b8:	66 89 15 e0 c1 b3 00 	mov    %dx,0xb3c1e0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80d3bf:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
  80d3c4:	8b 15 e4 c1 b3 00    	mov    0xb3c1e4,%edx
  80d3ca:	89 42 04             	mov    %eax,0x4(%edx)
  80d3cd:	eb 10                	jmp    80d3df <tcp_receive+0x5d5>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80d3cf:	39 d0                	cmp    %edx,%eax
  80d3d1:	79 1c                	jns    80d3ef <tcp_receive+0x5e5>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80d3d3:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d3d7:	89 3c 24             	mov    %edi,(%esp)
  80d3da:	e8 52 b3 ff ff       	call   808731 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d3df:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80d3e4:	8b 57 24             	mov    0x24(%edi),%edx
  80d3e7:	39 d0                	cmp    %edx,%eax
  80d3e9:	0f 88 d0 05 00 00    	js     80d9bf <tcp_receive+0xbb5>
  80d3ef:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
  80d3f3:	89 c3                	mov    %eax,%ebx
  80d3f5:	29 cb                	sub    %ecx,%ebx
  80d3f7:	8d 4b 01             	lea    0x1(%ebx),%ecx
  80d3fa:	29 d1                	sub    %edx,%ecx
  80d3fc:	85 c9                	test   %ecx,%ecx
  80d3fe:	0f 8f bb 05 00 00    	jg     80d9bf <tcp_receive+0xbb5>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80d404:	39 d0                	cmp    %edx,%eax
  80d406:	0f 85 53 03 00 00    	jne    80d75f <tcp_receive+0x955>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d40c:	8b 57 7c             	mov    0x7c(%edi),%edx
  80d40f:	85 d2                	test   %edx,%edx
  80d411:	0f 84 83 00 00 00    	je     80d49a <tcp_receive+0x690>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80d417:	8b 4a 10             	mov    0x10(%edx),%ecx
  80d41a:	8b 49 04             	mov    0x4(%ecx),%ecx
  80d41d:	0f b7 1d e0 c1 b3 00 	movzwl 0xb3c1e0,%ebx
  80d424:	89 ce                	mov    %ecx,%esi
  80d426:	29 de                	sub    %ebx,%esi
  80d428:	89 f3                	mov    %esi,%ebx
  80d42a:	29 c3                	sub    %eax,%ebx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d42c:	85 db                	test   %ebx,%ebx
  80d42e:	7f 6a                	jg     80d49a <tcp_receive+0x690>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80d430:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  80d435:	74 1f                	je     80d456 <tcp_receive+0x64c>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80d437:	29 c1                	sub    %eax,%ecx
  80d439:	66 89 0d e0 c1 b3 00 	mov    %cx,0xb3c1e0
            pbuf_realloc(inseg.p, inseg.len);
  80d440:	0f b7 c9             	movzwl %cx,%ecx
  80d443:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80d447:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d44c:	89 04 24             	mov    %eax,(%esp)
  80d44f:	e8 f2 7c ff ff       	call   805146 <pbuf_realloc>
  80d454:	eb 44                	jmp    80d49a <tcp_receive+0x690>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d456:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d45b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d45f:	89 04 24             	mov    %eax,(%esp)
  80d462:	e8 ec a8 ff ff       	call   807d53 <ntohs>
  80d467:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80d469:	8b 47 7c             	mov    0x7c(%edi),%eax
  80d46c:	8b 40 10             	mov    0x10(%eax),%eax
  80d46f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d473:	89 04 24             	mov    %eax,(%esp)
  80d476:	e8 d8 a8 ff ff       	call   807d53 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d47b:	31 c3                	xor    %eax,%ebx
  80d47d:	f6 c3 03             	test   $0x3,%bl
  80d480:	75 18                	jne    80d49a <tcp_receive+0x690>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80d482:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80d485:	8b 10                	mov    (%eax),%edx
  80d487:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80d48a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d48e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80d495:	e8 88 75 ff ff       	call   804a22 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80d49a:	0f b7 1d e0 c1 b3 00 	movzwl 0xb3c1e0,%ebx
  80d4a1:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d4a6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4aa:	89 04 24             	mov    %eax,(%esp)
  80d4ad:	e8 a1 a8 ff ff       	call   807d53 <ntohs>
  80d4b2:	ba 01 00 00 00       	mov    $0x1,%edx
  80d4b7:	a8 01                	test   $0x1,%al
  80d4b9:	75 19                	jne    80d4d4 <tcp_receive+0x6ca>
  80d4bb:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d4c0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4c4:	89 04 24             	mov    %eax,(%esp)
  80d4c7:	e8 87 a8 ff ff       	call   807d53 <ntohs>
  80d4cc:	66 d1 e8             	shr    %ax
  80d4cf:	89 c2                	mov    %eax,%edx
  80d4d1:	83 e2 01             	and    $0x1,%edx
  80d4d4:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80d4d7:	66 a3 be c1 b3 00    	mov    %ax,0xb3c1be

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80d4dd:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80d4e1:	74 06                	je     80d4e9 <tcp_receive+0x6df>
          pcb->rcv_nxt += tcplen;
  80d4e3:	0f b7 d0             	movzwl %ax,%edx
  80d4e6:	01 57 24             	add    %edx,0x24(%edi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80d4e9:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80d4ed:	66 39 d0             	cmp    %dx,%ax
  80d4f0:	76 08                	jbe    80d4fa <tcp_receive+0x6f0>
          pcb->rcv_wnd = 0;
  80d4f2:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80d4f8:	eb 06                	jmp    80d500 <tcp_receive+0x6f6>
        } else {
          pcb->rcv_wnd -= tcplen;
  80d4fa:	29 c2                	sub    %eax,%edx
  80d4fc:	66 89 57 28          	mov    %dx,0x28(%edi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80d500:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  80d504:	66 39 d0             	cmp    %dx,%ax
  80d507:	76 08                	jbe    80d511 <tcp_receive+0x707>
          pcb->rcv_ann_wnd = 0;
  80d509:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80d50f:	eb 06                	jmp    80d517 <tcp_receive+0x70d>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80d511:	29 c2                	sub    %eax,%edx
  80d513:	66 89 57 2a          	mov    %dx,0x2a(%edi)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80d517:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d51c:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d521:	74 0f                	je     80d532 <tcp_receive+0x728>
          recv_data = inseg.p;
  80d523:	a3 b8 c1 b3 00       	mov    %eax,0xb3c1b8
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80d528:	c7 05 d8 c1 b3 00 00 	movl   $0x0,0xb3c1d8
  80d52f:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80d532:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d537:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d53b:	89 04 24             	mov    %eax,(%esp)
  80d53e:	e8 10 a8 ff ff       	call   807d53 <ntohs>
  80d543:	a8 01                	test   $0x1,%al
  80d545:	0f 84 cb 01 00 00    	je     80d716 <tcp_receive+0x90c>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80d54b:	c6 05 bc c1 b3 00 20 	movb   $0x20,0xb3c1bc
  80d552:	e9 bf 01 00 00       	jmp    80d716 <tcp_receive+0x90c>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80d557:	89 35 c8 c1 b3 00    	mov    %esi,0xb3c1c8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80d55d:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d561:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80d564:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d568:	89 04 24             	mov    %eax,(%esp)
  80d56b:	e8 e3 a7 ff ff       	call   807d53 <ntohs>
  80d570:	ba 01 00 00 00       	mov    $0x1,%edx
  80d575:	a8 01                	test   $0x1,%al
  80d577:	75 17                	jne    80d590 <tcp_receive+0x786>
  80d579:	8b 43 10             	mov    0x10(%ebx),%eax
  80d57c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d580:	89 04 24             	mov    %eax,(%esp)
  80d583:	e8 cb a7 ff ff       	call   807d53 <ntohs>
  80d588:	66 d1 e8             	shr    %ax
  80d58b:	89 c2                	mov    %eax,%edx
  80d58d:	83 e2 01             	and    $0x1,%edx
  80d590:	03 55 e4             	add    -0x1c(%ebp),%edx
  80d593:	01 d6                	add    %edx,%esi
  80d595:	89 77 24             	mov    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80d598:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80d59c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d59f:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d5a3:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5a6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5aa:	89 04 24             	mov    %eax,(%esp)
  80d5ad:	e8 a1 a7 ff ff       	call   807d53 <ntohs>
  80d5b2:	ba 01 00 00 00       	mov    $0x1,%edx
  80d5b7:	a8 01                	test   $0x1,%al
  80d5b9:	75 17                	jne    80d5d2 <tcp_receive+0x7c8>
  80d5bb:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5be:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5c2:	89 04 24             	mov    %eax,(%esp)
  80d5c5:	e8 89 a7 ff ff       	call   807d53 <ntohs>
  80d5ca:	66 d1 e8             	shr    %ax
  80d5cd:	89 c2                	mov    %eax,%edx
  80d5cf:	83 e2 01             	and    $0x1,%edx
  80d5d2:	01 d6                	add    %edx,%esi
  80d5d4:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d5d7:	7d 08                	jge    80d5e1 <tcp_receive+0x7d7>
            pcb->rcv_wnd = 0;
  80d5d9:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80d5df:	eb 45                	jmp    80d626 <tcp_receive+0x81c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80d5e1:	0f b7 77 28          	movzwl 0x28(%edi),%esi
  80d5e5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d5e9:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d5ed:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5f0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5f4:	89 04 24             	mov    %eax,(%esp)
  80d5f7:	e8 57 a7 ff ff       	call   807d53 <ntohs>
  80d5fc:	ba 01 00 00 00       	mov    $0x1,%edx
  80d601:	a8 01                	test   $0x1,%al
  80d603:	75 17                	jne    80d61c <tcp_receive+0x812>
  80d605:	8b 43 10             	mov    0x10(%ebx),%eax
  80d608:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d60c:	89 04 24             	mov    %eax,(%esp)
  80d60f:	e8 3f a7 ff ff       	call   807d53 <ntohs>
  80d614:	66 d1 e8             	shr    %ax
  80d617:	89 c2                	mov    %eax,%edx
  80d619:	83 e2 01             	and    $0x1,%edx
  80d61c:	66 2b 75 e4          	sub    -0x1c(%ebp),%si
  80d620:	29 d6                	sub    %edx,%esi
  80d622:	66 89 77 28          	mov    %si,0x28(%edi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80d626:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80d62a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d62d:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d631:	8b 43 10             	mov    0x10(%ebx),%eax
  80d634:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d638:	89 04 24             	mov    %eax,(%esp)
  80d63b:	e8 13 a7 ff ff       	call   807d53 <ntohs>
  80d640:	ba 01 00 00 00       	mov    $0x1,%edx
  80d645:	a8 01                	test   $0x1,%al
  80d647:	75 17                	jne    80d660 <tcp_receive+0x856>
  80d649:	8b 43 10             	mov    0x10(%ebx),%eax
  80d64c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d650:	89 04 24             	mov    %eax,(%esp)
  80d653:	e8 fb a6 ff ff       	call   807d53 <ntohs>
  80d658:	66 d1 e8             	shr    %ax
  80d65b:	89 c2                	mov    %eax,%edx
  80d65d:	83 e2 01             	and    $0x1,%edx
  80d660:	01 d6                	add    %edx,%esi
  80d662:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d665:	7d 08                	jge    80d66f <tcp_receive+0x865>
            pcb->rcv_ann_wnd = 0;
  80d667:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80d66d:	eb 45                	jmp    80d6b4 <tcp_receive+0x8aa>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80d66f:	0f b7 77 2a          	movzwl 0x2a(%edi),%esi
  80d673:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d677:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d67b:	8b 43 10             	mov    0x10(%ebx),%eax
  80d67e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d682:	89 04 24             	mov    %eax,(%esp)
  80d685:	e8 c9 a6 ff ff       	call   807d53 <ntohs>
  80d68a:	ba 01 00 00 00       	mov    $0x1,%edx
  80d68f:	a8 01                	test   $0x1,%al
  80d691:	75 17                	jne    80d6aa <tcp_receive+0x8a0>
  80d693:	8b 43 10             	mov    0x10(%ebx),%eax
  80d696:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d69a:	89 04 24             	mov    %eax,(%esp)
  80d69d:	e8 b1 a6 ff ff       	call   807d53 <ntohs>
  80d6a2:	66 d1 e8             	shr    %ax
  80d6a5:	89 c2                	mov    %eax,%edx
  80d6a7:	83 e2 01             	and    $0x1,%edx
  80d6aa:	66 2b 75 e4          	sub    -0x1c(%ebp),%si
  80d6ae:	29 d6                	sub    %edx,%esi
  80d6b0:	66 89 77 2a          	mov    %si,0x2a(%edi)
          }

          if (cseg->p->tot_len > 0) {
  80d6b4:	8b 43 04             	mov    0x4(%ebx),%eax
  80d6b7:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d6bc:	74 24                	je     80d6e2 <tcp_receive+0x8d8>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80d6be:	8b 15 b8 c1 b3 00    	mov    0xb3c1b8,%edx
  80d6c4:	85 d2                	test   %edx,%edx
  80d6c6:	74 0e                	je     80d6d6 <tcp_receive+0x8cc>
              pbuf_cat(recv_data, cseg->p);
  80d6c8:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d6cc:	89 14 24             	mov    %edx,(%esp)
  80d6cf:	e8 bf 7b ff ff       	call   805293 <pbuf_cat>
  80d6d4:	eb 05                	jmp    80d6db <tcp_receive+0x8d1>
            } else {
              recv_data = cseg->p;
  80d6d6:	a3 b8 c1 b3 00       	mov    %eax,0xb3c1b8
            }
            cseg->p = NULL;
  80d6db:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80d6e2:	8b 43 10             	mov    0x10(%ebx),%eax
  80d6e5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d6e9:	89 04 24             	mov    %eax,(%esp)
  80d6ec:	e8 62 a6 ff ff       	call   807d53 <ntohs>
  80d6f1:	a8 01                	test   $0x1,%al
  80d6f3:	74 14                	je     80d709 <tcp_receive+0x8ff>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80d6f5:	c6 05 bc c1 b3 00 20 	movb   $0x20,0xb3c1bc
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80d6fc:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80d700:	75 07                	jne    80d709 <tcp_receive+0x8ff>
              pcb->state = CLOSE_WAIT;
  80d702:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
            } 
          }


          pcb->ooseq = cseg->next;
  80d709:	8b 03                	mov    (%ebx),%eax
  80d70b:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80d70e:	89 1c 24             	mov    %ebx,(%esp)
  80d711:	e8 93 86 ff ff       	call   805da9 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d716:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d719:	85 db                	test   %ebx,%ebx
  80d71b:	74 0f                	je     80d72c <tcp_receive+0x922>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80d71d:	8b 43 10             	mov    0x10(%ebx),%eax
  80d720:	8b 70 04             	mov    0x4(%eax),%esi
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d723:	3b 77 24             	cmp    0x24(%edi),%esi
  80d726:	0f 84 2b fe ff ff    	je     80d557 <tcp_receive+0x74d>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d72c:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80d730:	a8 01                	test   $0x1,%al
  80d732:	74 1b                	je     80d74f <tcp_receive+0x945>
  80d734:	83 e0 fe             	and    $0xfffffffe,%eax
  80d737:	83 c8 02             	or     $0x2,%eax
  80d73a:	88 47 20             	mov    %al,0x20(%edi)
  80d73d:	89 3c 24             	mov    %edi,(%esp)
  80d740:	e8 ec af ff ff       	call   808731 <tcp_output>
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d745:	b8 01 00 00 00       	mov    $0x1,%eax
  80d74a:	e9 e1 02 00 00       	jmp    80da30 <tcp_receive+0xc26>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d74f:	83 c8 01             	or     $0x1,%eax
  80d752:	88 47 20             	mov    %al,0x20(%edi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d755:	b8 01 00 00 00       	mov    $0x1,%eax
  80d75a:	e9 d1 02 00 00       	jmp    80da30 <tcp_receive+0xc26>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80d75f:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d763:	89 3c 24             	mov    %edi,(%esp)
  80d766:	e8 c6 af ff ff       	call   808731 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80d76b:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d76e:	85 db                	test   %ebx,%ebx
  80d770:	75 19                	jne    80d78b <tcp_receive+0x981>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80d772:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d779:	e8 ab 86 ff ff       	call   805e29 <tcp_seg_copy>
  80d77e:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d781:	b8 00 00 00 00       	mov    $0x0,%eax
  80d786:	e9 a5 02 00 00       	jmp    80da30 <tcp_receive+0xc26>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d78b:	8b 0d c8 c1 b3 00    	mov    0xb3c1c8,%ecx
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d791:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80d794:	8d 51 01             	lea    0x1(%ecx),%edx
  80d797:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80d79a:	be 00 00 00 00       	mov    $0x0,%esi
  80d79f:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80d7a2:	89 c7                	mov    %eax,%edi
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d7a4:	8b 43 10             	mov    0x10(%ebx),%eax
  80d7a7:	8b 40 04             	mov    0x4(%eax),%eax
  80d7aa:	39 c8                	cmp    %ecx,%eax
  80d7ac:	0f 85 9e 00 00 00    	jne    80d850 <tcp_receive+0xa46>
  80d7b2:	8b 7d e0             	mov    -0x20(%ebp),%edi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d7b5:	b8 00 00 00 00       	mov    $0x0,%eax
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80d7ba:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d7be:	66 39 0d e0 c1 b3 00 	cmp    %cx,0xb3c1e0
  80d7c5:	0f 86 65 02 00 00    	jbe    80da30 <tcp_receive+0xc26>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80d7cb:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d7d2:	e8 52 86 ff ff       	call   805e29 <tcp_seg_copy>
  80d7d7:	89 c1                	mov    %eax,%ecx
  80d7d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80d7dc:	85 c0                	test   %eax,%eax
  80d7de:	0f 84 1d 02 00 00    	je     80da01 <tcp_receive+0xbf7>
                  cseg->next = next->next;
  80d7e4:	8b 03                	mov    (%ebx),%eax
  80d7e6:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80d7e8:	85 f6                	test   %esi,%esi
  80d7ea:	74 04                	je     80d7f0 <tcp_receive+0x9e6>
                    prev->next = cseg;
  80d7ec:	89 0e                	mov    %ecx,(%esi)
  80d7ee:	eb 06                	jmp    80d7f6 <tcp_receive+0x9ec>
                  } else {
                    pcb->ooseq = cseg;
  80d7f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d7f3:	89 47 7c             	mov    %eax,0x7c(%edi)
                  }
                  tcp_seg_free(next);
  80d7f6:	89 1c 24             	mov    %ebx,(%esp)
  80d7f9:	e8 ab 85 ff ff       	call   805da9 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d7fe:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80d801:	8b 06                	mov    (%esi),%eax
  80d803:	85 c0                	test   %eax,%eax
  80d805:	0f 84 fd 01 00 00    	je     80da08 <tcp_receive+0xbfe>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d80b:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80d811:	8b 40 10             	mov    0x10(%eax),%eax
  80d814:	8b 48 04             	mov    0x4(%eax),%ecx
  80d817:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80d81b:	29 cb                	sub    %ecx,%ebx
  80d81d:	01 d3                	add    %edx,%ebx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d81f:	b8 00 00 00 00       	mov    $0x0,%eax
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d824:	85 db                	test   %ebx,%ebx
  80d826:	0f 8e 04 02 00 00    	jle    80da30 <tcp_receive+0xc26>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d82c:	89 c8                	mov    %ecx,%eax
  80d82e:	29 d0                	sub    %edx,%eax
  80d830:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80d834:	0f b7 c0             	movzwl %ax,%eax
  80d837:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d83b:	8b 46 04             	mov    0x4(%esi),%eax
  80d83e:	89 04 24             	mov    %eax,(%esp)
  80d841:	e8 00 79 ff ff       	call   805146 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d846:	b8 00 00 00 00       	mov    $0x0,%eax
  80d84b:	e9 e0 01 00 00       	jmp    80da30 <tcp_receive+0xc26>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80d850:	85 f6                	test   %esi,%esi
  80d852:	75 59                	jne    80d8ad <tcp_receive+0xaa3>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d854:	39 c1                	cmp    %eax,%ecx
  80d856:	0f 89 f2 00 00 00    	jns    80d94e <tcp_receive+0xb44>
  80d85c:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d85f:	0f b7 15 e0 c1 b3 00 	movzwl 0xb3c1e0,%edx
  80d866:	01 ca                	add    %ecx,%edx
  80d868:	29 c2                	sub    %eax,%edx
  80d86a:	85 d2                	test   %edx,%edx
  80d86c:	7e 1c                	jle    80d88a <tcp_receive+0xa80>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d86e:	29 c8                	sub    %ecx,%eax
  80d870:	66 a3 e0 c1 b3 00    	mov    %ax,0xb3c1e0
                    pbuf_realloc(inseg.p, inseg.len);
  80d876:	0f b7 c0             	movzwl %ax,%eax
  80d879:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d87d:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d882:	89 04 24             	mov    %eax,(%esp)
  80d885:	e8 bc 78 ff ff       	call   805146 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  80d88a:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d891:	e8 93 85 ff ff       	call   805e29 <tcp_seg_copy>
                  if (cseg != NULL) {
  80d896:	85 c0                	test   %eax,%eax
  80d898:	0f 84 71 01 00 00    	je     80da0f <tcp_receive+0xc05>
                    cseg->next = next;
  80d89e:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80d8a0:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d8a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8a8:	e9 83 01 00 00       	jmp    80da30 <tcp_receive+0xc26>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d8ad:	8b 56 10             	mov    0x10(%esi),%edx
  80d8b0:	3b 7a 04             	cmp    0x4(%edx),%edi
  80d8b3:	0f 88 95 00 00 00    	js     80d94e <tcp_receive+0xb44>
  80d8b9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d8bc:	29 c2                	sub    %eax,%edx
  80d8be:	85 d2                	test   %edx,%edx
  80d8c0:	0f 8f 88 00 00 00    	jg     80d94e <tcp_receive+0xb44>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d8c6:	0f b7 15 e0 c1 b3 00 	movzwl 0xb3c1e0,%edx
  80d8cd:	01 ca                	add    %ecx,%edx
  80d8cf:	29 c2                	sub    %eax,%edx
  80d8d1:	85 d2                	test   %edx,%edx
  80d8d3:	7e 1c                	jle    80d8f1 <tcp_receive+0xae7>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d8d5:	29 c8                	sub    %ecx,%eax
  80d8d7:	66 a3 e0 c1 b3 00    	mov    %ax,0xb3c1e0
                  pbuf_realloc(inseg.p, inseg.len);
  80d8dd:	0f b7 c0             	movzwl %ax,%eax
  80d8e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d8e4:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d8e9:	89 04 24             	mov    %eax,(%esp)
  80d8ec:	e8 55 78 ff ff       	call   805146 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  80d8f1:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d8f8:	e8 2c 85 ff ff       	call   805e29 <tcp_seg_copy>
                if (cseg != NULL) {
  80d8fd:	85 c0                	test   %eax,%eax
  80d8ff:	0f 84 11 01 00 00    	je     80da16 <tcp_receive+0xc0c>
                  cseg->next = next;
  80d905:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80d907:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d909:	8b 46 10             	mov    0x10(%esi),%eax
  80d90c:	8b 50 04             	mov    0x4(%eax),%edx
  80d90f:	8b 0d c8 c1 b3 00    	mov    0xb3c1c8,%ecx
  80d915:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80d919:	29 cb                	sub    %ecx,%ebx
  80d91b:	01 d3                	add    %edx,%ebx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d91d:	b8 00 00 00 00       	mov    $0x0,%eax

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  cseg->next = next;
                  prev->next = cseg;
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d922:	85 db                	test   %ebx,%ebx
  80d924:	0f 8e 06 01 00 00    	jle    80da30 <tcp_receive+0xc26>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d92a:	89 c8                	mov    %ecx,%eax
  80d92c:	29 d0                	sub    %edx,%eax
  80d92e:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80d932:	0f b7 c0             	movzwl %ax,%eax
  80d935:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d939:	8b 46 04             	mov    0x4(%esi),%eax
  80d93c:	89 04 24             	mov    %eax,(%esp)
  80d93f:	e8 02 78 ff ff       	call   805146 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d944:	b8 00 00 00 00       	mov    $0x0,%eax
  80d949:	e9 e2 00 00 00       	jmp    80da30 <tcp_receive+0xc26>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d94e:	8b 13                	mov    (%ebx),%edx
  80d950:	85 d2                	test   %edx,%edx
  80d952:	75 62                	jne    80d9b6 <tcp_receive+0xbac>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d954:	29 c1                	sub    %eax,%ecx
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d956:	85 c9                	test   %ecx,%ecx
  80d958:	0f 8e bf 00 00 00    	jle    80da1d <tcp_receive+0xc13>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80d95e:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d965:	e8 bf 84 ff ff       	call   805e29 <tcp_seg_copy>
  80d96a:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d96c:	85 c0                	test   %eax,%eax
  80d96e:	0f 84 b0 00 00 00    	je     80da24 <tcp_receive+0xc1a>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d974:	8b 43 10             	mov    0x10(%ebx),%eax
  80d977:	8b 50 04             	mov    0x4(%eax),%edx
  80d97a:	8b 0d c8 c1 b3 00    	mov    0xb3c1c8,%ecx
  80d980:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d984:	29 ce                	sub    %ecx,%esi
  80d986:	01 d6                	add    %edx,%esi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d988:	b8 00 00 00 00       	mov    $0x0,%eax
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d98d:	85 f6                	test   %esi,%esi
  80d98f:	0f 8e 9b 00 00 00    	jle    80da30 <tcp_receive+0xc26>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d995:	89 c8                	mov    %ecx,%eax
  80d997:	29 d0                	sub    %edx,%eax
  80d999:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d99d:	0f b7 c0             	movzwl %ax,%eax
  80d9a0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d9a4:	8b 43 04             	mov    0x4(%ebx),%eax
  80d9a7:	89 04 24             	mov    %eax,(%esp)
  80d9aa:	e8 97 77 ff ff       	call   805146 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d9af:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9b4:	eb 7a                	jmp    80da30 <tcp_receive+0xc26>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d9b6:	89 de                	mov    %ebx,%esi
  80d9b8:	89 d3                	mov    %edx,%ebx
  80d9ba:	e9 e5 fd ff ff       	jmp    80d7a4 <tcp_receive+0x99a>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80d9bf:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d9c3:	89 3c 24             	mov    %edi,(%esp)
  80d9c6:	e8 66 ad ff ff       	call   808731 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d9cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9d0:	eb 5e                	jmp    80da30 <tcp_receive+0xc26>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d9d2:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80d9d8:	8b 47 24             	mov    0x24(%edi),%eax
  80d9db:	39 c2                	cmp    %eax,%edx
  80d9dd:	78 0f                	js     80d9ee <tcp_receive+0xbe4>
  80d9df:	83 c2 01             	add    $0x1,%edx
  80d9e2:	29 c2                	sub    %eax,%edx
  80d9e4:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80d9e8:	29 c2                	sub    %eax,%edx
  80d9ea:	85 d2                	test   %edx,%edx
  80d9ec:	7e 3d                	jle    80da2b <tcp_receive+0xc21>
      tcp_ack_now(pcb);
  80d9ee:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d9f2:	89 3c 24             	mov    %edi,(%esp)
  80d9f5:	e8 37 ad ff ff       	call   808731 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d9fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9ff:	eb 2f                	jmp    80da30 <tcp_receive+0xc26>
  80da01:	b8 00 00 00 00       	mov    $0x0,%eax
  80da06:	eb 28                	jmp    80da30 <tcp_receive+0xc26>
  80da08:	b8 00 00 00 00       	mov    $0x0,%eax
  80da0d:	eb 21                	jmp    80da30 <tcp_receive+0xc26>
  80da0f:	b8 00 00 00 00       	mov    $0x0,%eax
  80da14:	eb 1a                	jmp    80da30 <tcp_receive+0xc26>
  80da16:	b8 00 00 00 00       	mov    $0x0,%eax
  80da1b:	eb 13                	jmp    80da30 <tcp_receive+0xc26>
  80da1d:	b8 00 00 00 00       	mov    $0x0,%eax
  80da22:	eb 0c                	jmp    80da30 <tcp_receive+0xc26>
  80da24:	b8 00 00 00 00       	mov    $0x0,%eax
  80da29:	eb 05                	jmp    80da30 <tcp_receive+0xc26>
  80da2b:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80da30:	83 c4 2c             	add    $0x2c,%esp
  80da33:	5b                   	pop    %ebx
  80da34:	5e                   	pop    %esi
  80da35:	5f                   	pop    %edi
  80da36:	5d                   	pop    %ebp
  80da37:	c3                   	ret    

0080da38 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80da38:	55                   	push   %ebp
  80da39:	89 e5                	mov    %esp,%ebp
  80da3b:	57                   	push   %edi
  80da3c:	56                   	push   %esi
  80da3d:	53                   	push   %ebx
  80da3e:	83 ec 4c             	sub    $0x4c,%esp
  80da41:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80da44:	8b 5e 04             	mov    0x4(%esi),%ebx
  80da47:	89 1d cc c1 b3 00    	mov    %ebx,0xb3c1cc
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80da4d:	0f b7 03             	movzwl (%ebx),%eax
  80da50:	89 04 24             	mov    %eax,(%esp)
  80da53:	e8 fb a2 ff ff       	call   807d53 <ntohs>
  80da58:	66 c1 e8 08          	shr    $0x8,%ax
  80da5c:	83 e0 0f             	and    $0xf,%eax
  80da5f:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80da62:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80da67:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80da6c:	0f b7 00             	movzwl (%eax),%eax
  80da6f:	89 04 24             	mov    %eax,(%esp)
  80da72:	e8 dc a2 ff ff       	call   807d53 <ntohs>
  80da77:	66 c1 e8 06          	shr    $0x6,%ax
  80da7b:	83 e0 3c             	and    $0x3c,%eax
  80da7e:	f7 d8                	neg    %eax
  80da80:	98                   	cwtl   
  80da81:	89 44 24 04          	mov    %eax,0x4(%esp)
  80da85:	89 34 24             	mov    %esi,(%esp)
  80da88:	e8 63 72 ff ff       	call   804cf0 <pbuf_header>
  80da8d:	84 c0                	test   %al,%al
  80da8f:	75 07                	jne    80da98 <tcp_input+0x60>
  80da91:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80da96:	77 0d                	ja     80daa5 <tcp_input+0x6d>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80da98:	89 34 24             	mov    %esi,(%esp)
  80da9b:	e8 34 73 ff ff       	call   804dd4 <pbuf_free>
    return;
  80daa0:	e9 cc 0c 00 00       	jmp    80e771 <tcp_input+0xd39>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80daa5:	8b 45 0c             	mov    0xc(%ebp),%eax
  80daa8:	89 44 24 04          	mov    %eax,0x4(%esp)
  80daac:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80dab1:	83 c0 10             	add    $0x10,%eax
  80dab4:	89 04 24             	mov    %eax,(%esp)
  80dab7:	e8 b5 8f ff ff       	call   806a71 <ip_addr_isbroadcast>
  80dabc:	84 c0                	test   %al,%al
  80dabe:	75 26                	jne    80dae6 <tcp_input+0xae>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80dac0:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80dac5:	8b 58 10             	mov    0x10(%eax),%ebx
  80dac8:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80dacf:	e8 c6 a4 ff ff       	call   807f9a <ntohl>
  80dad4:	21 c3                	and    %eax,%ebx
  80dad6:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80dadd:	e8 b8 a4 ff ff       	call   807f9a <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80dae2:	39 c3                	cmp    %eax,%ebx
  80dae4:	75 0f                	jne    80daf5 <tcp_input+0xbd>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80dae6:	89 34 24             	mov    %esi,(%esp)
  80dae9:	e8 e6 72 ff ff       	call   804dd4 <pbuf_free>
    return;
  80daee:	66 90                	xchg   %ax,%ax
  80daf0:	e9 7c 0c 00 00       	jmp    80e771 <tcp_input+0xd39>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80daf5:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80dafa:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80dafe:	89 54 24 10          	mov    %edx,0x10(%esp)
  80db02:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80db09:	00 
  80db0a:	8d 50 10             	lea    0x10(%eax),%edx
  80db0d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80db11:	83 c0 0c             	add    $0xc,%eax
  80db14:	89 44 24 04          	mov    %eax,0x4(%esp)
  80db18:	89 34 24             	mov    %esi,(%esp)
  80db1b:	e8 e5 9e ff ff       	call   807a05 <inet_chksum_pseudo>
  80db20:	66 85 c0             	test   %ax,%ax
  80db23:	74 0d                	je     80db32 <tcp_input+0xfa>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80db25:	89 34 24             	mov    %esi,(%esp)
  80db28:	e8 a7 72 ff ff       	call   804dd4 <pbuf_free>
    return;
  80db2d:	e9 3f 0c 00 00       	jmp    80e771 <tcp_input+0xd39>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80db32:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80db37:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80db3b:	89 04 24             	mov    %eax,(%esp)
  80db3e:	e8 10 a2 ff ff       	call   807d53 <ntohs>
  80db43:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80db47:	f7 d8                	neg    %eax
  80db49:	c1 e0 02             	shl    $0x2,%eax
  80db4c:	98                   	cwtl   
  80db4d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80db51:	89 34 24             	mov    %esi,(%esp)
  80db54:	e8 97 71 ff ff       	call   804cf0 <pbuf_header>
  80db59:	84 c0                	test   %al,%al
  80db5b:	74 0d                	je     80db6a <tcp_input+0x132>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80db5d:	89 34 24             	mov    %esi,(%esp)
  80db60:	e8 6f 72 ff ff       	call   804dd4 <pbuf_free>
    return;
  80db65:	e9 07 0c 00 00       	jmp    80e771 <tcp_input+0xd39>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80db6a:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80db70:	0f b7 03             	movzwl (%ebx),%eax
  80db73:	89 04 24             	mov    %eax,(%esp)
  80db76:	e8 d8 a1 ff ff       	call   807d53 <ntohs>
  80db7b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80db7e:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80db84:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80db88:	89 04 24             	mov    %eax,(%esp)
  80db8b:	e8 c3 a1 ff ff       	call   807d53 <ntohs>
  80db90:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80db94:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80db9a:	8b 43 04             	mov    0x4(%ebx),%eax
  80db9d:	89 04 24             	mov    %eax,(%esp)
  80dba0:	e8 f5 a3 ff ff       	call   807f9a <ntohl>
  80dba5:	89 43 04             	mov    %eax,0x4(%ebx)
  80dba8:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80dbad:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dbb3:	8b 43 08             	mov    0x8(%ebx),%eax
  80dbb6:	89 04 24             	mov    %eax,(%esp)
  80dbb9:	e8 dc a3 ff ff       	call   807f9a <ntohl>
  80dbbe:	89 43 08             	mov    %eax,0x8(%ebx)
  80dbc1:	a3 c4 c1 b3 00       	mov    %eax,0xb3c1c4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80dbc6:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dbcc:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80dbd0:	89 04 24             	mov    %eax,(%esp)
  80dbd3:	e8 7b a1 ff ff       	call   807d53 <ntohs>
  80dbd8:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80dbdc:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80dbe1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80dbe5:	89 04 24             	mov    %eax,(%esp)
  80dbe8:	e8 66 a1 ff ff       	call   807d53 <ntohs>
  80dbed:	89 c1                	mov    %eax,%ecx
  80dbef:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80dbf3:	83 e0 3f             	and    $0x3f,%eax
  80dbf6:	a2 c0 c1 b3 00       	mov    %al,0xb3c1c0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80dbfb:	f6 c1 03             	test   $0x3,%cl
  80dbfe:	0f 95 c0             	setne  %al
  80dc01:	0f b6 c0             	movzbl %al,%eax
  80dc04:	66 03 46 08          	add    0x8(%esi),%ax
  80dc08:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80dc0c:	66 a3 be c1 b3 00    	mov    %ax,0xb3c1be
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc12:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80dc17:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80dc1a:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dc20:	8b 0d cc c1 b3 00    	mov    0xb3c1cc,%ecx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc26:	89 c3                	mov    %eax,%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80dc28:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc2d:	e9 ea 00 00 00       	jmp    80dd1c <tcp_input+0x2e4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80dc32:	8b 43 10             	mov    0x10(%ebx),%eax
  80dc35:	85 c0                	test   %eax,%eax
  80dc37:	75 1c                	jne    80dc55 <tcp_input+0x21d>
  80dc39:	c7 44 24 08 04 42 81 	movl   $0x814204,0x8(%esp)
  80dc40:	00 
  80dc41:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80dc48:	00 
  80dc49:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80dc50:	e8 e5 13 00 00       	call   80f03a <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80dc55:	83 f8 0a             	cmp    $0xa,%eax
  80dc58:	75 1c                	jne    80dc76 <tcp_input+0x23e>
  80dc5a:	c7 44 24 08 2c 42 81 	movl   $0x81422c,0x8(%esp)
  80dc61:	00 
  80dc62:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  80dc69:	00 
  80dc6a:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80dc71:	e8 c4 13 00 00       	call   80f03a <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80dc76:	83 f8 01             	cmp    $0x1,%eax
  80dc79:	75 1c                	jne    80dc97 <tcp_input+0x25f>
  80dc7b:	c7 44 24 08 58 42 81 	movl   $0x814258,0x8(%esp)
  80dc82:	00 
  80dc83:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  80dc8a:	00 
  80dc8b:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80dc92:	e8 a3 13 00 00       	call   80f03a <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80dc97:	0f b7 02             	movzwl (%edx),%eax
  80dc9a:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80dc9e:	75 77                	jne    80dd17 <tcp_input+0x2df>
  80dca0:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80dca4:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80dca8:	75 6d                	jne    80dd17 <tcp_input+0x2df>
       pcb->local_port == tcphdr->dest &&
  80dcaa:	8b 41 0c             	mov    0xc(%ecx),%eax
  80dcad:	39 43 04             	cmp    %eax,0x4(%ebx)
  80dcb0:	75 65                	jne    80dd17 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dcb2:	8b 41 10             	mov    0x10(%ecx),%eax
  80dcb5:	39 03                	cmp    %eax,(%ebx)
  80dcb7:	75 5e                	jne    80dd17 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80dcb9:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dcbc:	39 d8                	cmp    %ebx,%eax
  80dcbe:	75 1c                	jne    80dcdc <tcp_input+0x2a4>
  80dcc0:	c7 44 24 08 80 42 81 	movl   $0x814280,0x8(%esp)
  80dcc7:	00 
  80dcc8:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  80dccf:	00 
  80dcd0:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80dcd7:	e8 5e 13 00 00       	call   80f03a <_panic>
      if (prev != NULL) {
  80dcdc:	85 ff                	test   %edi,%edi
  80dcde:	0f 84 06 0a 00 00    	je     80e6ea <tcp_input+0xcb2>
        prev->next = pcb->next;
  80dce4:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80dce7:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80dcea:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80dced:	89 1d 5c c2 b3 00    	mov    %ebx,0xb3c25c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80dcf3:	39 d8                	cmp    %ebx,%eax
  80dcf5:	0f 85 ef 09 00 00    	jne    80e6ea <tcp_input+0xcb2>
  80dcfb:	c7 44 24 08 ac 42 81 	movl   $0x8142ac,0x8(%esp)
  80dd02:	00 
  80dd03:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  80dd0a:	00 
  80dd0b:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80dd12:	e8 23 13 00 00       	call   80f03a <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd17:	89 df                	mov    %ebx,%edi
  80dd19:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80dd1c:	85 db                	test   %ebx,%ebx
  80dd1e:	0f 85 0e ff ff ff    	jne    80dc32 <tcp_input+0x1fa>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd24:	8b 1d 70 c2 b3 00    	mov    0xb3c270,%ebx
  80dd2a:	e9 85 00 00 00       	jmp    80ddb4 <tcp_input+0x37c>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80dd2f:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80dd33:	74 1c                	je     80dd51 <tcp_input+0x319>
  80dd35:	c7 44 24 08 d8 42 81 	movl   $0x8142d8,0x8(%esp)
  80dd3c:	00 
  80dd3d:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  80dd44:	00 
  80dd45:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80dd4c:	e8 e9 12 00 00       	call   80f03a <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80dd51:	0f b7 02             	movzwl (%edx),%eax
  80dd54:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80dd58:	75 57                	jne    80ddb1 <tcp_input+0x379>
  80dd5a:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80dd5e:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80dd62:	75 4d                	jne    80ddb1 <tcp_input+0x379>
         pcb->local_port == tcphdr->dest &&
  80dd64:	8b 41 0c             	mov    0xc(%ecx),%eax
  80dd67:	39 43 04             	cmp    %eax,0x4(%ebx)
  80dd6a:	75 45                	jne    80ddb1 <tcp_input+0x379>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dd6c:	8b 41 10             	mov    0x10(%ecx),%eax
  80dd6f:	39 03                	cmp    %eax,(%ebx)
  80dd71:	75 3e                	jne    80ddb1 <tcp_input+0x379>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80dd73:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80dd77:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80dd7d:	89 c2                	mov    %eax,%edx
  80dd7f:	2b 53 24             	sub    0x24(%ebx),%edx
  80dd82:	85 d2                	test   %edx,%edx
  80dd84:	7e 03                	jle    80dd89 <tcp_input+0x351>
    pcb->rcv_nxt = seqno + tcplen;
  80dd86:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80dd89:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80dd8e:	74 0c                	je     80dd9c <tcp_input+0x364>
    tcp_ack_now(pcb);
  80dd90:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dd94:	89 1c 24             	mov    %ebx,(%esp)
  80dd97:	e8 95 a9 ff ff       	call   808731 <tcp_output>
  }
  return tcp_output(pcb);
  80dd9c:	89 1c 24             	mov    %ebx,(%esp)
  80dd9f:	e8 8d a9 ff ff       	call   808731 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80dda4:	89 34 24             	mov    %esi,(%esp)
  80dda7:	e8 28 70 ff ff       	call   804dd4 <pbuf_free>
        return;
  80ddac:	e9 c0 09 00 00       	jmp    80e771 <tcp_input+0xd39>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80ddb1:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80ddb4:	85 db                	test   %ebx,%ebx
  80ddb6:	0f 85 73 ff ff ff    	jne    80dd2f <tcp_input+0x2f7>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80ddbc:	a1 64 c2 b3 00       	mov    0xb3c264,%eax
  80ddc1:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ddc4:	89 c3                	mov    %eax,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80ddc6:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80ddcb:	e9 af 01 00 00       	jmp    80df7f <tcp_input+0x547>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80ddd0:	85 db                	test   %ebx,%ebx
  80ddd2:	74 0f                	je     80dde3 <tcp_input+0x3ab>
  80ddd4:	8b 03                	mov    (%ebx),%eax
  80ddd6:	85 c0                	test   %eax,%eax
  80ddd8:	74 09                	je     80dde3 <tcp_input+0x3ab>
  80ddda:	3b 41 10             	cmp    0x10(%ecx),%eax
  80dddd:	0f 85 97 01 00 00    	jne    80df7a <tcp_input+0x542>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80dde3:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80dde7:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80ddeb:	0f 85 89 01 00 00    	jne    80df7a <tcp_input+0x542>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80ddf1:	85 ff                	test   %edi,%edi
  80ddf3:	74 12                	je     80de07 <tcp_input+0x3cf>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80ddf5:	8b 43 0c             	mov    0xc(%ebx),%eax
  80ddf8:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80ddfb:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80ddfe:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80de01:	89 1d 64 c2 b3 00    	mov    %ebx,0xb3c264
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80de07:	f6 45 d4 10          	testb  $0x10,-0x2c(%ebp)
  80de0b:	74 45                	je     80de52 <tcp_input+0x41a>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  80de0d:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80de12:	0f b7 0a             	movzwl (%edx),%ecx
  80de15:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80de19:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80de1d:	89 54 24 10          	mov    %edx,0x10(%esp)
  80de21:	8d 50 0c             	lea    0xc(%eax),%edx
  80de24:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80de28:	83 c0 10             	add    $0x10,%eax
  80de2b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80de2f:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80de33:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80de39:	89 44 24 04          	mov    %eax,0x4(%esp)
  80de3d:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80de42:	83 c0 01             	add    $0x1,%eax
  80de45:	89 04 24             	mov    %eax,(%esp)
  80de48:	e8 78 ad ff ff       	call   808bc5 <tcp_rst>
  80de4d:	e9 1b 01 00 00       	jmp    80df6d <tcp_input+0x535>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80de52:	f6 45 d4 02          	testb  $0x2,-0x2c(%ebp)
  80de56:	0f 84 11 01 00 00    	je     80df6d <tcp_input+0x535>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80de5c:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80de60:	89 04 24             	mov    %eax,(%esp)
  80de63:	e8 d2 88 ff ff       	call   80673a <tcp_alloc>
  80de68:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80de6a:	85 c0                	test   %eax,%eax
  80de6c:	0f 84 fb 00 00 00    	je     80df6d <tcp_input+0x535>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80de72:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80de77:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80de7a:	74 05                	je     80de81 <tcp_input+0x449>
  80de7c:	8b 50 10             	mov    0x10(%eax),%edx
  80de7f:	eb 05                	jmp    80de86 <tcp_input+0x44e>
  80de81:	ba 00 00 00 00       	mov    $0x0,%edx
  80de86:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80de88:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  80de8c:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80de90:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80de93:	74 05                	je     80de9a <tcp_input+0x462>
  80de95:	8b 40 0c             	mov    0xc(%eax),%eax
  80de98:	eb 05                	jmp    80de9f <tcp_input+0x467>
  80de9a:	b8 00 00 00 00       	mov    $0x0,%eax
  80de9f:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80dea2:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
  80dea8:	0f b7 02             	movzwl (%edx),%eax
  80deab:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80deaf:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80deb6:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80debb:	8d 48 01             	lea    0x1(%eax),%ecx
  80debe:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80dec1:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80dec5:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80dec9:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80decd:	83 e8 01             	sub    $0x1,%eax
  80ded0:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80ded3:	8b 43 18             	mov    0x18(%ebx),%eax
  80ded6:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80ded9:	8b 43 20             	mov    0x20(%ebx),%eax
  80dedc:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80dee2:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80dee6:	66 25 99 01          	and    $0x199,%ax
  80deea:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80deee:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80def3:	89 47 0c             	mov    %eax,0xc(%edi)
  80def6:	89 3d 5c c2 b3 00    	mov    %edi,0xb3c25c
  80defc:	e8 51 46 ff ff       	call   802552 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80df01:	89 f8                	mov    %edi,%eax
  80df03:	e8 58 ee ff ff       	call   80cd60 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80df08:	8d 47 04             	lea    0x4(%edi),%eax
  80df0b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80df0f:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80df13:	89 04 24             	mov    %eax,(%esp)
  80df16:	e8 ae 89 ff ff       	call   8068c9 <tcp_eff_send_mss>
  80df1b:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80df1f:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80df26:	e8 35 9e ff ff       	call   807d60 <htonl>
  80df2b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80df2e:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  80df35:	00 
  80df36:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80df39:	89 44 24 14          	mov    %eax,0x14(%esp)
  80df3d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80df44:	00 
  80df45:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  80df4c:	00 
  80df4d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80df54:	00 
  80df55:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80df5c:	00 
  80df5d:	89 3c 24             	mov    %edi,(%esp)
  80df60:	e8 4b a0 ff ff       	call   807fb0 <tcp_enqueue>
    return tcp_output(npcb);
  80df65:	89 3c 24             	mov    %edi,(%esp)
  80df68:	e8 c4 a7 ff ff       	call   808731 <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80df6d:	89 34 24             	mov    %esi,(%esp)
  80df70:	e8 5f 6e ff ff       	call   804dd4 <pbuf_free>
        return;
  80df75:	e9 f7 07 00 00       	jmp    80e771 <tcp_input+0xd39>
  80df7a:	89 df                	mov    %ebx,%edi
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80df7c:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80df7f:	85 db                	test   %ebx,%ebx
  80df81:	0f 85 49 fe ff ff    	jne    80ddd0 <tcp_input+0x398>
  80df87:	e9 ae 07 00 00       	jmp    80e73a <tcp_input+0xd02>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80df8c:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80df92:	85 c0                	test   %eax,%eax
  80df94:	74 1e                	je     80dfb4 <tcp_input+0x57c>
  80df96:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80df9d:	00 
  80df9e:	89 54 24 08          	mov    %edx,0x8(%esp)
  80dfa2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80dfa6:	8b 53 18             	mov    0x18(%ebx),%edx
  80dfa9:	89 14 24             	mov    %edx,(%esp)
  80dfac:	ff d0                	call   *%eax
      if (err == ERR_OK) {
  80dfae:	84 c0                	test   %al,%al
  80dfb0:	74 0a                	je     80dfbc <tcp_input+0x584>
  80dfb2:	eb 14                	jmp    80dfc8 <tcp_input+0x590>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80dfb4:	89 14 24             	mov    %edx,(%esp)
  80dfb7:	e8 18 6e ff ff       	call   804dd4 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80dfbc:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80dfc3:	00 00 00 
  80dfc6:	eb 0d                	jmp    80dfd5 <tcp_input+0x59d>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80dfc8:	89 34 24             	mov    %esi,(%esp)
  80dfcb:	e8 04 6e ff ff       	call   804dd4 <pbuf_free>
        return;
  80dfd0:	e9 9c 07 00 00       	jmp    80e771 <tcp_input+0xd39>
      }
    }

    tcp_input_pcb = pcb;
  80dfd5:	89 1d 78 c2 b3 00    	mov    %ebx,0xb3c278
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80dfdb:	0f b6 05 c0 c1 b3 00 	movzbl 0xb3c1c0,%eax
  80dfe2:	a8 04                	test   $0x4,%al
  80dfe4:	74 64                	je     80e04a <tcp_input+0x612>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80dfe6:	8b 43 10             	mov    0x10(%ebx),%eax
  80dfe9:	83 f8 02             	cmp    $0x2,%eax
  80dfec:	75 0f                	jne    80dffd <tcp_input+0x5c5>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80dfee:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80dff3:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dff6:	74 42                	je     80e03a <tcp_input+0x602>
  80dff8:	e9 38 05 00 00       	jmp    80e535 <tcp_input+0xafd>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80dffd:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80e003:	2b 53 24             	sub    0x24(%ebx),%edx
  80e006:	0f 88 43 07 00 00    	js     80e74f <tcp_input+0xd17>
  80e00c:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80e010:	29 ca                	sub    %ecx,%edx
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80e012:	85 d2                	test   %edx,%edx
  80e014:	0f 8f 35 07 00 00    	jg     80e74f <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80e01a:	85 c0                	test   %eax,%eax
  80e01c:	75 1c                	jne    80e03a <tcp_input+0x602>
  80e01e:	c7 44 24 08 08 43 81 	movl   $0x814308,0x8(%esp)
  80e025:	00 
  80e026:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  80e02d:	00 
  80e02e:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80e035:	e8 00 10 00 00       	call   80f03a <_panic>
      recv_flags = TF_RESET;
  80e03a:	c6 05 bc c1 b3 00 08 	movb   $0x8,0xb3c1bc
      pcb->flags &= ~TF_ACK_DELAY;
  80e041:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80e045:	e9 05 07 00 00       	jmp    80e74f <tcp_input+0xd17>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80e04a:	8b 15 60 c2 b3 00    	mov    0xb3c260,%edx
  80e050:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80e053:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80e05a:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80e05e:	0f 87 d1 04 00 00    	ja     80e535 <tcp_input+0xafd>
  80e064:	8b 53 10             	mov    0x10(%ebx),%edx
  80e067:	ff 24 95 ac 43 81 00 	jmp    *0x8143ac(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80e06e:	83 e0 12             	and    $0x12,%eax
  80e071:	3c 12                	cmp    $0x12,%al
  80e073:	0f 85 03 01 00 00    	jne    80e17c <tcp_input+0x744>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80e079:	8b 43 78             	mov    0x78(%ebx),%eax
  80e07c:	8b 40 10             	mov    0x10(%eax),%eax
  80e07f:	8b 40 04             	mov    0x4(%eax),%eax
  80e082:	89 04 24             	mov    %eax,(%esp)
  80e085:	e8 10 9f ff ff       	call   807f9a <ntohl>
  80e08a:	8d 50 01             	lea    0x1(%eax),%edx
  80e08d:	3b 15 c4 c1 b3 00    	cmp    0xb3c1c4,%edx
  80e093:	0f 85 e3 00 00 00    	jne    80e17c <tcp_input+0x744>
      pcb->snd_buf++;
  80e099:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80e09e:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e0a3:	8d 48 01             	lea    0x1(%eax),%ecx
  80e0a6:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80e0a9:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80e0ac:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
  80e0b2:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80e0b6:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80e0ba:	83 e8 01             	sub    $0x1,%eax
  80e0bd:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80e0c0:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80e0c7:	89 d8                	mov    %ebx,%eax
  80e0c9:	e8 92 ec ff ff       	call   80cd60 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80e0ce:	8d 43 04             	lea    0x4(%ebx),%eax
  80e0d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e0d5:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80e0d9:	89 04 24             	mov    %eax,(%esp)
  80e0dc:	e8 e8 87 ff ff       	call   8068c9 <tcp_eff_send_mss>
  80e0e1:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80e0e5:	6b d0 0a             	imul   $0xa,%eax,%edx
  80e0e8:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e0ec:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80e0ef:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80e0f4:	0f 44 c2             	cmove  %edx,%eax
  80e0f7:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80e0fb:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80e0ff:	66 85 c0             	test   %ax,%ax
  80e102:	75 1c                	jne    80e120 <tcp_input+0x6e8>
  80e104:	c7 44 24 08 81 43 81 	movl   $0x814381,0x8(%esp)
  80e10b:	00 
  80e10c:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  80e113:	00 
  80e114:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80e11b:	e8 1a 0f 00 00       	call   80f03a <_panic>
      --pcb->snd_queuelen;
  80e120:	83 e8 01             	sub    $0x1,%eax
  80e123:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80e127:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80e12a:	8b 10                	mov    (%eax),%edx
  80e12c:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80e12f:	85 d2                	test   %edx,%edx
  80e131:	75 08                	jne    80e13b <tcp_input+0x703>
        pcb->rtime = -1;
  80e133:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80e139:	eb 0a                	jmp    80e145 <tcp_input+0x70d>
      else {
        pcb->rtime = 0;
  80e13b:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80e141:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80e145:	89 04 24             	mov    %eax,(%esp)
  80e148:	e8 5c 7c ff ff       	call   805da9 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80e14d:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80e153:	85 c0                	test   %eax,%eax
  80e155:	74 14                	je     80e16b <tcp_input+0x733>
  80e157:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e15e:	00 
  80e15f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e163:	8b 53 18             	mov    0x18(%ebx),%edx
  80e166:	89 14 24             	mov    %edx,(%esp)
  80e169:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  80e16b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e16f:	89 1c 24             	mov    %ebx,(%esp)
  80e172:	e8 ba a5 ff ff       	call   808731 <tcp_output>
  80e177:	e9 d3 05 00 00       	jmp    80e74f <tcp_input+0xd17>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80e17c:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80e183:	0f 84 c6 05 00 00    	je     80e74f <tcp_input+0xd17>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e189:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e18f:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80e194:	0f b7 0a             	movzwl (%edx),%ecx
  80e197:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e19b:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e19f:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e1a3:	8d 50 0c             	lea    0xc(%eax),%edx
  80e1a6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e1aa:	83 c0 10             	add    $0x10,%eax
  80e1ad:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e1b1:	0f b7 05 be c1 b3 00 	movzwl 0xb3c1be,%eax
  80e1b8:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80e1be:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e1c2:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e1c7:	89 04 24             	mov    %eax,(%esp)
  80e1ca:	e8 f6 a9 ff ff       	call   808bc5 <tcp_rst>
  80e1cf:	e9 7b 05 00 00       	jmp    80e74f <tcp_input+0xd17>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80e1d4:	83 e0 14             	and    $0x14,%eax
  80e1d7:	3c 10                	cmp    $0x10,%al
  80e1d9:	0f 85 70 05 00 00    	jne    80e74f <tcp_input+0xd17>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80e1df:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e1e4:	8d 50 ff             	lea    -0x1(%eax),%edx
  80e1e7:	3b 53 48             	cmp    0x48(%ebx),%edx
  80e1ea:	0f 88 b8 00 00 00    	js     80e2a8 <tcp_input+0x870>
  80e1f0:	89 c2                	mov    %eax,%edx
  80e1f2:	2b 53 54             	sub    0x54(%ebx),%edx
  80e1f5:	85 d2                	test   %edx,%edx
  80e1f7:	0f 8f ab 00 00 00    	jg     80e2a8 <tcp_input+0x870>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80e1fd:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80e204:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80e20a:	85 c0                	test   %eax,%eax
  80e20c:	75 1c                	jne    80e22a <tcp_input+0x7f2>
  80e20e:	c7 44 24 08 97 43 81 	movl   $0x814397,0x8(%esp)
  80e215:	00 
  80e216:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  80e21d:	00 
  80e21e:	c7 04 24 28 43 81 00 	movl   $0x814328,(%esp)
  80e225:	e8 10 0e 00 00       	call   80f03a <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80e22a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e231:	00 
  80e232:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e236:	8b 53 18             	mov    0x18(%ebx),%edx
  80e239:	89 14 24             	mov    %edx,(%esp)
  80e23c:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80e23e:	84 c0                	test   %al,%al
  80e240:	74 17                	je     80e259 <tcp_input+0x821>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80e242:	89 1c 24             	mov    %ebx,(%esp)
  80e245:	e8 6f 7f ff ff       	call   8061b9 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e24a:	c7 05 78 c2 b3 00 00 	movl   $0x0,0xb3c278
  80e251:	00 00 00 
  80e254:	e9 1a 04 00 00       	jmp    80e673 <tcp_input+0xc3b>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80e259:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80e25d:	89 d8                	mov    %ebx,%eax
  80e25f:	e8 a6 eb ff ff       	call   80ce0a <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e264:	66 83 fe 01          	cmp    $0x1,%si
  80e268:	75 09                	jne    80e273 <tcp_input+0x83b>
  80e26a:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80e26e:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80e271:	eb 04                	jmp    80e277 <tcp_input+0x83f>
  80e273:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80e277:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80e27b:	f6 05 c0 c1 b3 00 01 	testb  $0x1,0xb3c1c0
  80e282:	0f 84 c7 04 00 00    	je     80e74f <tcp_input+0xd17>
  80e288:	84 c0                	test   %al,%al
  80e28a:	0f 84 bf 04 00 00    	je     80e74f <tcp_input+0xd17>
          tcp_ack_now(pcb);
  80e290:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e294:	89 1c 24             	mov    %ebx,(%esp)
  80e297:	e8 95 a4 ff ff       	call   808731 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80e29c:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e2a3:	e9 a7 04 00 00       	jmp    80e74f <tcp_input+0xd17>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80e2a8:	8b 0d d0 c1 b3 00    	mov    0xb3c1d0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e2ae:	8b 15 cc c1 b3 00    	mov    0xb3c1cc,%edx
  80e2b4:	0f b7 31             	movzwl (%ecx),%esi
  80e2b7:	89 74 24 14          	mov    %esi,0x14(%esp)
  80e2bb:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80e2bf:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  80e2c3:	8d 4a 0c             	lea    0xc(%edx),%ecx
  80e2c6:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80e2ca:	83 c2 10             	add    $0x10,%edx
  80e2cd:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e2d1:	0f b7 15 be c1 b3 00 	movzwl 0xb3c1be,%edx
  80e2d8:	03 15 c8 c1 b3 00    	add    0xb3c1c8,%edx
  80e2de:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e2e2:	89 04 24             	mov    %eax,(%esp)
  80e2e5:	e8 db a8 ff ff       	call   808bc5 <tcp_rst>
  80e2ea:	e9 60 04 00 00       	jmp    80e74f <tcp_input+0xd17>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80e2ef:	89 d8                	mov    %ebx,%eax
  80e2f1:	e8 14 eb ff ff       	call   80ce0a <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80e2f6:	f6 05 c0 c1 b3 00 01 	testb  $0x1,0xb3c1c0
  80e2fd:	0f 84 4c 04 00 00    	je     80e74f <tcp_input+0xd17>
  80e303:	84 c0                	test   %al,%al
  80e305:	0f 84 44 04 00 00    	je     80e74f <tcp_input+0xd17>
      tcp_ack_now(pcb);
  80e30b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e30f:	89 1c 24             	mov    %ebx,(%esp)
  80e312:	e8 1a a4 ff ff       	call   808731 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80e317:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e31e:	e9 2c 04 00 00       	jmp    80e74f <tcp_input+0xd17>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80e323:	89 d8                	mov    %ebx,%eax
  80e325:	e8 e0 ea ff ff       	call   80ce0a <tcp_receive>
    if (flags & TCP_FIN) {
  80e32a:	0f b6 05 c0 c1 b3 00 	movzbl 0xb3c1c0,%eax
  80e331:	a8 01                	test   $0x1,%al
  80e333:	0f 84 96 00 00 00    	je     80e3cf <tcp_input+0x997>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e339:	a8 10                	test   $0x10,%al
  80e33b:	74 7a                	je     80e3b7 <tcp_input+0x97f>
  80e33d:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e342:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e345:	75 70                	jne    80e3b7 <tcp_input+0x97f>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80e347:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e34b:	89 1c 24             	mov    %ebx,(%esp)
  80e34e:	e8 de a3 ff ff       	call   808731 <tcp_output>
        tcp_pcb_purge(pcb);
  80e353:	89 1c 24             	mov    %ebx,(%esp)
  80e356:	e8 77 7b ff ff       	call   805ed2 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80e35b:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e360:	39 c3                	cmp    %eax,%ebx
  80e362:	75 0a                	jne    80e36e <tcp_input+0x936>
  80e364:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e367:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
  80e36c:	eb 2a                	jmp    80e398 <tcp_input+0x960>
  80e36e:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e373:	eb 1a                	jmp    80e38f <tcp_input+0x957>
  80e375:	8b 50 0c             	mov    0xc(%eax),%edx
  80e378:	85 d2                	test   %edx,%edx
  80e37a:	74 11                	je     80e38d <tcp_input+0x955>
  80e37c:	39 d3                	cmp    %edx,%ebx
  80e37e:	75 0d                	jne    80e38d <tcp_input+0x955>
  80e380:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e385:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e388:	89 50 0c             	mov    %edx,0xc(%eax)
  80e38b:	eb 0b                	jmp    80e398 <tcp_input+0x960>
  80e38d:	89 d0                	mov    %edx,%eax
  80e38f:	85 c0                	test   %eax,%eax
  80e391:	75 e2                	jne    80e375 <tcp_input+0x93d>
  80e393:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
        pcb->state = TIME_WAIT;
  80e398:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80e39f:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  80e3a4:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e3a7:	89 1d 70 c2 b3 00    	mov    %ebx,0xb3c270
  80e3ad:	e8 a0 41 ff ff       	call   802552 <tcp_timer_needed>
  80e3b2:	e9 98 03 00 00       	jmp    80e74f <tcp_input+0xd17>
      } else {
        tcp_ack_now(pcb);
  80e3b7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e3bb:	89 1c 24             	mov    %ebx,(%esp)
  80e3be:	e8 6e a3 ff ff       	call   808731 <tcp_output>
        pcb->state = CLOSING;
  80e3c3:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80e3ca:	e9 80 03 00 00       	jmp    80e74f <tcp_input+0xd17>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e3cf:	a8 10                	test   $0x10,%al
  80e3d1:	0f 84 78 03 00 00    	je     80e74f <tcp_input+0xd17>
  80e3d7:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e3dc:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e3df:	0f 85 6a 03 00 00    	jne    80e74f <tcp_input+0xd17>
      pcb->state = FIN_WAIT_2;
  80e3e5:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80e3ec:	e9 5e 03 00 00       	jmp    80e74f <tcp_input+0xd17>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80e3f1:	89 d8                	mov    %ebx,%eax
  80e3f3:	e8 12 ea ff ff       	call   80ce0a <tcp_receive>
    if (flags & TCP_FIN) {
  80e3f8:	f6 05 c0 c1 b3 00 01 	testb  $0x1,0xb3c1c0
  80e3ff:	0f 84 4a 03 00 00    	je     80e74f <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e405:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e409:	89 1c 24             	mov    %ebx,(%esp)
  80e40c:	e8 20 a3 ff ff       	call   808731 <tcp_output>
      tcp_pcb_purge(pcb);
  80e411:	89 1c 24             	mov    %ebx,(%esp)
  80e414:	e8 b9 7a ff ff       	call   805ed2 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e419:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e41e:	39 c3                	cmp    %eax,%ebx
  80e420:	75 0a                	jne    80e42c <tcp_input+0x9f4>
  80e422:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e425:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
  80e42a:	eb 2a                	jmp    80e456 <tcp_input+0xa1e>
  80e42c:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e431:	eb 1a                	jmp    80e44d <tcp_input+0xa15>
  80e433:	8b 50 0c             	mov    0xc(%eax),%edx
  80e436:	85 d2                	test   %edx,%edx
  80e438:	74 11                	je     80e44b <tcp_input+0xa13>
  80e43a:	39 d3                	cmp    %edx,%ebx
  80e43c:	75 0d                	jne    80e44b <tcp_input+0xa13>
  80e43e:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e443:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e446:	89 50 0c             	mov    %edx,0xc(%eax)
  80e449:	eb 0b                	jmp    80e456 <tcp_input+0xa1e>
  80e44b:	89 d0                	mov    %edx,%eax
  80e44d:	85 c0                	test   %eax,%eax
  80e44f:	75 e2                	jne    80e433 <tcp_input+0x9fb>
  80e451:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
      pcb->state = TIME_WAIT;
  80e456:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e45d:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  80e462:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e465:	89 1d 70 c2 b3 00    	mov    %ebx,0xb3c270
  80e46b:	e8 e2 40 ff ff       	call   802552 <tcp_timer_needed>
  80e470:	e9 da 02 00 00       	jmp    80e74f <tcp_input+0xd17>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80e475:	89 d8                	mov    %ebx,%eax
  80e477:	e8 8e e9 ff ff       	call   80ce0a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e47c:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80e483:	0f 84 c6 02 00 00    	je     80e74f <tcp_input+0xd17>
  80e489:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e48e:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e491:	0f 85 b8 02 00 00    	jne    80e74f <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e497:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e49b:	89 1c 24             	mov    %ebx,(%esp)
  80e49e:	e8 8e a2 ff ff       	call   808731 <tcp_output>
      tcp_pcb_purge(pcb);
  80e4a3:	89 1c 24             	mov    %ebx,(%esp)
  80e4a6:	e8 27 7a ff ff       	call   805ed2 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e4ab:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e4b0:	39 c3                	cmp    %eax,%ebx
  80e4b2:	75 0a                	jne    80e4be <tcp_input+0xa86>
  80e4b4:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e4b7:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
  80e4bc:	eb 2a                	jmp    80e4e8 <tcp_input+0xab0>
  80e4be:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e4c3:	eb 1a                	jmp    80e4df <tcp_input+0xaa7>
  80e4c5:	8b 50 0c             	mov    0xc(%eax),%edx
  80e4c8:	85 d2                	test   %edx,%edx
  80e4ca:	74 11                	je     80e4dd <tcp_input+0xaa5>
  80e4cc:	39 d3                	cmp    %edx,%ebx
  80e4ce:	75 0d                	jne    80e4dd <tcp_input+0xaa5>
  80e4d0:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e4d5:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e4d8:	89 50 0c             	mov    %edx,0xc(%eax)
  80e4db:	eb 0b                	jmp    80e4e8 <tcp_input+0xab0>
  80e4dd:	89 d0                	mov    %edx,%eax
  80e4df:	85 c0                	test   %eax,%eax
  80e4e1:	75 e2                	jne    80e4c5 <tcp_input+0xa8d>
  80e4e3:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
      pcb->state = TIME_WAIT;
  80e4e8:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e4ef:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  80e4f4:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e4f7:	89 1d 70 c2 b3 00    	mov    %ebx,0xb3c270
  80e4fd:	e8 50 40 ff ff       	call   802552 <tcp_timer_needed>
  80e502:	e9 48 02 00 00       	jmp    80e74f <tcp_input+0xd17>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80e507:	89 d8                	mov    %ebx,%eax
  80e509:	e8 fc e8 ff ff       	call   80ce0a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e50e:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80e515:	0f 84 34 02 00 00    	je     80e74f <tcp_input+0xd17>
  80e51b:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e520:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e523:	0f 85 26 02 00 00    	jne    80e74f <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80e529:	c6 05 bc c1 b3 00 10 	movb   $0x10,0xb3c1bc
  80e530:	e9 1a 02 00 00       	jmp    80e74f <tcp_input+0xd17>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e535:	c7 05 78 c2 b3 00 00 	movl   $0x0,0xb3c278
  80e53c:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80e53f:	0f b6 05 bc c1 b3 00 	movzbl 0xb3c1bc,%eax
  80e546:	a8 08                	test   $0x8,%al
  80e548:	74 3f                	je     80e589 <tcp_input+0xb51>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80e54a:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80e550:	85 c0                	test   %eax,%eax
  80e552:	74 10                	je     80e564 <tcp_input+0xb2c>
  80e554:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  80e55b:	ff 
  80e55c:	8b 53 18             	mov    0x18(%ebx),%edx
  80e55f:	89 14 24             	mov    %edx,(%esp)
  80e562:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e564:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e568:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  80e56f:	e8 d3 79 ff ff       	call   805f47 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e574:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e578:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e57f:	e8 9e 64 ff ff       	call   804a22 <memp_free>
  80e584:	e9 ea 00 00 00       	jmp    80e673 <tcp_input+0xc3b>
      } else if (recv_flags & TF_CLOSED) {
  80e589:	a8 10                	test   $0x10,%al
  80e58b:	74 25                	je     80e5b2 <tcp_input+0xb7a>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e58d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e591:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  80e598:	e8 aa 79 ff ff       	call   805f47 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e59d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e5a1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e5a8:	e8 75 64 ff ff       	call   804a22 <memp_free>
  80e5ad:	e9 c1 00 00 00       	jmp    80e673 <tcp_input+0xc3b>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80e5b2:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80e5b6:	b8 00 00 00 00       	mov    $0x0,%eax
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80e5bb:	66 85 d2             	test   %dx,%dx
  80e5be:	74 1d                	je     80e5dd <tcp_input+0xba5>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80e5c0:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80e5c6:	85 c9                	test   %ecx,%ecx
  80e5c8:	74 13                	je     80e5dd <tcp_input+0xba5>
  80e5ca:	0f b7 d2             	movzwl %dx,%edx
  80e5cd:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e5d1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e5d5:	8b 43 18             	mov    0x18(%ebx),%eax
  80e5d8:	89 04 24             	mov    %eax,(%esp)
  80e5db:	ff d1                	call   *%ecx
        }
      
        if (recv_data != NULL) {
  80e5dd:	8b 15 b8 c1 b3 00    	mov    0xb3c1b8,%edx
  80e5e3:	85 d2                	test   %edx,%edx
  80e5e5:	74 51                	je     80e638 <tcp_input+0xc00>
          if(flags & TCP_PSH) {
  80e5e7:	f6 05 c0 c1 b3 00 08 	testb  $0x8,0xb3c1c0
  80e5ee:	0f 84 6a 01 00 00    	je     80e75e <tcp_input+0xd26>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80e5f4:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
  80e5f8:	e9 61 01 00 00       	jmp    80e75e <tcp_input+0xd26>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e5fd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e604:	00 
  80e605:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e609:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e60d:	8b 53 18             	mov    0x18(%ebx),%edx
  80e610:	89 14 24             	mov    %edx,(%esp)
  80e613:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80e615:	84 c0                	test   %al,%al
  80e617:	75 13                	jne    80e62c <tcp_input+0xbf4>
  80e619:	eb 1d                	jmp    80e638 <tcp_input+0xc00>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e61b:	89 14 24             	mov    %edx,(%esp)
  80e61e:	66 90                	xchg   %ax,%ax
  80e620:	e8 af 67 ff ff       	call   804dd4 <pbuf_free>
  80e625:	b8 00 00 00 00       	mov    $0x0,%eax
  80e62a:	eb 0c                	jmp    80e638 <tcp_input+0xc00>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80e62c:	8b 15 b8 c1 b3 00    	mov    0xb3c1b8,%edx
  80e632:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80e638:	f6 05 bc c1 b3 00 20 	testb  $0x20,0xb3c1bc
  80e63f:	74 26                	je     80e667 <tcp_input+0xc2f>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80e641:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e647:	85 c0                	test   %eax,%eax
  80e649:	74 20                	je     80e66b <tcp_input+0xc33>
  80e64b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e652:	00 
  80e653:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e65a:	00 
  80e65b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e65f:	8b 53 18             	mov    0x18(%ebx),%edx
  80e662:	89 14 24             	mov    %edx,(%esp)
  80e665:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80e667:	84 c0                	test   %al,%al
  80e669:	75 08                	jne    80e673 <tcp_input+0xc3b>
          tcp_output(pcb);
  80e66b:	89 1c 24             	mov    %ebx,(%esp)
  80e66e:	e8 be a0 ff ff       	call   808731 <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80e673:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80e678:	85 c0                	test   %eax,%eax
  80e67a:	0f 84 f1 00 00 00    	je     80e771 <tcp_input+0xd39>
    {
      pbuf_free(inseg.p);
  80e680:	89 04 24             	mov    %eax,(%esp)
  80e683:	e8 4c 67 ff ff       	call   804dd4 <pbuf_free>
      inseg.p = NULL;
  80e688:	c7 05 d8 c1 b3 00 00 	movl   $0x0,0xb3c1d8
  80e68f:	00 00 00 
  80e692:	e9 da 00 00 00       	jmp    80e771 <tcp_input+0xd39>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e697:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80e69d:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80e6a2:	0f b7 0a             	movzwl (%edx),%ecx
  80e6a5:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e6a9:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e6ad:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e6b1:	8d 50 0c             	lea    0xc(%eax),%edx
  80e6b4:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e6b8:	83 c0 10             	add    $0x10,%eax
  80e6bb:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e6bf:	0f b7 05 be c1 b3 00 	movzwl 0xb3c1be,%eax
  80e6c6:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80e6cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e6d0:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e6d5:	89 04 24             	mov    %eax,(%esp)
  80e6d8:	e8 e8 a4 ff ff       	call   808bc5 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80e6dd:	89 34 24             	mov    %esi,(%esp)
  80e6e0:	e8 ef 66 ff ff       	call   804dd4 <pbuf_free>
  80e6e5:	e9 87 00 00 00       	jmp    80e771 <tcp_input+0xd39>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80e6ea:	c7 05 d4 c1 b3 00 00 	movl   $0x0,0xb3c1d4
  80e6f1:	00 00 00 
    inseg.len = p->tot_len;
  80e6f4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80e6f8:	66 a3 e0 c1 b3 00    	mov    %ax,0xb3c1e0
    inseg.dataptr = p->payload;
  80e6fe:	8b 46 04             	mov    0x4(%esi),%eax
  80e701:	a3 dc c1 b3 00       	mov    %eax,0xb3c1dc
    inseg.p = p;
  80e706:	89 35 d8 c1 b3 00    	mov    %esi,0xb3c1d8
    inseg.tcphdr = tcphdr;
  80e70c:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80e711:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4

    recv_data = NULL;
  80e716:	c7 05 b8 c1 b3 00 00 	movl   $0x0,0xb3c1b8
  80e71d:	00 00 00 
    recv_flags = 0;
  80e720:	c6 05 bc c1 b3 00 00 	movb   $0x0,0xb3c1bc

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80e727:	8b 93 80 00 00 00    	mov    0x80(%ebx),%edx
  80e72d:	85 d2                	test   %edx,%edx
  80e72f:	0f 85 57 f8 ff ff    	jne    80df8c <tcp_input+0x554>
  80e735:	e9 9b f8 ff ff       	jmp    80dfd5 <tcp_input+0x59d>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80e73a:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80e73e:	89 04 24             	mov    %eax,(%esp)
  80e741:	e8 0d 96 ff ff       	call   807d53 <ntohs>
  80e746:	a8 04                	test   $0x4,%al
  80e748:	75 93                	jne    80e6dd <tcp_input+0xca5>
  80e74a:	e9 48 ff ff ff       	jmp    80e697 <tcp_input+0xc5f>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e74f:	c7 05 78 c2 b3 00 00 	movl   $0x0,0xb3c278
  80e756:	00 00 00 
  80e759:	e9 e1 fd ff ff       	jmp    80e53f <tcp_input+0xb07>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e75e:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e764:	85 c0                	test   %eax,%eax
  80e766:	0f 85 91 fe ff ff    	jne    80e5fd <tcp_input+0xbc5>
  80e76c:	e9 aa fe ff ff       	jmp    80e61b <tcp_input+0xbe3>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80e771:	83 c4 4c             	add    $0x4c,%esp
  80e774:	5b                   	pop    %ebx
  80e775:	5e                   	pop    %esi
  80e776:	5f                   	pop    %edi
  80e777:	5d                   	pop    %ebp
  80e778:	c3                   	ret    

0080e779 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80e779:	55                   	push   %ebp
  80e77a:	89 e5                	mov    %esp,%ebp
  80e77c:	57                   	push   %edi
  80e77d:	56                   	push   %esi
  80e77e:	53                   	push   %ebx
  80e77f:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80e782:	8b 45 08             	mov    0x8(%ebp),%eax
  80e785:	8b 40 04             	mov    0x4(%eax),%eax
  proto = IPH_PROTO(iphdr);
  80e788:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e78b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e78f:	89 04 24             	mov    %eax,(%esp)
  80e792:	e8 bc 95 ff ff       	call   807d53 <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80e797:	8b 1d e8 c1 b3 00    	mov    0xb3c1e8,%ebx
raw_input(struct pbuf *p, struct netif *inp)
{
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  80e79d:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80e7a1:	be 00 00 00 00       	mov    $0x0,%esi
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80e7a6:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e7a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e7ac:	83 c0 0c             	add    $0xc,%eax
  80e7af:	89 45 e0             	mov    %eax,-0x20(%ebp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e7b2:	eb 62                	jmp    80e816 <raw_input+0x9d>
    if (pcb->protocol == proto) {
  80e7b4:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e7b8:	39 f8                	cmp    %edi,%eax
  80e7ba:	75 55                	jne    80e811 <raw_input+0x98>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80e7bc:	8b 43 14             	mov    0x14(%ebx),%eax
  80e7bf:	85 c0                	test   %eax,%eax
  80e7c1:	74 4e                	je     80e811 <raw_input+0x98>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e7c3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e7c6:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80e7ca:	8b 55 08             	mov    0x8(%ebp),%edx
  80e7cd:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e7d1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e7d5:	8b 53 18             	mov    0x18(%ebx),%edx
  80e7d8:	89 14 24             	mov    %edx,(%esp)
  80e7db:	ff d0                	call   *%eax
  80e7dd:	84 c0                	test   %al,%al
  80e7df:	74 30                	je     80e811 <raw_input+0x98>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80e7e1:	85 f6                	test   %esi,%esi
  80e7e3:	74 21                	je     80e806 <raw_input+0x8d>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80e7e5:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e7e8:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  80e7eb:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80e7f0:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80e7f3:	89 1d e8 c1 b3 00    	mov    %ebx,0xb3c1e8
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80e7f9:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80e7fd:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80e804:	eb 0b                	jmp    80e811 <raw_input+0x98>
          eaten = 1;
  80e806:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80e80a:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80e811:	89 de                	mov    %ebx,%esi
    pcb = pcb->next;
  80e813:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e816:	85 db                	test   %ebx,%ebx
  80e818:	74 06                	je     80e820 <raw_input+0xa7>
  80e81a:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80e81e:	74 94                	je     80e7b4 <raw_input+0x3b>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80e820:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80e824:	83 c4 2c             	add    $0x2c,%esp
  80e827:	5b                   	pop    %ebx
  80e828:	5e                   	pop    %esi
  80e829:	5f                   	pop    %edi
  80e82a:	5d                   	pop    %ebp
  80e82b:	c3                   	ret    

0080e82c <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e82c:	55                   	push   %ebp
  80e82d:	89 e5                	mov    %esp,%ebp
  80e82f:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e832:	85 c0                	test   %eax,%eax
  80e834:	74 04                	je     80e83a <raw_bind+0xe>
  80e836:	8b 10                	mov    (%eax),%edx
  80e838:	eb 05                	jmp    80e83f <raw_bind+0x13>
  80e83a:	ba 00 00 00 00       	mov    $0x0,%edx
  80e83f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e842:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80e844:	b8 00 00 00 00       	mov    $0x0,%eax
  80e849:	5d                   	pop    %ebp
  80e84a:	c3                   	ret    

0080e84b <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e84b:	55                   	push   %ebp
  80e84c:	89 e5                	mov    %esp,%ebp
  80e84e:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e851:	85 c0                	test   %eax,%eax
  80e853:	74 04                	je     80e859 <raw_connect+0xe>
  80e855:	8b 10                	mov    (%eax),%edx
  80e857:	eb 05                	jmp    80e85e <raw_connect+0x13>
  80e859:	ba 00 00 00 00       	mov    $0x0,%edx
  80e85e:	8b 45 08             	mov    0x8(%ebp),%eax
  80e861:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80e864:	b8 00 00 00 00       	mov    $0x0,%eax
  80e869:	5d                   	pop    %ebp
  80e86a:	c3                   	ret    

0080e86b <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e86b:	55                   	push   %ebp
  80e86c:	89 e5                	mov    %esp,%ebp
  80e86e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e871:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e874:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e877:	8b 55 10             	mov    0x10(%ebp),%edx
  80e87a:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e87d:	5d                   	pop    %ebp
  80e87e:	c3                   	ret    

0080e87f <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80e87f:	55                   	push   %ebp
  80e880:	89 e5                	mov    %esp,%ebp
  80e882:	57                   	push   %edi
  80e883:	56                   	push   %esi
  80e884:	53                   	push   %ebx
  80e885:	83 ec 2c             	sub    $0x2c,%esp
  80e888:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e88b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80e88e:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80e895:	00 
  80e896:	89 3c 24             	mov    %edi,(%esp)
  80e899:	e8 52 64 ff ff       	call   804cf0 <pbuf_header>
  80e89e:	84 c0                	test   %al,%al
  80e8a0:	74 43                	je     80e8e5 <raw_sendto+0x66>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80e8a2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e8a9:	00 
  80e8aa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e8b1:	00 
  80e8b2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80e8b9:	e8 f7 65 ff ff       	call   804eb5 <pbuf_alloc>
  80e8be:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80e8c0:	85 c0                	test   %eax,%eax
  80e8c2:	0f 84 b8 00 00 00    	je     80e980 <raw_sendto+0x101>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e8c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80e8cc:	89 04 24             	mov    %eax,(%esp)
  80e8cf:	e8 36 6a ff ff       	call   80530a <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e8d4:	8b 45 10             	mov    0x10(%ebp),%eax
  80e8d7:	89 04 24             	mov    %eax,(%esp)
  80e8da:	e8 e1 81 ff ff       	call   806ac0 <ip_route>
  80e8df:	85 c0                	test   %eax,%eax
  80e8e1:	75 4e                	jne    80e931 <raw_sendto+0xb2>
  80e8e3:	eb 34                	jmp    80e919 <raw_sendto+0x9a>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80e8e5:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80e8ec:	ff 
  80e8ed:	89 3c 24             	mov    %edi,(%esp)
  80e8f0:	e8 fb 63 ff ff       	call   804cf0 <pbuf_header>
  80e8f5:	84 c0                	test   %al,%al
  80e8f7:	0f 84 91 00 00 00    	je     80e98e <raw_sendto+0x10f>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e8fd:	c7 44 24 08 d4 43 81 	movl   $0x8143d4,0x8(%esp)
  80e904:	00 
  80e905:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80e90c:	00 
  80e90d:	c7 04 24 fa 43 81 00 	movl   $0x8143fa,(%esp)
  80e914:	e8 21 07 00 00       	call   80f03a <_panic>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80e919:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e91e:	39 f7                	cmp    %esi,%edi
  80e920:	74 7f                	je     80e9a1 <raw_sendto+0x122>
      pbuf_free(q);
  80e922:	89 34 24             	mov    %esi,(%esp)
  80e925:	e8 aa 64 ff ff       	call   804dd4 <pbuf_free>
    }
    return ERR_RTE;
  80e92a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80e92f:	eb 70                	jmp    80e9a1 <raw_sendto+0x122>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e931:	89 da                	mov    %ebx,%edx
  80e933:	85 db                	test   %ebx,%ebx
  80e935:	74 05                	je     80e93c <raw_sendto+0xbd>
  80e937:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e93a:	75 03                	jne    80e93f <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e93c:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e93f:	89 44 24 18          	mov    %eax,0x18(%esp)
  80e943:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e947:	89 44 24 14          	mov    %eax,0x14(%esp)
  80e94b:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e94f:	89 44 24 10          	mov    %eax,0x10(%esp)
  80e953:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e957:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80e95b:	8b 45 10             	mov    0x10(%ebp),%eax
  80e95e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e962:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e966:	89 34 24             	mov    %esi,(%esp)
  80e969:	e8 90 84 ff ff       	call   806dfe <ip_output_if>
  80e96e:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e970:	39 fe                	cmp    %edi,%esi
  80e972:	74 2d                	je     80e9a1 <raw_sendto+0x122>
    /* free the header */
    pbuf_free(q);
  80e974:	89 34 24             	mov    %esi,(%esp)
  80e977:	e8 58 64 ff ff       	call   804dd4 <pbuf_free>
  }
  return err;
  80e97c:	89 d8                	mov    %ebx,%eax
  80e97e:	eb 21                	jmp    80e9a1 <raw_sendto+0x122>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80e980:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80e985:	eb 1a                	jmp    80e9a1 <raw_sendto+0x122>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80e987:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80e98c:	eb 13                	jmp    80e9a1 <raw_sendto+0x122>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e98e:	8b 45 10             	mov    0x10(%ebp),%eax
  80e991:	89 04 24             	mov    %eax,(%esp)
  80e994:	e8 27 81 ff ff       	call   806ac0 <ip_route>
  80e999:	85 c0                	test   %eax,%eax
  80e99b:	74 ea                	je     80e987 <raw_sendto+0x108>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80e99d:	89 fe                	mov    %edi,%esi
  80e99f:	eb 90                	jmp    80e931 <raw_sendto+0xb2>
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80e9a1:	83 c4 2c             	add    $0x2c,%esp
  80e9a4:	5b                   	pop    %ebx
  80e9a5:	5e                   	pop    %esi
  80e9a6:	5f                   	pop    %edi
  80e9a7:	5d                   	pop    %ebp
  80e9a8:	c3                   	ret    

0080e9a9 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e9a9:	55                   	push   %ebp
  80e9aa:	89 e5                	mov    %esp,%ebp
  80e9ac:	83 ec 18             	sub    $0x18,%esp
  80e9af:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e9b2:	8d 50 04             	lea    0x4(%eax),%edx
  80e9b5:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e9b9:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e9bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e9c0:	89 04 24             	mov    %eax,(%esp)
  80e9c3:	e8 b7 fe ff ff       	call   80e87f <raw_sendto>
}
  80e9c8:	c9                   	leave  
  80e9c9:	c3                   	ret    

0080e9ca <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e9ca:	55                   	push   %ebp
  80e9cb:	89 e5                	mov    %esp,%ebp
  80e9cd:	83 ec 18             	sub    $0x18,%esp
  80e9d0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e9d3:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80e9d8:	39 c8                	cmp    %ecx,%eax
  80e9da:	75 1e                	jne    80e9fa <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e9dc:	8b 40 0c             	mov    0xc(%eax),%eax
  80e9df:	a3 e8 c1 b3 00       	mov    %eax,0xb3c1e8
  80e9e4:	eb 18                	jmp    80e9fe <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e9e6:	8b 50 0c             	mov    0xc(%eax),%edx
  80e9e9:	85 d2                	test   %edx,%edx
  80e9eb:	74 0a                	je     80e9f7 <raw_remove+0x2d>
  80e9ed:	39 d1                	cmp    %edx,%ecx
  80e9ef:	75 06                	jne    80e9f7 <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80e9f1:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e9f4:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e9f7:	8b 40 0c             	mov    0xc(%eax),%eax
  80e9fa:	85 c0                	test   %eax,%eax
  80e9fc:	75 e8                	jne    80e9e6 <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e9fe:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80ea02:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ea09:	e8 14 60 ff ff       	call   804a22 <memp_free>
}
  80ea0e:	c9                   	leave  
  80ea0f:	c3                   	ret    

0080ea10 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80ea10:	55                   	push   %ebp
  80ea11:	89 e5                	mov    %esp,%ebp
  80ea13:	56                   	push   %esi
  80ea14:	53                   	push   %ebx
  80ea15:	83 ec 10             	sub    $0x10,%esp
  80ea18:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80ea1b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ea22:	e8 9b 5f ff ff       	call   8049c2 <memp_malloc>
  80ea27:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80ea29:	85 c0                	test   %eax,%eax
  80ea2b:	74 2f                	je     80ea5c <raw_new+0x4c>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80ea2d:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ea34:	00 
  80ea35:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ea3c:	00 
  80ea3d:	89 04 24             	mov    %eax,(%esp)
  80ea40:	e8 b2 0e 00 00       	call   80f8f7 <memset>
    pcb->protocol = proto;
  80ea45:	89 f0                	mov    %esi,%eax
  80ea47:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80ea4a:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80ea4e:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80ea53:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80ea56:	89 1d e8 c1 b3 00    	mov    %ebx,0xb3c1e8
  }
  return pcb;
}
  80ea5c:	89 d8                	mov    %ebx,%eax
  80ea5e:	83 c4 10             	add    $0x10,%esp
  80ea61:	5b                   	pop    %ebx
  80ea62:	5e                   	pop    %esi
  80ea63:	5d                   	pop    %ebp
  80ea64:	c3                   	ret    
  80ea65:	66 90                	xchg   %ax,%ax
  80ea67:	66 90                	xchg   %ax,%ax
  80ea69:	66 90                	xchg   %ax,%ax
  80ea6b:	66 90                	xchg   %ax,%ax
  80ea6d:	66 90                	xchg   %ax,%ax
  80ea6f:	90                   	nop

0080ea70 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80ea70:	55                   	push   %ebp
  80ea71:	89 e5                	mov    %esp,%ebp
  80ea73:	57                   	push   %edi
  80ea74:	56                   	push   %esi
  80ea75:	53                   	push   %ebx
  80ea76:	83 ec 3c             	sub    $0x3c,%esp
  80ea79:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80ea7c:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  80ea7f:	0f b7 06             	movzwl (%esi),%eax
  80ea82:	89 04 24             	mov    %eax,(%esp)
  80ea85:	e8 c9 92 ff ff       	call   807d53 <ntohs>
  80ea8a:	66 c1 e8 06          	shr    $0x6,%ax
  80ea8e:	83 e0 3c             	and    $0x3c,%eax
  80ea91:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80ea95:	89 c7                	mov    %eax,%edi
  80ea97:	f7 df                	neg    %edi
  80ea99:	0f bf ff             	movswl %di,%edi
  80ea9c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80eaa0:	89 1c 24             	mov    %ebx,(%esp)
  80eaa3:	e8 48 62 ff ff       	call   804cf0 <pbuf_header>
  80eaa8:	84 c0                	test   %al,%al
  80eaaa:	0f 85 eb 02 00 00    	jne    80ed9b <icmp_input+0x32b>
  80eab0:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80eab5:	0f 86 e0 02 00 00    	jbe    80ed9b <icmp_input+0x32b>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80eabb:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80eabe:	80 38 08             	cmpb   $0x8,(%eax)
  80eac1:	0f 85 ca 02 00 00    	jne    80ed91 <icmp_input+0x321>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80eac7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80eaca:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eace:	8d 46 10             	lea    0x10(%esi),%eax
  80ead1:	89 04 24             	mov    %eax,(%esp)
  80ead4:	e8 98 7f ff ff       	call   806a71 <ip_addr_isbroadcast>
  80ead9:	84 c0                	test   %al,%al
  80eadb:	75 29                	jne    80eb06 <icmp_input+0x96>
  80eadd:	8b 46 10             	mov    0x10(%esi),%eax
  80eae0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eae3:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80eaea:	e8 ab 94 ff ff       	call   807f9a <ntohl>
  80eaef:	23 45 e0             	and    -0x20(%ebp),%eax
  80eaf2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eaf5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80eafc:	e8 99 94 ff ff       	call   807f9a <ntohl>
  80eb01:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80eb04:	75 0f                	jne    80eb15 <icmp_input+0xa5>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80eb06:	89 1c 24             	mov    %ebx,(%esp)
  80eb09:	e8 c6 62 ff ff       	call   804dd4 <pbuf_free>
      return;
  80eb0e:	66 90                	xchg   %ax,%ax
  80eb10:	e9 98 02 00 00       	jmp    80edad <icmp_input+0x33d>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80eb15:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80eb1a:	0f 86 7b 02 00 00    	jbe    80ed9b <icmp_input+0x32b>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80eb20:	89 1c 24             	mov    %ebx,(%esp)
  80eb23:	e8 e6 90 ff ff       	call   807c0e <inet_chksum_pbuf>
  80eb28:	66 85 c0             	test   %ax,%ax
  80eb2b:	74 0d                	je     80eb3a <icmp_input+0xca>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80eb2d:	89 1c 24             	mov    %ebx,(%esp)
  80eb30:	e8 9f 62 ff ff       	call   804dd4 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80eb35:	e9 73 02 00 00       	jmp    80edad <icmp_input+0x33d>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80eb3a:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  80eb41:	00 
  80eb42:	89 1c 24             	mov    %ebx,(%esp)
  80eb45:	e8 a6 61 ff ff       	call   804cf0 <pbuf_header>
  80eb4a:	84 c0                	test   %al,%al
  80eb4c:	0f 84 f0 00 00 00    	je     80ec42 <icmp_input+0x1d2>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80eb52:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80eb56:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eb5a:	89 1c 24             	mov    %ebx,(%esp)
  80eb5d:	e8 8e 61 ff ff       	call   804cf0 <pbuf_header>
  80eb62:	84 c0                	test   %al,%al
  80eb64:	74 1c                	je     80eb82 <icmp_input+0x112>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80eb66:	c7 44 24 08 10 44 81 	movl   $0x814410,0x8(%esp)
  80eb6d:	00 
  80eb6e:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  80eb75:	00 
  80eb76:	c7 04 24 04 45 81 00 	movl   $0x814504,(%esp)
  80eb7d:	e8 b8 04 00 00       	call   80f03a <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80eb82:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80eb86:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eb8d:	00 
  80eb8e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eb92:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80eb99:	e8 17 63 ff ff       	call   804eb5 <pbuf_alloc>
  80eb9e:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80eba1:	85 c0                	test   %eax,%eax
  80eba3:	0f 84 fc 01 00 00    	je     80eda5 <icmp_input+0x335>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80eba9:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80ebad:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80ebb1:	83 c0 08             	add    $0x8,%eax
  80ebb4:	39 c2                	cmp    %eax,%edx
  80ebb6:	73 1c                	jae    80ebd4 <icmp_input+0x164>
  80ebb8:	c7 44 24 08 44 44 81 	movl   $0x814444,0x8(%esp)
  80ebbf:	00 
  80ebc0:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  80ebc7:	00 
  80ebc8:	c7 04 24 04 45 81 00 	movl   $0x814504,(%esp)
  80ebcf:	e8 66 04 00 00       	call   80f03a <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80ebd4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ebd8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ebdb:	89 04 24             	mov    %eax,(%esp)
  80ebde:	e8 01 68 ff ff       	call   8053e4 <pbuf_copy>
  80ebe3:	84 c0                	test   %al,%al
  80ebe5:	74 1c                	je     80ec03 <icmp_input+0x193>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80ebe7:	c7 44 24 08 7c 44 81 	movl   $0x81447c,0x8(%esp)
  80ebee:	00 
  80ebef:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  80ebf6:	00 
  80ebf7:	c7 04 24 04 45 81 00 	movl   $0x814504,(%esp)
  80ebfe:	e8 37 04 00 00       	call   80f03a <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80ec03:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ec06:	8b 70 04             	mov    0x4(%eax),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80ec09:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ec0d:	89 04 24             	mov    %eax,(%esp)
  80ec10:	e8 db 60 ff ff       	call   804cf0 <pbuf_header>
  80ec15:	84 c0                	test   %al,%al
  80ec17:	74 1c                	je     80ec35 <icmp_input+0x1c5>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ec19:	c7 44 24 08 a4 44 81 	movl   $0x8144a4,0x8(%esp)
  80ec20:	00 
  80ec21:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80ec28:	00 
  80ec29:	c7 04 24 04 45 81 00 	movl   $0x814504,(%esp)
  80ec30:	e8 05 04 00 00       	call   80f03a <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80ec35:	89 1c 24             	mov    %ebx,(%esp)
  80ec38:	e8 97 61 ff ff       	call   804dd4 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80ec3d:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80ec40:	eb 30                	jmp    80ec72 <icmp_input+0x202>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80ec42:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  80ec49:	ff 
  80ec4a:	89 1c 24             	mov    %ebx,(%esp)
  80ec4d:	e8 9e 60 ff ff       	call   804cf0 <pbuf_header>
  80ec52:	84 c0                	test   %al,%al
  80ec54:	74 1c                	je     80ec72 <icmp_input+0x202>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ec56:	c7 44 24 08 a4 44 81 	movl   $0x8144a4,0x8(%esp)
  80ec5d:	00 
  80ec5e:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80ec65:	00 
  80ec66:	c7 04 24 04 45 81 00 	movl   $0x814504,(%esp)
  80ec6d:	e8 c8 03 00 00       	call   80f03a <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80ec72:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  80ec75:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80ec78:	8b 56 10             	mov    0x10(%esi),%edx
  80ec7b:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  80ec7e:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80ec81:	0f b7 07             	movzwl (%edi),%eax
  80ec84:	89 04 24             	mov    %eax,(%esp)
  80ec87:	e8 c7 90 ff ff       	call   807d53 <ntohs>
  80ec8c:	0f b6 c0             	movzbl %al,%eax
  80ec8f:	89 04 24             	mov    %eax,(%esp)
  80ec92:	e8 af 90 ff ff       	call   807d46 <htons>
  80ec97:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80ec9a:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80ec9e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80eca2:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80eca9:	e8 98 90 ff ff       	call   807d46 <htons>
  80ecae:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80ecb2:	72 22                	jb     80ecd6 <icmp_input+0x266>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80ecb4:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80ecb8:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80ecbc:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80ecc3:	e8 7e 90 ff ff       	call   807d46 <htons>
  80ecc8:	0f b7 4d e0          	movzwl -0x20(%ebp),%ecx
  80eccc:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
  80ecd0:	66 89 47 02          	mov    %ax,0x2(%edi)
  80ecd4:	eb 1c                	jmp    80ecf2 <icmp_input+0x282>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80ecd6:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80ecda:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80ecde:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80ece5:	e8 5c 90 ff ff       	call   807d46 <htons>
  80ecea:	66 03 45 e0          	add    -0x20(%ebp),%ax
  80ecee:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80ecf2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80ecf6:	89 04 24             	mov    %eax,(%esp)
  80ecf9:	e8 55 90 ff ff       	call   807d53 <ntohs>
  80ecfe:	66 0d 00 ff          	or     $0xff00,%ax
  80ed02:	0f b7 c0             	movzwl %ax,%eax
  80ed05:	89 04 24             	mov    %eax,(%esp)
  80ed08:	e8 39 90 ff ff       	call   807d46 <htons>
  80ed0d:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  80ed11:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80ed17:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80ed1e:	00 
  80ed1f:	89 34 24             	mov    %esi,(%esp)
  80ed22:	e8 d1 8e ff ff       	call   807bf8 <inet_chksum>
  80ed27:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80ed2b:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80ed2f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ed33:	89 1c 24             	mov    %ebx,(%esp)
  80ed36:	e8 b5 5f ff ff       	call   804cf0 <pbuf_header>
  80ed3b:	84 c0                	test   %al,%al
  80ed3d:	74 1c                	je     80ed5b <icmp_input+0x2eb>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80ed3f:	c7 44 24 08 70 35 81 	movl   $0x813570,0x8(%esp)
  80ed46:	00 
  80ed47:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  80ed4e:	00 
  80ed4f:	c7 04 24 04 45 81 00 	movl   $0x814504,(%esp)
  80ed56:	e8 df 02 00 00       	call   80f03a <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80ed5b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ed5e:	89 44 24 18          	mov    %eax,0x18(%esp)
  80ed62:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80ed69:	00 
  80ed6a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ed71:	00 
  80ed72:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ed79:	00 
  80ed7a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ed81:	00 
  80ed82:	83 c6 0c             	add    $0xc,%esi
  80ed85:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ed89:	89 1c 24             	mov    %ebx,(%esp)
  80ed8c:	e8 6d 80 ff ff       	call   806dfe <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80ed91:	89 1c 24             	mov    %ebx,(%esp)
  80ed94:	e8 3b 60 ff ff       	call   804dd4 <pbuf_free>
  return;
  80ed99:	eb 12                	jmp    80edad <icmp_input+0x33d>
lenerr:
  pbuf_free(p);
  80ed9b:	89 1c 24             	mov    %ebx,(%esp)
  80ed9e:	e8 31 60 ff ff       	call   804dd4 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80eda3:	eb 08                	jmp    80edad <icmp_input+0x33d>
memerr:
  pbuf_free(p);
  80eda5:	89 1c 24             	mov    %ebx,(%esp)
  80eda8:	e8 27 60 ff ff       	call   804dd4 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80edad:	83 c4 3c             	add    $0x3c,%esp
  80edb0:	5b                   	pop    %ebx
  80edb1:	5e                   	pop    %esi
  80edb2:	5f                   	pop    %edi
  80edb3:	5d                   	pop    %ebp
  80edb4:	c3                   	ret    

0080edb5 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80edb5:	55                   	push   %ebp
  80edb6:	89 e5                	mov    %esp,%ebp
  80edb8:	57                   	push   %edi
  80edb9:	56                   	push   %esi
  80edba:	53                   	push   %ebx
  80edbb:	83 ec 2c             	sub    $0x2c,%esp
  80edbe:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80edc1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80edc8:	00 
  80edc9:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80edd0:	00 
  80edd1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80edd8:	e8 d8 60 ff ff       	call   804eb5 <pbuf_alloc>
  80eddd:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80eddf:	85 c0                	test   %eax,%eax
  80ede1:	0f 84 d8 00 00 00    	je     80eebf <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ede7:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80edec:	77 1c                	ja     80ee0a <icmp_dest_unreach+0x55>
  80edee:	c7 44 24 08 d8 44 81 	movl   $0x8144d8,0x8(%esp)
  80edf5:	00 
  80edf6:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  80edfd:	00 
  80edfe:	c7 04 24 04 45 81 00 	movl   $0x814504,(%esp)
  80ee05:	e8 30 02 00 00       	call   80f03a <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ee0a:	8b 47 04             	mov    0x4(%edi),%eax
  80ee0d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  80ee10:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80ee13:	0f b7 06             	movzwl (%esi),%eax
  80ee16:	89 04 24             	mov    %eax,(%esp)
  80ee19:	e8 35 8f ff ff       	call   807d53 <ntohs>
  80ee1e:	0f b6 c0             	movzbl %al,%eax
  80ee21:	80 cc 03             	or     $0x3,%ah
  80ee24:	89 04 24             	mov    %eax,(%esp)
  80ee27:	e8 1a 8f ff ff       	call   807d46 <htons>
  80ee2c:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80ee2f:	0f b7 c0             	movzwl %ax,%eax
  80ee32:	89 04 24             	mov    %eax,(%esp)
  80ee35:	e8 19 8f ff ff       	call   807d53 <ntohs>
  80ee3a:	b0 00                	mov    $0x0,%al
  80ee3c:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80ee40:	0f b7 c0             	movzwl %ax,%eax
  80ee43:	89 04 24             	mov    %eax,(%esp)
  80ee46:	e8 fb 8e ff ff       	call   807d46 <htons>
  80ee4b:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80ee4e:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ee55:	00 
  80ee56:	8b 47 04             	mov    0x4(%edi),%eax
  80ee59:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ee5d:	8b 53 04             	mov    0x4(%ebx),%edx
  80ee60:	8d 42 08             	lea    0x8(%edx),%eax
  80ee63:	89 04 24             	mov    %eax,(%esp)
  80ee66:	e8 41 0b 00 00       	call   80f9ac <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80ee6b:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80ee71:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ee75:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ee79:	89 34 24             	mov    %esi,(%esp)
  80ee7c:	e8 77 8d ff ff       	call   807bf8 <inet_chksum>
  80ee81:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80ee85:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80ee8c:	00 
  80ee8d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ee94:	00 
  80ee95:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ee9c:	00 
  80ee9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80eea0:	83 c0 0c             	add    $0xc,%eax
  80eea3:	89 44 24 08          	mov    %eax,0x8(%esp)
  80eea7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eeae:	00 
  80eeaf:	89 1c 24             	mov    %ebx,(%esp)
  80eeb2:	e8 d9 80 ff ff       	call   806f90 <ip_output>
  pbuf_free(q);
  80eeb7:	89 1c 24             	mov    %ebx,(%esp)
  80eeba:	e8 15 5f ff ff       	call   804dd4 <pbuf_free>
}
  80eebf:	83 c4 2c             	add    $0x2c,%esp
  80eec2:	5b                   	pop    %ebx
  80eec3:	5e                   	pop    %esi
  80eec4:	5f                   	pop    %edi
  80eec5:	5d                   	pop    %ebp
  80eec6:	c3                   	ret    

0080eec7 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80eec7:	55                   	push   %ebp
  80eec8:	89 e5                	mov    %esp,%ebp
  80eeca:	57                   	push   %edi
  80eecb:	56                   	push   %esi
  80eecc:	53                   	push   %ebx
  80eecd:	83 ec 2c             	sub    $0x2c,%esp
  80eed0:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80eed3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eeda:	00 
  80eedb:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80eee2:	00 
  80eee3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80eeea:	e8 c6 5f ff ff       	call   804eb5 <pbuf_alloc>
  80eeef:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80eef1:	85 c0                	test   %eax,%eax
  80eef3:	0f 84 d8 00 00 00    	je     80efd1 <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80eef9:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80eefe:	77 1c                	ja     80ef1c <icmp_time_exceeded+0x55>
  80ef00:	c7 44 24 08 d8 44 81 	movl   $0x8144d8,0x8(%esp)
  80ef07:	00 
  80ef08:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  80ef0f:	00 
  80ef10:	c7 04 24 04 45 81 00 	movl   $0x814504,(%esp)
  80ef17:	e8 1e 01 00 00       	call   80f03a <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ef1c:	8b 47 04             	mov    0x4(%edi),%eax
  80ef1f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80ef22:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80ef25:	0f b7 06             	movzwl (%esi),%eax
  80ef28:	89 04 24             	mov    %eax,(%esp)
  80ef2b:	e8 23 8e ff ff       	call   807d53 <ntohs>
  80ef30:	0f b6 c0             	movzbl %al,%eax
  80ef33:	80 cc 0b             	or     $0xb,%ah
  80ef36:	89 04 24             	mov    %eax,(%esp)
  80ef39:	e8 08 8e ff ff       	call   807d46 <htons>
  80ef3e:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80ef41:	0f b7 c0             	movzwl %ax,%eax
  80ef44:	89 04 24             	mov    %eax,(%esp)
  80ef47:	e8 07 8e ff ff       	call   807d53 <ntohs>
  80ef4c:	b0 00                	mov    $0x0,%al
  80ef4e:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80ef52:	0f b7 c0             	movzwl %ax,%eax
  80ef55:	89 04 24             	mov    %eax,(%esp)
  80ef58:	e8 e9 8d ff ff       	call   807d46 <htons>
  80ef5d:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80ef60:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ef67:	00 
  80ef68:	8b 47 04             	mov    0x4(%edi),%eax
  80ef6b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef6f:	8b 53 04             	mov    0x4(%ebx),%edx
  80ef72:	8d 42 08             	lea    0x8(%edx),%eax
  80ef75:	89 04 24             	mov    %eax,(%esp)
  80ef78:	e8 2f 0a 00 00       	call   80f9ac <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80ef7d:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80ef83:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ef87:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef8b:	89 34 24             	mov    %esi,(%esp)
  80ef8e:	e8 65 8c ff ff       	call   807bf8 <inet_chksum>
  80ef93:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80ef97:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80ef9e:	00 
  80ef9f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80efa6:	00 
  80efa7:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80efae:	00 
  80efaf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80efb2:	83 c0 0c             	add    $0xc,%eax
  80efb5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80efb9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80efc0:	00 
  80efc1:	89 1c 24             	mov    %ebx,(%esp)
  80efc4:	e8 c7 7f ff ff       	call   806f90 <ip_output>
  pbuf_free(q);
  80efc9:	89 1c 24             	mov    %ebx,(%esp)
  80efcc:	e8 03 5e ff ff       	call   804dd4 <pbuf_free>
}
  80efd1:	83 c4 2c             	add    $0x2c,%esp
  80efd4:	5b                   	pop    %ebx
  80efd5:	5e                   	pop    %esi
  80efd6:	5f                   	pop    %edi
  80efd7:	5d                   	pop    %ebp
  80efd8:	c3                   	ret    

0080efd9 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80efd9:	55                   	push   %ebp
  80efda:	89 e5                	mov    %esp,%ebp
  80efdc:	56                   	push   %esi
  80efdd:	53                   	push   %ebx
  80efde:	83 ec 10             	sub    $0x10,%esp
  80efe1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80efe4:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.

	//envid_t envid = sys_getenvid();
	thisenv = &envs[ENVX(sys_getenvid())];
  80efe7:	e8 eb 0b 00 00       	call   80fbd7 <sys_getenvid>
  80efec:	25 ff 03 00 00       	and    $0x3ff,%eax
  80eff1:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80eff4:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80eff9:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80effe:	85 db                	test   %ebx,%ebx
  80f000:	7e 07                	jle    80f009 <libmain+0x30>
		binaryname = argv[0];
  80f002:	8b 06                	mov    (%esi),%eax
  80f004:	a3 e8 52 81 00       	mov    %eax,0x8152e8

	// call user main routine
	umain(argc, argv);
  80f009:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f00d:	89 1c 24             	mov    %ebx,(%esp)
  80f010:	e8 3a 16 ff ff       	call   80064f <umain>

	// exit gracefully
	exit();
  80f015:	e8 07 00 00 00       	call   80f021 <exit>
}
  80f01a:	83 c4 10             	add    $0x10,%esp
  80f01d:	5b                   	pop    %ebx
  80f01e:	5e                   	pop    %esi
  80f01f:	5d                   	pop    %ebp
  80f020:	c3                   	ret    

0080f021 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80f021:	55                   	push   %ebp
  80f022:	89 e5                	mov    %esp,%ebp
  80f024:	83 ec 18             	sub    $0x18,%esp
	close_all();
  80f027:	e8 8e 17 00 00       	call   8107ba <close_all>
	sys_env_destroy(0);
  80f02c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f033:	e8 fb 0a 00 00       	call   80fb33 <sys_env_destroy>
}
  80f038:	c9                   	leave  
  80f039:	c3                   	ret    

0080f03a <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80f03a:	55                   	push   %ebp
  80f03b:	89 e5                	mov    %esp,%ebp
  80f03d:	56                   	push   %esi
  80f03e:	53                   	push   %ebx
  80f03f:	83 ec 20             	sub    $0x20,%esp
	va_list ap;

	va_start(ap, fmt);
  80f042:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80f045:	8b 35 e8 52 81 00    	mov    0x8152e8,%esi
  80f04b:	e8 87 0b 00 00       	call   80fbd7 <sys_getenvid>
  80f050:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f053:	89 54 24 10          	mov    %edx,0x10(%esp)
  80f057:	8b 55 08             	mov    0x8(%ebp),%edx
  80f05a:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f05e:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f062:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f066:	c7 04 24 28 45 81 00 	movl   $0x814528,(%esp)
  80f06d:	e8 c1 00 00 00       	call   80f133 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80f072:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f076:	8b 45 10             	mov    0x10(%ebp),%eax
  80f079:	89 04 24             	mov    %eax,(%esp)
  80f07c:	e8 51 00 00 00       	call   80f0d2 <vcprintf>
	cprintf("\n");
  80f081:	c7 04 24 e8 20 81 00 	movl   $0x8120e8,(%esp)
  80f088:	e8 a6 00 00 00       	call   80f133 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80f08d:	cc                   	int3   
  80f08e:	eb fd                	jmp    80f08d <_panic+0x53>

0080f090 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80f090:	55                   	push   %ebp
  80f091:	89 e5                	mov    %esp,%ebp
  80f093:	53                   	push   %ebx
  80f094:	83 ec 14             	sub    $0x14,%esp
  80f097:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80f09a:	8b 13                	mov    (%ebx),%edx
  80f09c:	8d 42 01             	lea    0x1(%edx),%eax
  80f09f:	89 03                	mov    %eax,(%ebx)
  80f0a1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f0a4:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80f0a8:	3d ff 00 00 00       	cmp    $0xff,%eax
  80f0ad:	75 19                	jne    80f0c8 <putch+0x38>
		sys_cputs(b->buf, b->idx);
  80f0af:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80f0b6:	00 
  80f0b7:	8d 43 08             	lea    0x8(%ebx),%eax
  80f0ba:	89 04 24             	mov    %eax,(%esp)
  80f0bd:	e8 34 0a 00 00       	call   80faf6 <sys_cputs>
		b->idx = 0;
  80f0c2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  80f0c8:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80f0cc:	83 c4 14             	add    $0x14,%esp
  80f0cf:	5b                   	pop    %ebx
  80f0d0:	5d                   	pop    %ebp
  80f0d1:	c3                   	ret    

0080f0d2 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80f0d2:	55                   	push   %ebp
  80f0d3:	89 e5                	mov    %esp,%ebp
  80f0d5:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  80f0db:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80f0e2:	00 00 00 
	b.cnt = 0;
  80f0e5:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80f0ec:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80f0ef:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f0f2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f0f6:	8b 45 08             	mov    0x8(%ebp),%eax
  80f0f9:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f0fd:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80f103:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f107:	c7 04 24 90 f0 80 00 	movl   $0x80f090,(%esp)
  80f10e:	e8 71 01 00 00       	call   80f284 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80f113:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  80f119:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f11d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80f123:	89 04 24             	mov    %eax,(%esp)
  80f126:	e8 cb 09 00 00       	call   80faf6 <sys_cputs>

	return b.cnt;
}
  80f12b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80f131:	c9                   	leave  
  80f132:	c3                   	ret    

0080f133 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80f133:	55                   	push   %ebp
  80f134:	89 e5                	mov    %esp,%ebp
  80f136:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80f139:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80f13c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f140:	8b 45 08             	mov    0x8(%ebp),%eax
  80f143:	89 04 24             	mov    %eax,(%esp)
  80f146:	e8 87 ff ff ff       	call   80f0d2 <vcprintf>
	va_end(ap);

	return cnt;
}
  80f14b:	c9                   	leave  
  80f14c:	c3                   	ret    
  80f14d:	66 90                	xchg   %ax,%ax
  80f14f:	90                   	nop

0080f150 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80f150:	55                   	push   %ebp
  80f151:	89 e5                	mov    %esp,%ebp
  80f153:	57                   	push   %edi
  80f154:	56                   	push   %esi
  80f155:	53                   	push   %ebx
  80f156:	83 ec 3c             	sub    $0x3c,%esp
  80f159:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f15c:	89 d7                	mov    %edx,%edi
  80f15e:	8b 45 08             	mov    0x8(%ebp),%eax
  80f161:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80f164:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f167:	89 c3                	mov    %eax,%ebx
  80f169:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80f16c:	8b 45 10             	mov    0x10(%ebp),%eax
  80f16f:	8b 75 14             	mov    0x14(%ebp),%esi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80f172:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f177:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80f17a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80f17d:	39 d9                	cmp    %ebx,%ecx
  80f17f:	72 05                	jb     80f186 <printnum+0x36>
  80f181:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80f184:	77 69                	ja     80f1ef <printnum+0x9f>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80f186:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80f189:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  80f18d:	83 ee 01             	sub    $0x1,%esi
  80f190:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80f194:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f198:	8b 44 24 08          	mov    0x8(%esp),%eax
  80f19c:	8b 54 24 0c          	mov    0xc(%esp),%edx
  80f1a0:	89 c3                	mov    %eax,%ebx
  80f1a2:	89 d6                	mov    %edx,%esi
  80f1a4:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80f1a7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80f1aa:	89 54 24 08          	mov    %edx,0x8(%esp)
  80f1ae:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80f1b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f1b5:	89 04 24             	mov    %eax,(%esp)
  80f1b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80f1bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f1bf:	e8 0c 2b 00 00       	call   811cd0 <__udivdi3>
  80f1c4:	89 d9                	mov    %ebx,%ecx
  80f1c6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f1ca:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80f1ce:	89 04 24             	mov    %eax,(%esp)
  80f1d1:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f1d5:	89 fa                	mov    %edi,%edx
  80f1d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f1da:	e8 71 ff ff ff       	call   80f150 <printnum>
  80f1df:	eb 1b                	jmp    80f1fc <printnum+0xac>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80f1e1:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f1e5:	8b 45 18             	mov    0x18(%ebp),%eax
  80f1e8:	89 04 24             	mov    %eax,(%esp)
  80f1eb:	ff d3                	call   *%ebx
  80f1ed:	eb 03                	jmp    80f1f2 <printnum+0xa2>
  80f1ef:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80f1f2:	83 ee 01             	sub    $0x1,%esi
  80f1f5:	85 f6                	test   %esi,%esi
  80f1f7:	7f e8                	jg     80f1e1 <printnum+0x91>
  80f1f9:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80f1fc:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f200:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80f204:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80f207:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80f20a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f20e:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f212:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f215:	89 04 24             	mov    %eax,(%esp)
  80f218:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80f21b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f21f:	e8 dc 2b 00 00       	call   811e00 <__umoddi3>
  80f224:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f228:	0f be 80 4b 45 81 00 	movsbl 0x81454b(%eax),%eax
  80f22f:	89 04 24             	mov    %eax,(%esp)
  80f232:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f235:	ff d0                	call   *%eax
}
  80f237:	83 c4 3c             	add    $0x3c,%esp
  80f23a:	5b                   	pop    %ebx
  80f23b:	5e                   	pop    %esi
  80f23c:	5f                   	pop    %edi
  80f23d:	5d                   	pop    %ebp
  80f23e:	c3                   	ret    

0080f23f <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80f23f:	55                   	push   %ebp
  80f240:	89 e5                	mov    %esp,%ebp
  80f242:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80f245:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80f249:	8b 10                	mov    (%eax),%edx
  80f24b:	3b 50 04             	cmp    0x4(%eax),%edx
  80f24e:	73 0a                	jae    80f25a <sprintputch+0x1b>
		*b->buf++ = ch;
  80f250:	8d 4a 01             	lea    0x1(%edx),%ecx
  80f253:	89 08                	mov    %ecx,(%eax)
  80f255:	8b 45 08             	mov    0x8(%ebp),%eax
  80f258:	88 02                	mov    %al,(%edx)
}
  80f25a:	5d                   	pop    %ebp
  80f25b:	c3                   	ret    

0080f25c <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80f25c:	55                   	push   %ebp
  80f25d:	89 e5                	mov    %esp,%ebp
  80f25f:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
  80f262:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80f265:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f269:	8b 45 10             	mov    0x10(%ebp),%eax
  80f26c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f270:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f273:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f277:	8b 45 08             	mov    0x8(%ebp),%eax
  80f27a:	89 04 24             	mov    %eax,(%esp)
  80f27d:	e8 02 00 00 00       	call   80f284 <vprintfmt>
	va_end(ap);
}
  80f282:	c9                   	leave  
  80f283:	c3                   	ret    

0080f284 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80f284:	55                   	push   %ebp
  80f285:	89 e5                	mov    %esp,%ebp
  80f287:	57                   	push   %edi
  80f288:	56                   	push   %esi
  80f289:	53                   	push   %ebx
  80f28a:	83 ec 3c             	sub    $0x3c,%esp
  80f28d:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f290:	eb 17                	jmp    80f2a9 <vprintfmt+0x25>
	const char *colorIdx;
	int found=0;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) !='%') {
			if (ch == '\0')
  80f292:	85 c0                	test   %eax,%eax
  80f294:	0f 84 4b 04 00 00    	je     80f6e5 <vprintfmt+0x461>
				return;
			putch(ch, putdat);
  80f29a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f29d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80f2a1:	89 04 24             	mov    %eax,(%esp)
  80f2a4:	ff 55 08             	call   *0x8(%ebp)

	const char *colorIdx;
	int found=0;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) !='%') {
  80f2a7:	89 fb                	mov    %edi,%ebx
  80f2a9:	8d 7b 01             	lea    0x1(%ebx),%edi
  80f2ac:	0f b6 03             	movzbl (%ebx),%eax
  80f2af:	83 f8 25             	cmp    $0x25,%eax
  80f2b2:	75 de                	jne    80f292 <vprintfmt+0xe>
  80f2b4:	c6 45 dc 20          	movb   $0x20,-0x24(%ebp)
  80f2b8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80f2bf:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80f2c4:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
  80f2cb:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f2d0:	eb 18                	jmp    80f2ea <vprintfmt+0x66>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f2d2:	89 df                	mov    %ebx,%edi

		// flag to pad on the right
		case '-':
			padc = '-';
  80f2d4:	c6 45 dc 2d          	movb   $0x2d,-0x24(%ebp)
  80f2d8:	eb 10                	jmp    80f2ea <vprintfmt+0x66>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f2da:	89 df                	mov    %ebx,%edi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80f2dc:	c6 45 dc 30          	movb   $0x30,-0x24(%ebp)
  80f2e0:	eb 08                	jmp    80f2ea <vprintfmt+0x66>
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
  80f2e2:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80f2e5:	be ff ff ff ff       	mov    $0xffffffff,%esi
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f2ea:	8d 5f 01             	lea    0x1(%edi),%ebx
  80f2ed:	0f b6 17             	movzbl (%edi),%edx
  80f2f0:	0f b6 c2             	movzbl %dl,%eax
  80f2f3:	83 ea 23             	sub    $0x23,%edx
  80f2f6:	80 fa 55             	cmp    $0x55,%dl
  80f2f9:	0f 87 c2 03 00 00    	ja     80f6c1 <vprintfmt+0x43d>
  80f2ff:	0f b6 d2             	movzbl %dl,%edx
  80f302:	ff 24 95 80 46 81 00 	jmp    *0x814680(,%edx,4)
  80f309:	89 df                	mov    %ebx,%edi
  80f30b:	be 00 00 00 00       	mov    $0x0,%esi
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80f310:	8d 14 b6             	lea    (%esi,%esi,4),%edx
  80f313:	8d 74 50 d0          	lea    -0x30(%eax,%edx,2),%esi
				ch = *fmt;
  80f317:	0f be 07             	movsbl (%edi),%eax
				if (ch < '0' || ch > '9')
  80f31a:	8d 50 d0             	lea    -0x30(%eax),%edx
  80f31d:	83 fa 09             	cmp    $0x9,%edx
  80f320:	77 33                	ja     80f355 <vprintfmt+0xd1>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80f322:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80f325:	eb e9                	jmp    80f310 <vprintfmt+0x8c>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80f327:	8b 45 14             	mov    0x14(%ebp),%eax
  80f32a:	8b 30                	mov    (%eax),%esi
  80f32c:	8d 40 04             	lea    0x4(%eax),%eax
  80f32f:	89 45 14             	mov    %eax,0x14(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f332:	89 df                	mov    %ebx,%edi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80f334:	eb 1f                	jmp    80f355 <vprintfmt+0xd1>
  80f336:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80f339:	85 ff                	test   %edi,%edi
  80f33b:	b8 00 00 00 00       	mov    $0x0,%eax
  80f340:	0f 49 c7             	cmovns %edi,%eax
  80f343:	89 45 e0             	mov    %eax,-0x20(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f346:	89 df                	mov    %ebx,%edi
  80f348:	eb a0                	jmp    80f2ea <vprintfmt+0x66>
  80f34a:	89 df                	mov    %ebx,%edi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80f34c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			goto reswitch;
  80f353:	eb 95                	jmp    80f2ea <vprintfmt+0x66>

		process_precision:
			if (width < 0)
  80f355:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80f359:	79 8f                	jns    80f2ea <vprintfmt+0x66>
  80f35b:	eb 85                	jmp    80f2e2 <vprintfmt+0x5e>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80f35d:	83 c1 01             	add    $0x1,%ecx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f360:	89 df                	mov    %ebx,%edi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80f362:	eb 86                	jmp    80f2ea <vprintfmt+0x66>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80f364:	8b 45 14             	mov    0x14(%ebp),%eax
  80f367:	8d 70 04             	lea    0x4(%eax),%esi
  80f36a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f36d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f371:	8b 45 14             	mov    0x14(%ebp),%eax
  80f374:	8b 00                	mov    (%eax),%eax
  80f376:	89 04 24             	mov    %eax,(%esp)
  80f379:	ff 55 08             	call   *0x8(%ebp)
  80f37c:	89 75 14             	mov    %esi,0x14(%ebp)
			break;
  80f37f:	e9 25 ff ff ff       	jmp    80f2a9 <vprintfmt+0x25>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80f384:	8b 45 14             	mov    0x14(%ebp),%eax
  80f387:	8d 70 04             	lea    0x4(%eax),%esi
  80f38a:	8b 00                	mov    (%eax),%eax
  80f38c:	99                   	cltd   
  80f38d:	31 d0                	xor    %edx,%eax
  80f38f:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80f391:	83 f8 15             	cmp    $0x15,%eax
  80f394:	7f 0b                	jg     80f3a1 <vprintfmt+0x11d>
  80f396:	8b 14 85 e0 47 81 00 	mov    0x8147e0(,%eax,4),%edx
  80f39d:	85 d2                	test   %edx,%edx
  80f39f:	75 26                	jne    80f3c7 <vprintfmt+0x143>
				printfmt(putch, putdat, "error %d", err);
  80f3a1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f3a5:	c7 44 24 08 63 45 81 	movl   $0x814563,0x8(%esp)
  80f3ac:	00 
  80f3ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f3b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f3b4:	8b 45 08             	mov    0x8(%ebp),%eax
  80f3b7:	89 04 24             	mov    %eax,(%esp)
  80f3ba:	e8 9d fe ff ff       	call   80f25c <printfmt>
			putch(va_arg(ap, int), putdat);
			break;

		// error message
		case 'e':
			err = va_arg(ap, int);
  80f3bf:	89 75 14             	mov    %esi,0x14(%ebp)
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
  80f3c2:	e9 e2 fe ff ff       	jmp    80f2a9 <vprintfmt+0x25>
			else
				printfmt(putch, putdat, "%s", p);
  80f3c7:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f3cb:	c7 44 24 08 31 37 81 	movl   $0x813731,0x8(%esp)
  80f3d2:	00 
  80f3d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f3d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f3da:	8b 45 08             	mov    0x8(%ebp),%eax
  80f3dd:	89 04 24             	mov    %eax,(%esp)
  80f3e0:	e8 77 fe ff ff       	call   80f25c <printfmt>
			putch(va_arg(ap, int), putdat);
			break;

		// error message
		case 'e':
			err = va_arg(ap, int);
  80f3e5:	89 75 14             	mov    %esi,0x14(%ebp)
  80f3e8:	e9 bc fe ff ff       	jmp    80f2a9 <vprintfmt+0x25>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f3ed:	8b 45 14             	mov    0x14(%ebp),%eax
  80f3f0:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80f3f3:	89 4d d8             	mov    %ecx,-0x28(%ebp)
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80f3f6:	83 45 14 04          	addl   $0x4,0x14(%ebp)
  80f3fa:	8b 38                	mov    (%eax),%edi
				p = "(null)";
  80f3fc:	85 ff                	test   %edi,%edi
  80f3fe:	b8 5c 45 81 00       	mov    $0x81455c,%eax
  80f403:	0f 44 f8             	cmove  %eax,%edi
			if (width > 0 && padc != '-')
  80f406:	80 7d dc 2d          	cmpb   $0x2d,-0x24(%ebp)
  80f40a:	0f 84 94 00 00 00    	je     80f4a4 <vprintfmt+0x220>
  80f410:	85 c9                	test   %ecx,%ecx
  80f412:	0f 8e 94 00 00 00    	jle    80f4ac <vprintfmt+0x228>
				for (width -= strnlen(p, precision); width > 0; width--)
  80f418:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f41c:	89 3c 24             	mov    %edi,(%esp)
  80f41f:	e8 64 03 00 00       	call   80f788 <strnlen>
  80f424:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80f427:	29 c1                	sub    %eax,%ecx
  80f429:	89 4d e0             	mov    %ecx,-0x20(%ebp)
					putch(padc, putdat);
  80f42c:	0f be 45 dc          	movsbl -0x24(%ebp),%eax
  80f430:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80f433:	89 75 d8             	mov    %esi,-0x28(%ebp)
  80f436:	8b 75 08             	mov    0x8(%ebp),%esi
  80f439:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f43c:	89 cb                	mov    %ecx,%ebx
  80f43e:	89 c7                	mov    %eax,%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f440:	eb 0f                	jmp    80f451 <vprintfmt+0x1cd>
					putch(padc, putdat);
  80f442:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f445:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f449:	89 3c 24             	mov    %edi,(%esp)
  80f44c:	ff d6                	call   *%esi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f44e:	83 eb 01             	sub    $0x1,%ebx
  80f451:	85 db                	test   %ebx,%ebx
  80f453:	7f ed                	jg     80f442 <vprintfmt+0x1be>
  80f455:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80f458:	8b 75 d8             	mov    -0x28(%ebp),%esi
  80f45b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80f45e:	85 c9                	test   %ecx,%ecx
  80f460:	b8 00 00 00 00       	mov    $0x0,%eax
  80f465:	0f 49 c1             	cmovns %ecx,%eax
  80f468:	29 c1                	sub    %eax,%ecx
  80f46a:	89 cb                	mov    %ecx,%ebx
  80f46c:	eb 44                	jmp    80f4b2 <vprintfmt+0x22e>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80f46e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f472:	74 1e                	je     80f492 <vprintfmt+0x20e>
  80f474:	0f be d2             	movsbl %dl,%edx
  80f477:	83 ea 20             	sub    $0x20,%edx
  80f47a:	83 fa 5e             	cmp    $0x5e,%edx
  80f47d:	76 13                	jbe    80f492 <vprintfmt+0x20e>
					putch('?', putdat);
  80f47f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f482:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f486:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  80f48d:	ff 55 08             	call   *0x8(%ebp)
  80f490:	eb 0d                	jmp    80f49f <vprintfmt+0x21b>
				else
					putch(ch, putdat);
  80f492:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f495:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80f499:	89 04 24             	mov    %eax,(%esp)
  80f49c:	ff 55 08             	call   *0x8(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80f49f:	83 eb 01             	sub    $0x1,%ebx
  80f4a2:	eb 0e                	jmp    80f4b2 <vprintfmt+0x22e>
  80f4a4:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f4a7:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80f4aa:	eb 06                	jmp    80f4b2 <vprintfmt+0x22e>
  80f4ac:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f4af:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80f4b2:	83 c7 01             	add    $0x1,%edi
  80f4b5:	0f b6 57 ff          	movzbl -0x1(%edi),%edx
  80f4b9:	0f be c2             	movsbl %dl,%eax
  80f4bc:	85 c0                	test   %eax,%eax
  80f4be:	74 27                	je     80f4e7 <vprintfmt+0x263>
  80f4c0:	85 f6                	test   %esi,%esi
  80f4c2:	78 aa                	js     80f46e <vprintfmt+0x1ea>
  80f4c4:	83 ee 01             	sub    $0x1,%esi
  80f4c7:	79 a5                	jns    80f46e <vprintfmt+0x1ea>
  80f4c9:	89 d8                	mov    %ebx,%eax
  80f4cb:	8b 75 08             	mov    0x8(%ebp),%esi
  80f4ce:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80f4d1:	89 c3                	mov    %eax,%ebx
  80f4d3:	eb 18                	jmp    80f4ed <vprintfmt+0x269>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80f4d5:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f4d9:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80f4e0:	ff d6                	call   *%esi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80f4e2:	83 eb 01             	sub    $0x1,%ebx
  80f4e5:	eb 06                	jmp    80f4ed <vprintfmt+0x269>
  80f4e7:	8b 75 08             	mov    0x8(%ebp),%esi
  80f4ea:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80f4ed:	85 db                	test   %ebx,%ebx
  80f4ef:	7f e4                	jg     80f4d5 <vprintfmt+0x251>
  80f4f1:	89 75 08             	mov    %esi,0x8(%ebp)
  80f4f4:	89 7d 0c             	mov    %edi,0xc(%ebp)
  80f4f7:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f4fa:	e9 aa fd ff ff       	jmp    80f2a9 <vprintfmt+0x25>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80f4ff:	83 f9 01             	cmp    $0x1,%ecx
  80f502:	7e 10                	jle    80f514 <vprintfmt+0x290>
		return va_arg(*ap, long long);
  80f504:	8b 45 14             	mov    0x14(%ebp),%eax
  80f507:	8b 30                	mov    (%eax),%esi
  80f509:	8b 78 04             	mov    0x4(%eax),%edi
  80f50c:	8d 40 08             	lea    0x8(%eax),%eax
  80f50f:	89 45 14             	mov    %eax,0x14(%ebp)
  80f512:	eb 26                	jmp    80f53a <vprintfmt+0x2b6>
	else if (lflag)
  80f514:	85 c9                	test   %ecx,%ecx
  80f516:	74 12                	je     80f52a <vprintfmt+0x2a6>
		return va_arg(*ap, long);
  80f518:	8b 45 14             	mov    0x14(%ebp),%eax
  80f51b:	8b 30                	mov    (%eax),%esi
  80f51d:	89 f7                	mov    %esi,%edi
  80f51f:	c1 ff 1f             	sar    $0x1f,%edi
  80f522:	8d 40 04             	lea    0x4(%eax),%eax
  80f525:	89 45 14             	mov    %eax,0x14(%ebp)
  80f528:	eb 10                	jmp    80f53a <vprintfmt+0x2b6>
	else
		return va_arg(*ap, int);
  80f52a:	8b 45 14             	mov    0x14(%ebp),%eax
  80f52d:	8b 30                	mov    (%eax),%esi
  80f52f:	89 f7                	mov    %esi,%edi
  80f531:	c1 ff 1f             	sar    $0x1f,%edi
  80f534:	8d 40 04             	lea    0x4(%eax),%eax
  80f537:	89 45 14             	mov    %eax,0x14(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  80f53a:	89 f0                	mov    %esi,%eax
  80f53c:	89 fa                	mov    %edi,%edx
			if ((long long) num < 0) {
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80f53e:	b9 0a 00 00 00       	mov    $0xa,%ecx
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80f543:	85 ff                	test   %edi,%edi
  80f545:	0f 89 3a 01 00 00    	jns    80f685 <vprintfmt+0x401>
				putch('-', putdat);
  80f54b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f54e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f552:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  80f559:	ff 55 08             	call   *0x8(%ebp)
				num = -(long long) num;
  80f55c:	89 f0                	mov    %esi,%eax
  80f55e:	89 fa                	mov    %edi,%edx
  80f560:	f7 d8                	neg    %eax
  80f562:	83 d2 00             	adc    $0x0,%edx
  80f565:	f7 da                	neg    %edx
			}
			base = 10;
  80f567:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80f56c:	e9 14 01 00 00       	jmp    80f685 <vprintfmt+0x401>
// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80f571:	83 f9 01             	cmp    $0x1,%ecx
  80f574:	7e 13                	jle    80f589 <vprintfmt+0x305>
		return va_arg(*ap, unsigned long long);
  80f576:	8b 45 14             	mov    0x14(%ebp),%eax
  80f579:	8b 50 04             	mov    0x4(%eax),%edx
  80f57c:	8b 00                	mov    (%eax),%eax
  80f57e:	8b 75 14             	mov    0x14(%ebp),%esi
  80f581:	8d 4e 08             	lea    0x8(%esi),%ecx
  80f584:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80f587:	eb 2c                	jmp    80f5b5 <vprintfmt+0x331>
	else if (lflag)
  80f589:	85 c9                	test   %ecx,%ecx
  80f58b:	74 15                	je     80f5a2 <vprintfmt+0x31e>
		return va_arg(*ap, unsigned long);
  80f58d:	8b 45 14             	mov    0x14(%ebp),%eax
  80f590:	8b 00                	mov    (%eax),%eax
  80f592:	ba 00 00 00 00       	mov    $0x0,%edx
  80f597:	8b 75 14             	mov    0x14(%ebp),%esi
  80f59a:	8d 76 04             	lea    0x4(%esi),%esi
  80f59d:	89 75 14             	mov    %esi,0x14(%ebp)
  80f5a0:	eb 13                	jmp    80f5b5 <vprintfmt+0x331>
	else
		return va_arg(*ap, unsigned int);
  80f5a2:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5a5:	8b 00                	mov    (%eax),%eax
  80f5a7:	ba 00 00 00 00       	mov    $0x0,%edx
  80f5ac:	8b 75 14             	mov    0x14(%ebp),%esi
  80f5af:	8d 76 04             	lea    0x4(%esi),%esi
  80f5b2:	89 75 14             	mov    %esi,0x14(%ebp)
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
			base = 10;
  80f5b5:	b9 0a 00 00 00       	mov    $0xa,%ecx
			goto number;
  80f5ba:	e9 c6 00 00 00       	jmp    80f685 <vprintfmt+0x401>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80f5bf:	83 f9 01             	cmp    $0x1,%ecx
  80f5c2:	7e 13                	jle    80f5d7 <vprintfmt+0x353>
		return va_arg(*ap, long long);
  80f5c4:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5c7:	8b 50 04             	mov    0x4(%eax),%edx
  80f5ca:	8b 00                	mov    (%eax),%eax
  80f5cc:	8b 75 14             	mov    0x14(%ebp),%esi
  80f5cf:	8d 4e 08             	lea    0x8(%esi),%ecx
  80f5d2:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80f5d5:	eb 24                	jmp    80f5fb <vprintfmt+0x377>
	else if (lflag)
  80f5d7:	85 c9                	test   %ecx,%ecx
  80f5d9:	74 11                	je     80f5ec <vprintfmt+0x368>
		return va_arg(*ap, long);
  80f5db:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5de:	8b 00                	mov    (%eax),%eax
  80f5e0:	99                   	cltd   
  80f5e1:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80f5e4:	8d 71 04             	lea    0x4(%ecx),%esi
  80f5e7:	89 75 14             	mov    %esi,0x14(%ebp)
  80f5ea:	eb 0f                	jmp    80f5fb <vprintfmt+0x377>
	else
		return va_arg(*ap, int);
  80f5ec:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5ef:	8b 00                	mov    (%eax),%eax
  80f5f1:	99                   	cltd   
  80f5f2:	8b 75 14             	mov    0x14(%ebp),%esi
  80f5f5:	8d 76 04             	lea    0x4(%esi),%esi
  80f5f8:	89 75 14             	mov    %esi,0x14(%ebp)
		// (unsigned) octal
		case 'o':
			// Replace this with your code.

			num = getint(&ap, lflag);
			base = 8;
  80f5fb:	b9 08 00 00 00       	mov    $0x8,%ecx
			goto number;
  80f600:	e9 80 00 00 00       	jmp    80f685 <vprintfmt+0x401>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f605:	8b 75 14             	mov    0x14(%ebp),%esi
			base = 8;
			goto number;

		// pointer
		case 'p':
			putch('0', putdat);
  80f608:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f60b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f60f:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  80f616:	ff 55 08             	call   *0x8(%ebp)
			putch('x', putdat);
  80f619:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f61c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f620:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  80f627:	ff 55 08             	call   *0x8(%ebp)
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80f62a:	83 45 14 04          	addl   $0x4,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80f62e:	8b 06                	mov    (%esi),%eax
  80f630:	ba 00 00 00 00       	mov    $0x0,%edx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80f635:	b9 10 00 00 00       	mov    $0x10,%ecx
			goto number;
  80f63a:	eb 49                	jmp    80f685 <vprintfmt+0x401>
// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80f63c:	83 f9 01             	cmp    $0x1,%ecx
  80f63f:	7e 13                	jle    80f654 <vprintfmt+0x3d0>
		return va_arg(*ap, unsigned long long);
  80f641:	8b 45 14             	mov    0x14(%ebp),%eax
  80f644:	8b 50 04             	mov    0x4(%eax),%edx
  80f647:	8b 00                	mov    (%eax),%eax
  80f649:	8b 75 14             	mov    0x14(%ebp),%esi
  80f64c:	8d 4e 08             	lea    0x8(%esi),%ecx
  80f64f:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80f652:	eb 2c                	jmp    80f680 <vprintfmt+0x3fc>
	else if (lflag)
  80f654:	85 c9                	test   %ecx,%ecx
  80f656:	74 15                	je     80f66d <vprintfmt+0x3e9>
		return va_arg(*ap, unsigned long);
  80f658:	8b 45 14             	mov    0x14(%ebp),%eax
  80f65b:	8b 00                	mov    (%eax),%eax
  80f65d:	ba 00 00 00 00       	mov    $0x0,%edx
  80f662:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80f665:	8d 71 04             	lea    0x4(%ecx),%esi
  80f668:	89 75 14             	mov    %esi,0x14(%ebp)
  80f66b:	eb 13                	jmp    80f680 <vprintfmt+0x3fc>
	else
		return va_arg(*ap, unsigned int);
  80f66d:	8b 45 14             	mov    0x14(%ebp),%eax
  80f670:	8b 00                	mov    (%eax),%eax
  80f672:	ba 00 00 00 00       	mov    $0x0,%edx
  80f677:	8b 75 14             	mov    0x14(%ebp),%esi
  80f67a:	8d 76 04             	lea    0x4(%esi),%esi
  80f67d:	89 75 14             	mov    %esi,0x14(%ebp)
			goto number;

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
			base = 16;
  80f680:	b9 10 00 00 00       	mov    $0x10,%ecx
		number:
			printnum(putch, putdat, num, base, width, padc);
  80f685:	0f be 75 dc          	movsbl -0x24(%ebp),%esi
  80f689:	89 74 24 10          	mov    %esi,0x10(%esp)
  80f68d:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f690:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80f694:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f698:	89 04 24             	mov    %eax,(%esp)
  80f69b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f69f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f6a2:	8b 45 08             	mov    0x8(%ebp),%eax
  80f6a5:	e8 a6 fa ff ff       	call   80f150 <printnum>
			break;
  80f6aa:	e9 fa fb ff ff       	jmp    80f2a9 <vprintfmt+0x25>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80f6af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f6b2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80f6b6:	89 04 24             	mov    %eax,(%esp)
  80f6b9:	ff 55 08             	call   *0x8(%ebp)
			break;
  80f6bc:	e9 e8 fb ff ff       	jmp    80f2a9 <vprintfmt+0x25>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80f6c1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f6c4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f6c8:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  80f6cf:	ff 55 08             	call   *0x8(%ebp)
			for (fmt--; fmt[-1] != '%'; fmt--)
  80f6d2:	89 fb                	mov    %edi,%ebx
  80f6d4:	eb 03                	jmp    80f6d9 <vprintfmt+0x455>
  80f6d6:	83 eb 01             	sub    $0x1,%ebx
  80f6d9:	80 7b ff 25          	cmpb   $0x25,-0x1(%ebx)
  80f6dd:	75 f7                	jne    80f6d6 <vprintfmt+0x452>
  80f6df:	90                   	nop
  80f6e0:	e9 c4 fb ff ff       	jmp    80f2a9 <vprintfmt+0x25>
				/* do nothing */;
			break;
		}
	}
}
  80f6e5:	83 c4 3c             	add    $0x3c,%esp
  80f6e8:	5b                   	pop    %ebx
  80f6e9:	5e                   	pop    %esi
  80f6ea:	5f                   	pop    %edi
  80f6eb:	5d                   	pop    %ebp
  80f6ec:	c3                   	ret    

0080f6ed <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80f6ed:	55                   	push   %ebp
  80f6ee:	89 e5                	mov    %esp,%ebp
  80f6f0:	83 ec 28             	sub    $0x28,%esp
  80f6f3:	8b 45 08             	mov    0x8(%ebp),%eax
  80f6f6:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80f6f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80f6fc:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80f700:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80f703:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80f70a:	85 c0                	test   %eax,%eax
  80f70c:	74 30                	je     80f73e <vsnprintf+0x51>
  80f70e:	85 d2                	test   %edx,%edx
  80f710:	7e 2c                	jle    80f73e <vsnprintf+0x51>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80f712:	8b 45 14             	mov    0x14(%ebp),%eax
  80f715:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f719:	8b 45 10             	mov    0x10(%ebp),%eax
  80f71c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f720:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80f723:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f727:	c7 04 24 3f f2 80 00 	movl   $0x80f23f,(%esp)
  80f72e:	e8 51 fb ff ff       	call   80f284 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80f733:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80f736:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80f739:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f73c:	eb 05                	jmp    80f743 <vsnprintf+0x56>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80f73e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80f743:	c9                   	leave  
  80f744:	c3                   	ret    

0080f745 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80f745:	55                   	push   %ebp
  80f746:	89 e5                	mov    %esp,%ebp
  80f748:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80f74b:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80f74e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f752:	8b 45 10             	mov    0x10(%ebp),%eax
  80f755:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f759:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f75c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f760:	8b 45 08             	mov    0x8(%ebp),%eax
  80f763:	89 04 24             	mov    %eax,(%esp)
  80f766:	e8 82 ff ff ff       	call   80f6ed <vsnprintf>
	va_end(ap);

	return rc;
}
  80f76b:	c9                   	leave  
  80f76c:	c3                   	ret    
  80f76d:	66 90                	xchg   %ax,%ax
  80f76f:	90                   	nop

0080f770 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80f770:	55                   	push   %ebp
  80f771:	89 e5                	mov    %esp,%ebp
  80f773:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80f776:	b8 00 00 00 00       	mov    $0x0,%eax
  80f77b:	eb 03                	jmp    80f780 <strlen+0x10>
		n++;
  80f77d:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80f780:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80f784:	75 f7                	jne    80f77d <strlen+0xd>
		n++;
	return n;
}
  80f786:	5d                   	pop    %ebp
  80f787:	c3                   	ret    

0080f788 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80f788:	55                   	push   %ebp
  80f789:	89 e5                	mov    %esp,%ebp
  80f78b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f78e:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f791:	b8 00 00 00 00       	mov    $0x0,%eax
  80f796:	eb 03                	jmp    80f79b <strnlen+0x13>
		n++;
  80f798:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f79b:	39 d0                	cmp    %edx,%eax
  80f79d:	74 06                	je     80f7a5 <strnlen+0x1d>
  80f79f:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80f7a3:	75 f3                	jne    80f798 <strnlen+0x10>
		n++;
	return n;
}
  80f7a5:	5d                   	pop    %ebp
  80f7a6:	c3                   	ret    

0080f7a7 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80f7a7:	55                   	push   %ebp
  80f7a8:	89 e5                	mov    %esp,%ebp
  80f7aa:	53                   	push   %ebx
  80f7ab:	8b 45 08             	mov    0x8(%ebp),%eax
  80f7ae:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80f7b1:	89 c2                	mov    %eax,%edx
  80f7b3:	83 c2 01             	add    $0x1,%edx
  80f7b6:	83 c1 01             	add    $0x1,%ecx
  80f7b9:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
  80f7bd:	88 5a ff             	mov    %bl,-0x1(%edx)
  80f7c0:	84 db                	test   %bl,%bl
  80f7c2:	75 ef                	jne    80f7b3 <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  80f7c4:	5b                   	pop    %ebx
  80f7c5:	5d                   	pop    %ebp
  80f7c6:	c3                   	ret    

0080f7c7 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80f7c7:	55                   	push   %ebp
  80f7c8:	89 e5                	mov    %esp,%ebp
  80f7ca:	53                   	push   %ebx
  80f7cb:	83 ec 08             	sub    $0x8,%esp
  80f7ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80f7d1:	89 1c 24             	mov    %ebx,(%esp)
  80f7d4:	e8 97 ff ff ff       	call   80f770 <strlen>
	strcpy(dst + len, src);
  80f7d9:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f7dc:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f7e0:	01 d8                	add    %ebx,%eax
  80f7e2:	89 04 24             	mov    %eax,(%esp)
  80f7e5:	e8 bd ff ff ff       	call   80f7a7 <strcpy>
	return dst;
}
  80f7ea:	89 d8                	mov    %ebx,%eax
  80f7ec:	83 c4 08             	add    $0x8,%esp
  80f7ef:	5b                   	pop    %ebx
  80f7f0:	5d                   	pop    %ebp
  80f7f1:	c3                   	ret    

0080f7f2 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f7f2:	55                   	push   %ebp
  80f7f3:	89 e5                	mov    %esp,%ebp
  80f7f5:	56                   	push   %esi
  80f7f6:	53                   	push   %ebx
  80f7f7:	8b 75 08             	mov    0x8(%ebp),%esi
  80f7fa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f7fd:	89 f3                	mov    %esi,%ebx
  80f7ff:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f802:	89 f2                	mov    %esi,%edx
  80f804:	eb 0f                	jmp    80f815 <strncpy+0x23>
		*dst++ = *src;
  80f806:	83 c2 01             	add    $0x1,%edx
  80f809:	0f b6 01             	movzbl (%ecx),%eax
  80f80c:	88 42 ff             	mov    %al,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f80f:	80 39 01             	cmpb   $0x1,(%ecx)
  80f812:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f815:	39 da                	cmp    %ebx,%edx
  80f817:	75 ed                	jne    80f806 <strncpy+0x14>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80f819:	89 f0                	mov    %esi,%eax
  80f81b:	5b                   	pop    %ebx
  80f81c:	5e                   	pop    %esi
  80f81d:	5d                   	pop    %ebp
  80f81e:	c3                   	ret    

0080f81f <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f81f:	55                   	push   %ebp
  80f820:	89 e5                	mov    %esp,%ebp
  80f822:	56                   	push   %esi
  80f823:	53                   	push   %ebx
  80f824:	8b 75 08             	mov    0x8(%ebp),%esi
  80f827:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f82a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80f82d:	89 f0                	mov    %esi,%eax
  80f82f:	8d 5c 0e ff          	lea    -0x1(%esi,%ecx,1),%ebx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f833:	85 c9                	test   %ecx,%ecx
  80f835:	75 0b                	jne    80f842 <strlcpy+0x23>
  80f837:	eb 1d                	jmp    80f856 <strlcpy+0x37>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80f839:	83 c0 01             	add    $0x1,%eax
  80f83c:	83 c2 01             	add    $0x1,%edx
  80f83f:	88 48 ff             	mov    %cl,-0x1(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80f842:	39 d8                	cmp    %ebx,%eax
  80f844:	74 0b                	je     80f851 <strlcpy+0x32>
  80f846:	0f b6 0a             	movzbl (%edx),%ecx
  80f849:	84 c9                	test   %cl,%cl
  80f84b:	75 ec                	jne    80f839 <strlcpy+0x1a>
  80f84d:	89 c2                	mov    %eax,%edx
  80f84f:	eb 02                	jmp    80f853 <strlcpy+0x34>
  80f851:	89 c2                	mov    %eax,%edx
			*dst++ = *src++;
		*dst = '\0';
  80f853:	c6 02 00             	movb   $0x0,(%edx)
	}
	return dst - dst_in;
  80f856:	29 f0                	sub    %esi,%eax
}
  80f858:	5b                   	pop    %ebx
  80f859:	5e                   	pop    %esi
  80f85a:	5d                   	pop    %ebp
  80f85b:	c3                   	ret    

0080f85c <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f85c:	55                   	push   %ebp
  80f85d:	89 e5                	mov    %esp,%ebp
  80f85f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f862:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f865:	eb 06                	jmp    80f86d <strcmp+0x11>
		p++, q++;
  80f867:	83 c1 01             	add    $0x1,%ecx
  80f86a:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80f86d:	0f b6 01             	movzbl (%ecx),%eax
  80f870:	84 c0                	test   %al,%al
  80f872:	74 04                	je     80f878 <strcmp+0x1c>
  80f874:	3a 02                	cmp    (%edx),%al
  80f876:	74 ef                	je     80f867 <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f878:	0f b6 c0             	movzbl %al,%eax
  80f87b:	0f b6 12             	movzbl (%edx),%edx
  80f87e:	29 d0                	sub    %edx,%eax
}
  80f880:	5d                   	pop    %ebp
  80f881:	c3                   	ret    

0080f882 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f882:	55                   	push   %ebp
  80f883:	89 e5                	mov    %esp,%ebp
  80f885:	53                   	push   %ebx
  80f886:	8b 45 08             	mov    0x8(%ebp),%eax
  80f889:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f88c:	89 c3                	mov    %eax,%ebx
  80f88e:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80f891:	eb 06                	jmp    80f899 <strncmp+0x17>
		n--, p++, q++;
  80f893:	83 c0 01             	add    $0x1,%eax
  80f896:	83 c2 01             	add    $0x1,%edx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80f899:	39 d8                	cmp    %ebx,%eax
  80f89b:	74 15                	je     80f8b2 <strncmp+0x30>
  80f89d:	0f b6 08             	movzbl (%eax),%ecx
  80f8a0:	84 c9                	test   %cl,%cl
  80f8a2:	74 04                	je     80f8a8 <strncmp+0x26>
  80f8a4:	3a 0a                	cmp    (%edx),%cl
  80f8a6:	74 eb                	je     80f893 <strncmp+0x11>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f8a8:	0f b6 00             	movzbl (%eax),%eax
  80f8ab:	0f b6 12             	movzbl (%edx),%edx
  80f8ae:	29 d0                	sub    %edx,%eax
  80f8b0:	eb 05                	jmp    80f8b7 <strncmp+0x35>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80f8b2:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80f8b7:	5b                   	pop    %ebx
  80f8b8:	5d                   	pop    %ebp
  80f8b9:	c3                   	ret    

0080f8ba <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f8ba:	55                   	push   %ebp
  80f8bb:	89 e5                	mov    %esp,%ebp
  80f8bd:	8b 45 08             	mov    0x8(%ebp),%eax
  80f8c0:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f8c4:	eb 07                	jmp    80f8cd <strchr+0x13>
		if (*s == c)
  80f8c6:	38 ca                	cmp    %cl,%dl
  80f8c8:	74 0f                	je     80f8d9 <strchr+0x1f>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80f8ca:	83 c0 01             	add    $0x1,%eax
  80f8cd:	0f b6 10             	movzbl (%eax),%edx
  80f8d0:	84 d2                	test   %dl,%dl
  80f8d2:	75 f2                	jne    80f8c6 <strchr+0xc>
		if (*s == c)
			return (char *) s;
	return 0;
  80f8d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f8d9:	5d                   	pop    %ebp
  80f8da:	c3                   	ret    

0080f8db <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f8db:	55                   	push   %ebp
  80f8dc:	89 e5                	mov    %esp,%ebp
  80f8de:	8b 45 08             	mov    0x8(%ebp),%eax
  80f8e1:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f8e5:	eb 07                	jmp    80f8ee <strfind+0x13>
		if (*s == c)
  80f8e7:	38 ca                	cmp    %cl,%dl
  80f8e9:	74 0a                	je     80f8f5 <strfind+0x1a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80f8eb:	83 c0 01             	add    $0x1,%eax
  80f8ee:	0f b6 10             	movzbl (%eax),%edx
  80f8f1:	84 d2                	test   %dl,%dl
  80f8f3:	75 f2                	jne    80f8e7 <strfind+0xc>
		if (*s == c)
			break;
	return (char *) s;
}
  80f8f5:	5d                   	pop    %ebp
  80f8f6:	c3                   	ret    

0080f8f7 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f8f7:	55                   	push   %ebp
  80f8f8:	89 e5                	mov    %esp,%ebp
  80f8fa:	57                   	push   %edi
  80f8fb:	56                   	push   %esi
  80f8fc:	53                   	push   %ebx
  80f8fd:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f900:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f903:	85 c9                	test   %ecx,%ecx
  80f905:	74 36                	je     80f93d <memset+0x46>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f907:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80f90d:	75 28                	jne    80f937 <memset+0x40>
  80f90f:	f6 c1 03             	test   $0x3,%cl
  80f912:	75 23                	jne    80f937 <memset+0x40>
		c &= 0xFF;
  80f914:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f918:	89 d3                	mov    %edx,%ebx
  80f91a:	c1 e3 08             	shl    $0x8,%ebx
  80f91d:	89 d6                	mov    %edx,%esi
  80f91f:	c1 e6 18             	shl    $0x18,%esi
  80f922:	89 d0                	mov    %edx,%eax
  80f924:	c1 e0 10             	shl    $0x10,%eax
  80f927:	09 f0                	or     %esi,%eax
  80f929:	09 c2                	or     %eax,%edx
  80f92b:	89 d0                	mov    %edx,%eax
  80f92d:	09 d8                	or     %ebx,%eax
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f92f:	c1 e9 02             	shr    $0x2,%ecx
	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  80f932:	fc                   	cld    
  80f933:	f3 ab                	rep stos %eax,%es:(%edi)
  80f935:	eb 06                	jmp    80f93d <memset+0x46>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f937:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f93a:	fc                   	cld    
  80f93b:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f93d:	89 f8                	mov    %edi,%eax
  80f93f:	5b                   	pop    %ebx
  80f940:	5e                   	pop    %esi
  80f941:	5f                   	pop    %edi
  80f942:	5d                   	pop    %ebp
  80f943:	c3                   	ret    

0080f944 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f944:	55                   	push   %ebp
  80f945:	89 e5                	mov    %esp,%ebp
  80f947:	57                   	push   %edi
  80f948:	56                   	push   %esi
  80f949:	8b 45 08             	mov    0x8(%ebp),%eax
  80f94c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f94f:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f952:	39 c6                	cmp    %eax,%esi
  80f954:	73 35                	jae    80f98b <memmove+0x47>
  80f956:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f959:	39 d0                	cmp    %edx,%eax
  80f95b:	73 2e                	jae    80f98b <memmove+0x47>
		s += n;
		d += n;
  80f95d:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
  80f960:	89 d6                	mov    %edx,%esi
  80f962:	09 fe                	or     %edi,%esi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f964:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f96a:	75 13                	jne    80f97f <memmove+0x3b>
  80f96c:	f6 c1 03             	test   $0x3,%cl
  80f96f:	75 0e                	jne    80f97f <memmove+0x3b>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f971:	83 ef 04             	sub    $0x4,%edi
  80f974:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f977:	c1 e9 02             	shr    $0x2,%ecx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80f97a:	fd                   	std    
  80f97b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f97d:	eb 09                	jmp    80f988 <memmove+0x44>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f97f:	83 ef 01             	sub    $0x1,%edi
  80f982:	8d 72 ff             	lea    -0x1(%edx),%esi
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80f985:	fd                   	std    
  80f986:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f988:	fc                   	cld    
  80f989:	eb 1d                	jmp    80f9a8 <memmove+0x64>
  80f98b:	89 f2                	mov    %esi,%edx
  80f98d:	09 c2                	or     %eax,%edx
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f98f:	f6 c2 03             	test   $0x3,%dl
  80f992:	75 0f                	jne    80f9a3 <memmove+0x5f>
  80f994:	f6 c1 03             	test   $0x3,%cl
  80f997:	75 0a                	jne    80f9a3 <memmove+0x5f>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f999:	c1 e9 02             	shr    $0x2,%ecx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  80f99c:	89 c7                	mov    %eax,%edi
  80f99e:	fc                   	cld    
  80f99f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f9a1:	eb 05                	jmp    80f9a8 <memmove+0x64>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80f9a3:	89 c7                	mov    %eax,%edi
  80f9a5:	fc                   	cld    
  80f9a6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f9a8:	5e                   	pop    %esi
  80f9a9:	5f                   	pop    %edi
  80f9aa:	5d                   	pop    %ebp
  80f9ab:	c3                   	ret    

0080f9ac <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f9ac:	55                   	push   %ebp
  80f9ad:	89 e5                	mov    %esp,%ebp
  80f9af:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f9b2:	8b 45 10             	mov    0x10(%ebp),%eax
  80f9b5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f9b9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f9bc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f9c0:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9c3:	89 04 24             	mov    %eax,(%esp)
  80f9c6:	e8 79 ff ff ff       	call   80f944 <memmove>
}
  80f9cb:	c9                   	leave  
  80f9cc:	c3                   	ret    

0080f9cd <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f9cd:	55                   	push   %ebp
  80f9ce:	89 e5                	mov    %esp,%ebp
  80f9d0:	56                   	push   %esi
  80f9d1:	53                   	push   %ebx
  80f9d2:	8b 55 08             	mov    0x8(%ebp),%edx
  80f9d5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f9d8:	89 d6                	mov    %edx,%esi
  80f9da:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f9dd:	eb 1a                	jmp    80f9f9 <memcmp+0x2c>
		if (*s1 != *s2)
  80f9df:	0f b6 02             	movzbl (%edx),%eax
  80f9e2:	0f b6 19             	movzbl (%ecx),%ebx
  80f9e5:	38 d8                	cmp    %bl,%al
  80f9e7:	74 0a                	je     80f9f3 <memcmp+0x26>
			return (int) *s1 - (int) *s2;
  80f9e9:	0f b6 c0             	movzbl %al,%eax
  80f9ec:	0f b6 db             	movzbl %bl,%ebx
  80f9ef:	29 d8                	sub    %ebx,%eax
  80f9f1:	eb 0f                	jmp    80fa02 <memcmp+0x35>
		s1++, s2++;
  80f9f3:	83 c2 01             	add    $0x1,%edx
  80f9f6:	83 c1 01             	add    $0x1,%ecx
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f9f9:	39 f2                	cmp    %esi,%edx
  80f9fb:	75 e2                	jne    80f9df <memcmp+0x12>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80f9fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fa02:	5b                   	pop    %ebx
  80fa03:	5e                   	pop    %esi
  80fa04:	5d                   	pop    %ebp
  80fa05:	c3                   	ret    

0080fa06 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80fa06:	55                   	push   %ebp
  80fa07:	89 e5                	mov    %esp,%ebp
  80fa09:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa0c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80fa0f:	89 c2                	mov    %eax,%edx
  80fa11:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80fa14:	eb 07                	jmp    80fa1d <memfind+0x17>
		if (*(const unsigned char *) s == (unsigned char) c)
  80fa16:	38 08                	cmp    %cl,(%eax)
  80fa18:	74 07                	je     80fa21 <memfind+0x1b>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80fa1a:	83 c0 01             	add    $0x1,%eax
  80fa1d:	39 d0                	cmp    %edx,%eax
  80fa1f:	72 f5                	jb     80fa16 <memfind+0x10>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80fa21:	5d                   	pop    %ebp
  80fa22:	c3                   	ret    

0080fa23 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80fa23:	55                   	push   %ebp
  80fa24:	89 e5                	mov    %esp,%ebp
  80fa26:	57                   	push   %edi
  80fa27:	56                   	push   %esi
  80fa28:	53                   	push   %ebx
  80fa29:	8b 55 08             	mov    0x8(%ebp),%edx
  80fa2c:	8b 45 10             	mov    0x10(%ebp),%eax
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80fa2f:	eb 03                	jmp    80fa34 <strtol+0x11>
		s++;
  80fa31:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80fa34:	0f b6 0a             	movzbl (%edx),%ecx
  80fa37:	80 f9 09             	cmp    $0x9,%cl
  80fa3a:	74 f5                	je     80fa31 <strtol+0xe>
  80fa3c:	80 f9 20             	cmp    $0x20,%cl
  80fa3f:	74 f0                	je     80fa31 <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80fa41:	80 f9 2b             	cmp    $0x2b,%cl
  80fa44:	75 0a                	jne    80fa50 <strtol+0x2d>
		s++;
  80fa46:	83 c2 01             	add    $0x1,%edx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80fa49:	bf 00 00 00 00       	mov    $0x0,%edi
  80fa4e:	eb 11                	jmp    80fa61 <strtol+0x3e>
  80fa50:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80fa55:	80 f9 2d             	cmp    $0x2d,%cl
  80fa58:	75 07                	jne    80fa61 <strtol+0x3e>
		s++, neg = 1;
  80fa5a:	8d 52 01             	lea    0x1(%edx),%edx
  80fa5d:	66 bf 01 00          	mov    $0x1,%di

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80fa61:	a9 ef ff ff ff       	test   $0xffffffef,%eax
  80fa66:	75 15                	jne    80fa7d <strtol+0x5a>
  80fa68:	80 3a 30             	cmpb   $0x30,(%edx)
  80fa6b:	75 10                	jne    80fa7d <strtol+0x5a>
  80fa6d:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80fa71:	75 0a                	jne    80fa7d <strtol+0x5a>
		s += 2, base = 16;
  80fa73:	83 c2 02             	add    $0x2,%edx
  80fa76:	b8 10 00 00 00       	mov    $0x10,%eax
  80fa7b:	eb 10                	jmp    80fa8d <strtol+0x6a>
	else if (base == 0 && s[0] == '0')
  80fa7d:	85 c0                	test   %eax,%eax
  80fa7f:	75 0c                	jne    80fa8d <strtol+0x6a>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80fa81:	b0 0a                	mov    $0xa,%al
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80fa83:	80 3a 30             	cmpb   $0x30,(%edx)
  80fa86:	75 05                	jne    80fa8d <strtol+0x6a>
		s++, base = 8;
  80fa88:	83 c2 01             	add    $0x1,%edx
  80fa8b:	b0 08                	mov    $0x8,%al
	else if (base == 0)
		base = 10;
  80fa8d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fa92:	89 45 10             	mov    %eax,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80fa95:	0f b6 0a             	movzbl (%edx),%ecx
  80fa98:	8d 71 d0             	lea    -0x30(%ecx),%esi
  80fa9b:	89 f0                	mov    %esi,%eax
  80fa9d:	3c 09                	cmp    $0x9,%al
  80fa9f:	77 08                	ja     80faa9 <strtol+0x86>
			dig = *s - '0';
  80faa1:	0f be c9             	movsbl %cl,%ecx
  80faa4:	83 e9 30             	sub    $0x30,%ecx
  80faa7:	eb 20                	jmp    80fac9 <strtol+0xa6>
		else if (*s >= 'a' && *s <= 'z')
  80faa9:	8d 71 9f             	lea    -0x61(%ecx),%esi
  80faac:	89 f0                	mov    %esi,%eax
  80faae:	3c 19                	cmp    $0x19,%al
  80fab0:	77 08                	ja     80faba <strtol+0x97>
			dig = *s - 'a' + 10;
  80fab2:	0f be c9             	movsbl %cl,%ecx
  80fab5:	83 e9 57             	sub    $0x57,%ecx
  80fab8:	eb 0f                	jmp    80fac9 <strtol+0xa6>
		else if (*s >= 'A' && *s <= 'Z')
  80faba:	8d 71 bf             	lea    -0x41(%ecx),%esi
  80fabd:	89 f0                	mov    %esi,%eax
  80fabf:	3c 19                	cmp    $0x19,%al
  80fac1:	77 16                	ja     80fad9 <strtol+0xb6>
			dig = *s - 'A' + 10;
  80fac3:	0f be c9             	movsbl %cl,%ecx
  80fac6:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  80fac9:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  80facc:	7d 0f                	jge    80fadd <strtol+0xba>
			break;
		s++, val = (val * base) + dig;
  80face:	83 c2 01             	add    $0x1,%edx
  80fad1:	0f af 5d 10          	imul   0x10(%ebp),%ebx
  80fad5:	01 cb                	add    %ecx,%ebx
		// we don't properly detect overflow!
	}
  80fad7:	eb bc                	jmp    80fa95 <strtol+0x72>
  80fad9:	89 d8                	mov    %ebx,%eax
  80fadb:	eb 02                	jmp    80fadf <strtol+0xbc>
  80fadd:	89 d8                	mov    %ebx,%eax

	if (endptr)
  80fadf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80fae3:	74 05                	je     80faea <strtol+0xc7>
		*endptr = (char *) s;
  80fae5:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fae8:	89 16                	mov    %edx,(%esi)
	return (neg ? -val : val);
  80faea:	f7 d8                	neg    %eax
  80faec:	85 ff                	test   %edi,%edi
  80faee:	0f 44 c3             	cmove  %ebx,%eax
}
  80faf1:	5b                   	pop    %ebx
  80faf2:	5e                   	pop    %esi
  80faf3:	5f                   	pop    %edi
  80faf4:	5d                   	pop    %ebp
  80faf5:	c3                   	ret    

0080faf6 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80faf6:	55                   	push   %ebp
  80faf7:	89 e5                	mov    %esp,%ebp
  80faf9:	57                   	push   %edi
  80fafa:	56                   	push   %esi
  80fafb:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fafc:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb01:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fb04:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb07:	89 c3                	mov    %eax,%ebx
  80fb09:	89 c7                	mov    %eax,%edi
  80fb0b:	89 c6                	mov    %eax,%esi
  80fb0d:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80fb0f:	5b                   	pop    %ebx
  80fb10:	5e                   	pop    %esi
  80fb11:	5f                   	pop    %edi
  80fb12:	5d                   	pop    %ebp
  80fb13:	c3                   	ret    

0080fb14 <sys_cgetc>:

int
sys_cgetc(void)
{
  80fb14:	55                   	push   %ebp
  80fb15:	89 e5                	mov    %esp,%ebp
  80fb17:	57                   	push   %edi
  80fb18:	56                   	push   %esi
  80fb19:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb1a:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb1f:	b8 01 00 00 00       	mov    $0x1,%eax
  80fb24:	89 d1                	mov    %edx,%ecx
  80fb26:	89 d3                	mov    %edx,%ebx
  80fb28:	89 d7                	mov    %edx,%edi
  80fb2a:	89 d6                	mov    %edx,%esi
  80fb2c:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80fb2e:	5b                   	pop    %ebx
  80fb2f:	5e                   	pop    %esi
  80fb30:	5f                   	pop    %edi
  80fb31:	5d                   	pop    %ebp
  80fb32:	c3                   	ret    

0080fb33 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80fb33:	55                   	push   %ebp
  80fb34:	89 e5                	mov    %esp,%ebp
  80fb36:	57                   	push   %edi
  80fb37:	56                   	push   %esi
  80fb38:	53                   	push   %ebx
  80fb39:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb3c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fb41:	b8 03 00 00 00       	mov    $0x3,%eax
  80fb46:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb49:	89 cb                	mov    %ecx,%ebx
  80fb4b:	89 cf                	mov    %ecx,%edi
  80fb4d:	89 ce                	mov    %ecx,%esi
  80fb4f:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fb51:	85 c0                	test   %eax,%eax
  80fb53:	7e 28                	jle    80fb7d <sys_env_destroy+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fb55:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fb59:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  80fb60:	00 
  80fb61:	c7 44 24 08 57 48 81 	movl   $0x814857,0x8(%esp)
  80fb68:	00 
  80fb69:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fb70:	00 
  80fb71:	c7 04 24 74 48 81 00 	movl   $0x814874,(%esp)
  80fb78:	e8 bd f4 ff ff       	call   80f03a <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80fb7d:	83 c4 2c             	add    $0x2c,%esp
  80fb80:	5b                   	pop    %ebx
  80fb81:	5e                   	pop    %esi
  80fb82:	5f                   	pop    %edi
  80fb83:	5d                   	pop    %ebp
  80fb84:	c3                   	ret    

0080fb85 <sys_env_cleanup>:

int
sys_env_cleanup(envid_t envid)
{
  80fb85:	55                   	push   %ebp
  80fb86:	89 e5                	mov    %esp,%ebp
  80fb88:	57                   	push   %edi
  80fb89:	56                   	push   %esi
  80fb8a:	53                   	push   %ebx
  80fb8b:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb8e:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fb93:	b8 04 00 00 00       	mov    $0x4,%eax
  80fb98:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb9b:	89 cb                	mov    %ecx,%ebx
  80fb9d:	89 cf                	mov    %ecx,%edi
  80fb9f:	89 ce                	mov    %ecx,%esi
  80fba1:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fba3:	85 c0                	test   %eax,%eax
  80fba5:	7e 28                	jle    80fbcf <sys_env_cleanup+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fba7:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fbab:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  80fbb2:	00 
  80fbb3:	c7 44 24 08 57 48 81 	movl   $0x814857,0x8(%esp)
  80fbba:	00 
  80fbbb:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fbc2:	00 
  80fbc3:	c7 04 24 74 48 81 00 	movl   $0x814874,(%esp)
  80fbca:	e8 6b f4 ff ff       	call   80f03a <_panic>

int
sys_env_cleanup(envid_t envid)
{
	return syscall(SYS_env_cleanup, 1, envid, 0, 0, 0, 0);
}
  80fbcf:	83 c4 2c             	add    $0x2c,%esp
  80fbd2:	5b                   	pop    %ebx
  80fbd3:	5e                   	pop    %esi
  80fbd4:	5f                   	pop    %edi
  80fbd5:	5d                   	pop    %ebp
  80fbd6:	c3                   	ret    

0080fbd7 <sys_getenvid>:


envid_t
sys_getenvid(void)
{
  80fbd7:	55                   	push   %ebp
  80fbd8:	89 e5                	mov    %esp,%ebp
  80fbda:	57                   	push   %edi
  80fbdb:	56                   	push   %esi
  80fbdc:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fbdd:	ba 00 00 00 00       	mov    $0x0,%edx
  80fbe2:	b8 02 00 00 00       	mov    $0x2,%eax
  80fbe7:	89 d1                	mov    %edx,%ecx
  80fbe9:	89 d3                	mov    %edx,%ebx
  80fbeb:	89 d7                	mov    %edx,%edi
  80fbed:	89 d6                	mov    %edx,%esi
  80fbef:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80fbf1:	5b                   	pop    %ebx
  80fbf2:	5e                   	pop    %esi
  80fbf3:	5f                   	pop    %edi
  80fbf4:	5d                   	pop    %ebp
  80fbf5:	c3                   	ret    

0080fbf6 <sys_yield>:

void
sys_yield(void)
{
  80fbf6:	55                   	push   %ebp
  80fbf7:	89 e5                	mov    %esp,%ebp
  80fbf9:	57                   	push   %edi
  80fbfa:	56                   	push   %esi
  80fbfb:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fbfc:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc01:	b8 0c 00 00 00       	mov    $0xc,%eax
  80fc06:	89 d1                	mov    %edx,%ecx
  80fc08:	89 d3                	mov    %edx,%ebx
  80fc0a:	89 d7                	mov    %edx,%edi
  80fc0c:	89 d6                	mov    %edx,%esi
  80fc0e:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80fc10:	5b                   	pop    %ebx
  80fc11:	5e                   	pop    %esi
  80fc12:	5f                   	pop    %edi
  80fc13:	5d                   	pop    %ebp
  80fc14:	c3                   	ret    

0080fc15 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80fc15:	55                   	push   %ebp
  80fc16:	89 e5                	mov    %esp,%ebp
  80fc18:	57                   	push   %edi
  80fc19:	56                   	push   %esi
  80fc1a:	53                   	push   %ebx
  80fc1b:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fc1e:	be 00 00 00 00       	mov    $0x0,%esi
  80fc23:	b8 05 00 00 00       	mov    $0x5,%eax
  80fc28:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fc2b:	8b 55 08             	mov    0x8(%ebp),%edx
  80fc2e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fc31:	89 f7                	mov    %esi,%edi
  80fc33:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fc35:	85 c0                	test   %eax,%eax
  80fc37:	7e 28                	jle    80fc61 <sys_page_alloc+0x4c>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fc39:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fc3d:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  80fc44:	00 
  80fc45:	c7 44 24 08 57 48 81 	movl   $0x814857,0x8(%esp)
  80fc4c:	00 
  80fc4d:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fc54:	00 
  80fc55:	c7 04 24 74 48 81 00 	movl   $0x814874,(%esp)
  80fc5c:	e8 d9 f3 ff ff       	call   80f03a <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80fc61:	83 c4 2c             	add    $0x2c,%esp
  80fc64:	5b                   	pop    %ebx
  80fc65:	5e                   	pop    %esi
  80fc66:	5f                   	pop    %edi
  80fc67:	5d                   	pop    %ebp
  80fc68:	c3                   	ret    

0080fc69 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80fc69:	55                   	push   %ebp
  80fc6a:	89 e5                	mov    %esp,%ebp
  80fc6c:	57                   	push   %edi
  80fc6d:	56                   	push   %esi
  80fc6e:	53                   	push   %ebx
  80fc6f:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fc72:	b8 06 00 00 00       	mov    $0x6,%eax
  80fc77:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fc7a:	8b 55 08             	mov    0x8(%ebp),%edx
  80fc7d:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fc80:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fc83:	8b 75 18             	mov    0x18(%ebp),%esi
  80fc86:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fc88:	85 c0                	test   %eax,%eax
  80fc8a:	7e 28                	jle    80fcb4 <sys_page_map+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fc8c:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fc90:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80fc97:	00 
  80fc98:	c7 44 24 08 57 48 81 	movl   $0x814857,0x8(%esp)
  80fc9f:	00 
  80fca0:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fca7:	00 
  80fca8:	c7 04 24 74 48 81 00 	movl   $0x814874,(%esp)
  80fcaf:	e8 86 f3 ff ff       	call   80f03a <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80fcb4:	83 c4 2c             	add    $0x2c,%esp
  80fcb7:	5b                   	pop    %ebx
  80fcb8:	5e                   	pop    %esi
  80fcb9:	5f                   	pop    %edi
  80fcba:	5d                   	pop    %ebp
  80fcbb:	c3                   	ret    

0080fcbc <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80fcbc:	55                   	push   %ebp
  80fcbd:	89 e5                	mov    %esp,%ebp
  80fcbf:	57                   	push   %edi
  80fcc0:	56                   	push   %esi
  80fcc1:	53                   	push   %ebx
  80fcc2:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fcc5:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fcca:	b8 07 00 00 00       	mov    $0x7,%eax
  80fccf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fcd2:	8b 55 08             	mov    0x8(%ebp),%edx
  80fcd5:	89 df                	mov    %ebx,%edi
  80fcd7:	89 de                	mov    %ebx,%esi
  80fcd9:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fcdb:	85 c0                	test   %eax,%eax
  80fcdd:	7e 28                	jle    80fd07 <sys_page_unmap+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fcdf:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fce3:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80fcea:	00 
  80fceb:	c7 44 24 08 57 48 81 	movl   $0x814857,0x8(%esp)
  80fcf2:	00 
  80fcf3:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fcfa:	00 
  80fcfb:	c7 04 24 74 48 81 00 	movl   $0x814874,(%esp)
  80fd02:	e8 33 f3 ff ff       	call   80f03a <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80fd07:	83 c4 2c             	add    $0x2c,%esp
  80fd0a:	5b                   	pop    %ebx
  80fd0b:	5e                   	pop    %esi
  80fd0c:	5f                   	pop    %edi
  80fd0d:	5d                   	pop    %ebp
  80fd0e:	c3                   	ret    

0080fd0f <sys_share_pages>:

int sys_share_pages(envid_t dst_envid)
{
  80fd0f:	55                   	push   %ebp
  80fd10:	89 e5                	mov    %esp,%ebp
  80fd12:	57                   	push   %edi
  80fd13:	56                   	push   %esi
  80fd14:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd15:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fd1a:	b8 10 00 00 00       	mov    $0x10,%eax
  80fd1f:	8b 55 08             	mov    0x8(%ebp),%edx
  80fd22:	89 cb                	mov    %ecx,%ebx
  80fd24:	89 cf                	mov    %ecx,%edi
  80fd26:	89 ce                	mov    %ecx,%esi
  80fd28:	cd 30                	int    $0x30
}

int sys_share_pages(envid_t dst_envid)
{
	return syscall(SYS_share_pages, 0, dst_envid, 0, 0, 0, 0);
}
  80fd2a:	5b                   	pop    %ebx
  80fd2b:	5e                   	pop    %esi
  80fd2c:	5f                   	pop    %edi
  80fd2d:	5d                   	pop    %ebp
  80fd2e:	c3                   	ret    

0080fd2f <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80fd2f:	55                   	push   %ebp
  80fd30:	89 e5                	mov    %esp,%ebp
  80fd32:	57                   	push   %edi
  80fd33:	56                   	push   %esi
  80fd34:	53                   	push   %ebx
  80fd35:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd38:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fd3d:	b8 09 00 00 00       	mov    $0x9,%eax
  80fd42:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fd45:	8b 55 08             	mov    0x8(%ebp),%edx
  80fd48:	89 df                	mov    %ebx,%edi
  80fd4a:	89 de                	mov    %ebx,%esi
  80fd4c:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fd4e:	85 c0                	test   %eax,%eax
  80fd50:	7e 28                	jle    80fd7a <sys_env_set_status+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fd52:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fd56:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  80fd5d:	00 
  80fd5e:	c7 44 24 08 57 48 81 	movl   $0x814857,0x8(%esp)
  80fd65:	00 
  80fd66:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fd6d:	00 
  80fd6e:	c7 04 24 74 48 81 00 	movl   $0x814874,(%esp)
  80fd75:	e8 c0 f2 ff ff       	call   80f03a <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80fd7a:	83 c4 2c             	add    $0x2c,%esp
  80fd7d:	5b                   	pop    %ebx
  80fd7e:	5e                   	pop    %esi
  80fd7f:	5f                   	pop    %edi
  80fd80:	5d                   	pop    %ebp
  80fd81:	c3                   	ret    

0080fd82 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80fd82:	55                   	push   %ebp
  80fd83:	89 e5                	mov    %esp,%ebp
  80fd85:	57                   	push   %edi
  80fd86:	56                   	push   %esi
  80fd87:	53                   	push   %ebx
  80fd88:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd8b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fd90:	b8 0a 00 00 00       	mov    $0xa,%eax
  80fd95:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fd98:	8b 55 08             	mov    0x8(%ebp),%edx
  80fd9b:	89 df                	mov    %ebx,%edi
  80fd9d:	89 de                	mov    %ebx,%esi
  80fd9f:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fda1:	85 c0                	test   %eax,%eax
  80fda3:	7e 28                	jle    80fdcd <sys_env_set_trapframe+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fda5:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fda9:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  80fdb0:	00 
  80fdb1:	c7 44 24 08 57 48 81 	movl   $0x814857,0x8(%esp)
  80fdb8:	00 
  80fdb9:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fdc0:	00 
  80fdc1:	c7 04 24 74 48 81 00 	movl   $0x814874,(%esp)
  80fdc8:	e8 6d f2 ff ff       	call   80f03a <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80fdcd:	83 c4 2c             	add    $0x2c,%esp
  80fdd0:	5b                   	pop    %ebx
  80fdd1:	5e                   	pop    %esi
  80fdd2:	5f                   	pop    %edi
  80fdd3:	5d                   	pop    %ebp
  80fdd4:	c3                   	ret    

0080fdd5 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80fdd5:	55                   	push   %ebp
  80fdd6:	89 e5                	mov    %esp,%ebp
  80fdd8:	57                   	push   %edi
  80fdd9:	56                   	push   %esi
  80fdda:	53                   	push   %ebx
  80fddb:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fdde:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fde3:	b8 0b 00 00 00       	mov    $0xb,%eax
  80fde8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fdeb:	8b 55 08             	mov    0x8(%ebp),%edx
  80fdee:	89 df                	mov    %ebx,%edi
  80fdf0:	89 de                	mov    %ebx,%esi
  80fdf2:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fdf4:	85 c0                	test   %eax,%eax
  80fdf6:	7e 28                	jle    80fe20 <sys_env_set_pgfault_upcall+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fdf8:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fdfc:	c7 44 24 0c 0b 00 00 	movl   $0xb,0xc(%esp)
  80fe03:	00 
  80fe04:	c7 44 24 08 57 48 81 	movl   $0x814857,0x8(%esp)
  80fe0b:	00 
  80fe0c:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fe13:	00 
  80fe14:	c7 04 24 74 48 81 00 	movl   $0x814874,(%esp)
  80fe1b:	e8 1a f2 ff ff       	call   80f03a <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80fe20:	83 c4 2c             	add    $0x2c,%esp
  80fe23:	5b                   	pop    %ebx
  80fe24:	5e                   	pop    %esi
  80fe25:	5f                   	pop    %edi
  80fe26:	5d                   	pop    %ebp
  80fe27:	c3                   	ret    

0080fe28 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80fe28:	55                   	push   %ebp
  80fe29:	89 e5                	mov    %esp,%ebp
  80fe2b:	57                   	push   %edi
  80fe2c:	56                   	push   %esi
  80fe2d:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe2e:	be 00 00 00 00       	mov    $0x0,%esi
  80fe33:	b8 0d 00 00 00       	mov    $0xd,%eax
  80fe38:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fe3b:	8b 55 08             	mov    0x8(%ebp),%edx
  80fe3e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fe41:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fe44:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80fe46:	5b                   	pop    %ebx
  80fe47:	5e                   	pop    %esi
  80fe48:	5f                   	pop    %edi
  80fe49:	5d                   	pop    %ebp
  80fe4a:	c3                   	ret    

0080fe4b <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80fe4b:	55                   	push   %ebp
  80fe4c:	89 e5                	mov    %esp,%ebp
  80fe4e:	57                   	push   %edi
  80fe4f:	56                   	push   %esi
  80fe50:	53                   	push   %ebx
  80fe51:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe54:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fe59:	b8 0e 00 00 00       	mov    $0xe,%eax
  80fe5e:	8b 55 08             	mov    0x8(%ebp),%edx
  80fe61:	89 cb                	mov    %ecx,%ebx
  80fe63:	89 cf                	mov    %ecx,%edi
  80fe65:	89 ce                	mov    %ecx,%esi
  80fe67:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fe69:	85 c0                	test   %eax,%eax
  80fe6b:	7e 28                	jle    80fe95 <sys_ipc_recv+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fe6d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fe71:	c7 44 24 0c 0e 00 00 	movl   $0xe,0xc(%esp)
  80fe78:	00 
  80fe79:	c7 44 24 08 57 48 81 	movl   $0x814857,0x8(%esp)
  80fe80:	00 
  80fe81:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fe88:	00 
  80fe89:	c7 04 24 74 48 81 00 	movl   $0x814874,(%esp)
  80fe90:	e8 a5 f1 ff ff       	call   80f03a <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80fe95:	83 c4 2c             	add    $0x2c,%esp
  80fe98:	5b                   	pop    %ebx
  80fe99:	5e                   	pop    %esi
  80fe9a:	5f                   	pop    %edi
  80fe9b:	5d                   	pop    %ebp
  80fe9c:	c3                   	ret    

0080fe9d <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80fe9d:	55                   	push   %ebp
  80fe9e:	89 e5                	mov    %esp,%ebp
  80fea0:	57                   	push   %edi
  80fea1:	56                   	push   %esi
  80fea2:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fea3:	ba 00 00 00 00       	mov    $0x0,%edx
  80fea8:	b8 0f 00 00 00       	mov    $0xf,%eax
  80fead:	89 d1                	mov    %edx,%ecx
  80feaf:	89 d3                	mov    %edx,%ebx
  80feb1:	89 d7                	mov    %edx,%edi
  80feb3:	89 d6                	mov    %edx,%esi
  80feb5:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80feb7:	5b                   	pop    %ebx
  80feb8:	5e                   	pop    %esi
  80feb9:	5f                   	pop    %edi
  80feba:	5d                   	pop    %ebp
  80febb:	c3                   	ret    

0080febc <sys_tx_packet>:

int sys_tx_packet(const char *data, size_t len)
{
  80febc:	55                   	push   %ebp
  80febd:	89 e5                	mov    %esp,%ebp
  80febf:	57                   	push   %edi
  80fec0:	56                   	push   %esi
  80fec1:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fec2:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fec7:	b8 11 00 00 00       	mov    $0x11,%eax
  80fecc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fecf:	8b 55 08             	mov    0x8(%ebp),%edx
  80fed2:	89 df                	mov    %ebx,%edi
  80fed4:	89 de                	mov    %ebx,%esi
  80fed6:	cd 30                	int    $0x30
}

int sys_tx_packet(const char *data, size_t len)
{
	return syscall(SYS_tx_packet, 0, (uint32_t)data, len, 0, 0, 0);
}
  80fed8:	5b                   	pop    %ebx
  80fed9:	5e                   	pop    %esi
  80feda:	5f                   	pop    %edi
  80fedb:	5d                   	pop    %ebp
  80fedc:	c3                   	ret    

0080fedd <sys_rx_packet>:

int sys_rx_packet(void *req, int *len)
{
  80fedd:	55                   	push   %ebp
  80fede:	89 e5                	mov    %esp,%ebp
  80fee0:	57                   	push   %edi
  80fee1:	56                   	push   %esi
  80fee2:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fee3:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fee8:	b8 12 00 00 00       	mov    $0x12,%eax
  80feed:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fef0:	8b 55 08             	mov    0x8(%ebp),%edx
  80fef3:	89 df                	mov    %ebx,%edi
  80fef5:	89 de                	mov    %ebx,%esi
  80fef7:	cd 30                	int    $0x30
}

int sys_rx_packet(void *req, int *len)
{
	return syscall(SYS_rx_packet, 0, (uint32_t)req,(uint32_t)len , 0, 0, 0);
}
  80fef9:	5b                   	pop    %ebx
  80fefa:	5e                   	pop    %esi
  80fefb:	5f                   	pop    %edi
  80fefc:	5d                   	pop    %ebp
  80fefd:	c3                   	ret    

0080fefe <sys_read_mac>:

int sys_read_mac(uint8_t *data)
{
  80fefe:	55                   	push   %ebp
  80feff:	89 e5                	mov    %esp,%ebp
  80ff01:	57                   	push   %edi
  80ff02:	56                   	push   %esi
  80ff03:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ff04:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ff09:	b8 13 00 00 00       	mov    $0x13,%eax
  80ff0e:	8b 55 08             	mov    0x8(%ebp),%edx
  80ff11:	89 cb                	mov    %ecx,%ebx
  80ff13:	89 cf                	mov    %ecx,%edi
  80ff15:	89 ce                	mov    %ecx,%esi
  80ff17:	cd 30                	int    $0x30
}

int sys_read_mac(uint8_t *data)
{
	return syscall(SYS_read_mac, 0, (uint32_t)data, 0, 0, 0, 0);
  80ff19:	5b                   	pop    %ebx
  80ff1a:	5e                   	pop    %esi
  80ff1b:	5f                   	pop    %edi
  80ff1c:	5d                   	pop    %ebp
  80ff1d:	c3                   	ret    

0080ff1e <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80ff1e:	55                   	push   %ebp
  80ff1f:	89 e5                	mov    %esp,%ebp
  80ff21:	57                   	push   %edi
  80ff22:	56                   	push   %esi
  80ff23:	53                   	push   %ebx
  80ff24:	83 ec 2c             	sub    $0x2c,%esp
  80ff27:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80ff2a:	8b 38                	mov    (%eax),%edi
	uint32_t err = utf->utf_err;
  80ff2c:	8b 70 04             	mov    0x4(%eax),%esi
	int r;
	pte_t ptentry=0;
	pte_t page_num = PGNUM(addr);
  80ff2f:	89 f8                	mov    %edi,%eax
  80ff31:	c1 e8 0c             	shr    $0xc,%eax
  80ff34:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	envid_t src_envid = sys_getenvid();
  80ff37:	e8 9b fc ff ff       	call   80fbd7 <sys_getenvid>

	// LAB 4: Your code here.

	//panic("pgfault not implemented");
	//checks if fault because of write action //violation//
	if(err & FEC_WR)
  80ff3c:	f7 c6 02 00 00 00    	test   $0x2,%esi
  80ff42:	0f 84 de 00 00 00    	je     810026 <pgfault+0x108>
  80ff48:	89 c3                	mov    %eax,%ebx
	{
		if(src_envid <0)
  80ff4a:	85 c0                	test   %eax,%eax
  80ff4c:	79 20                	jns    80ff6e <pgfault+0x50>
			panic("\nenvironment value wrong:%e",src_envid);	
  80ff4e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ff52:	c7 44 24 08 82 48 81 	movl   $0x814882,0x8(%esp)
  80ff59:	00 
  80ff5a:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%esp)
  80ff61:	00 
  80ff62:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  80ff69:	e8 cc f0 ff ff       	call   80f03a <_panic>
		//check if the the page is copy on write
		ptentry = uvpt[page_num];
  80ff6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ff71:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
		if((ptentry & PTE_COW) && (ptentry & PTE_U) && (ptentry & PTE_P))
  80ff78:	25 05 08 00 00       	and    $0x805,%eax
  80ff7d:	3d 05 08 00 00       	cmp    $0x805,%eax
  80ff82:	0f 85 ba 00 00 00    	jne    810042 <pgfault+0x124>
		{
			//allocating page mapped at virtual address PFTEMP in current address space
			//cprintf("\nenvid:%d nd thisenvid:%d",src_envid, thisenv->env_id);
			if ((r = sys_page_alloc(src_envid, PFTEMP, PTE_P|PTE_U|PTE_W)) < 0)
  80ff88:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80ff8f:	00 
  80ff90:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80ff97:	00 
  80ff98:	89 1c 24             	mov    %ebx,(%esp)
  80ff9b:	e8 75 fc ff ff       	call   80fc15 <sys_page_alloc>
  80ffa0:	85 c0                	test   %eax,%eax
  80ffa2:	79 20                	jns    80ffc4 <pgfault+0xa6>
				panic("sys_page_alloc: %e", r);
  80ffa4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ffa8:	c7 44 24 08 a9 48 81 	movl   $0x8148a9,0x8(%esp)
  80ffaf:	00 
  80ffb0:	c7 44 24 04 38 00 00 	movl   $0x38,0x4(%esp)
  80ffb7:	00 
  80ffb8:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  80ffbf:	e8 76 f0 ff ff       	call   80f03a <_panic>
			//copying the data at addr to newly mapped page
			memmove((void *)PFTEMP, (void *)PTE_ADDR(addr), PGSIZE);
  80ffc4:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
  80ffca:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  80ffd1:	00 
  80ffd2:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ffd6:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  80ffdd:	e8 62 f9 ff ff       	call   80f944 <memmove>
				So our PFTEMP addr is already pointing to old page faulted page. So during this new
				page insert it pages will obviously not be same so will remove the old page mapping
				So old page mapping will go from 2 to 1 which is no and also was consistent.

			*/
			if ((r = sys_page_map(src_envid, PFTEMP, src_envid, (void *)PTE_ADDR(addr), PTE_P|PTE_U|PTE_W)) < 0)
  80ffe2:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  80ffe9:	00 
  80ffea:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80ffee:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80fff2:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80fff9:	00 
  80fffa:	89 1c 24             	mov    %ebx,(%esp)
  80fffd:	e8 67 fc ff ff       	call   80fc69 <sys_page_map>
  810002:	85 c0                	test   %eax,%eax
  810004:	79 3c                	jns    810042 <pgfault+0x124>
				panic("sys_page_map: %e", r);
  810006:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81000a:	c7 44 24 08 bc 48 81 	movl   $0x8148bc,0x8(%esp)
  810011:	00 
  810012:	c7 44 24 04 4d 00 00 	movl   $0x4d,0x4(%esp)
  810019:	00 
  81001a:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  810021:	e8 14 f0 ff ff       	call   80f03a <_panic>
		}

	}
	else
		panic("\nviolation of page fault handler\n");
  810026:	c7 44 24 08 e0 48 81 	movl   $0x8148e0,0x8(%esp)
  81002d:	00 
  81002e:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  810035:	00 
  810036:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  81003d:	e8 f8 ef ff ff       	call   80f03a <_panic>
}
  810042:	83 c4 2c             	add    $0x2c,%esp
  810045:	5b                   	pop    %ebx
  810046:	5e                   	pop    %esi
  810047:	5f                   	pop    %edi
  810048:	5d                   	pop    %ebp
  810049:	c3                   	ret    

0081004a <sf_stack_duppage>:

void
sf_stack_duppage(envid_t dstenv, void *addr)
{
  81004a:	55                   	push   %ebp
  81004b:	89 e5                	mov    %esp,%ebp
  81004d:	56                   	push   %esi
  81004e:	53                   	push   %ebx
  81004f:	83 ec 20             	sub    $0x20,%esp
  810052:	8b 75 08             	mov    0x8(%ebp),%esi
  810055:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	// This is NOT what you should do in your fork.
	//cprintf("\nsf_stack_duppage\n");
	if ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) < 0)
  810058:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  81005f:	00 
  810060:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810064:	89 34 24             	mov    %esi,(%esp)
  810067:	e8 a9 fb ff ff       	call   80fc15 <sys_page_alloc>
  81006c:	85 c0                	test   %eax,%eax
  81006e:	79 20                	jns    810090 <sf_stack_duppage+0x46>
		panic("sys_page_alloc: %e", r);
  810070:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810074:	c7 44 24 08 a9 48 81 	movl   $0x8148a9,0x8(%esp)
  81007b:	00 
  81007c:	c7 44 24 04 5d 00 00 	movl   $0x5d,0x4(%esp)
  810083:	00 
  810084:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  81008b:	e8 aa ef ff ff       	call   80f03a <_panic>
	if ((r = sys_page_map(dstenv, addr, 0, UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
  810090:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  810097:	00 
  810098:	c7 44 24 0c 00 00 40 	movl   $0x400000,0xc(%esp)
  81009f:	00 
  8100a0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8100a7:	00 
  8100a8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8100ac:	89 34 24             	mov    %esi,(%esp)
  8100af:	e8 b5 fb ff ff       	call   80fc69 <sys_page_map>
  8100b4:	85 c0                	test   %eax,%eax
  8100b6:	79 20                	jns    8100d8 <sf_stack_duppage+0x8e>
		panic("sys_page_map: %e", r);
  8100b8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8100bc:	c7 44 24 08 bc 48 81 	movl   $0x8148bc,0x8(%esp)
  8100c3:	00 
  8100c4:	c7 44 24 04 5f 00 00 	movl   $0x5f,0x4(%esp)
  8100cb:	00 
  8100cc:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  8100d3:	e8 62 ef ff ff       	call   80f03a <_panic>
	memmove(UTEMP, addr, PGSIZE);
  8100d8:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  8100df:	00 
  8100e0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8100e4:	c7 04 24 00 00 40 00 	movl   $0x400000,(%esp)
  8100eb:	e8 54 f8 ff ff       	call   80f944 <memmove>
	if ((r = sys_page_unmap(0, UTEMP)) < 0)
  8100f0:	c7 44 24 04 00 00 40 	movl   $0x400000,0x4(%esp)
  8100f7:	00 
  8100f8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8100ff:	e8 b8 fb ff ff       	call   80fcbc <sys_page_unmap>
  810104:	85 c0                	test   %eax,%eax
  810106:	79 20                	jns    810128 <sf_stack_duppage+0xde>
		panic("sys_page_unmap: %e", r);
  810108:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81010c:	c7 44 24 08 cd 48 81 	movl   $0x8148cd,0x8(%esp)
  810113:	00 
  810114:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  81011b:	00 
  81011c:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  810123:	e8 12 ef ff ff       	call   80f03a <_panic>

}
  810128:	83 c4 20             	add    $0x20,%esp
  81012b:	5b                   	pop    %ebx
  81012c:	5e                   	pop    %esi
  81012d:	5d                   	pop    %ebp
  81012e:	c3                   	ret    

0081012f <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  81012f:	55                   	push   %ebp
  810130:	89 e5                	mov    %esp,%ebp
  810132:	57                   	push   %edi
  810133:	56                   	push   %esi
  810134:	53                   	push   %ebx
  810135:	83 ec 2c             	sub    $0x2c,%esp
	pde_t pdentry=0;
	uintptr_t addr=0;
	int pdindex = 0, pte_perm=0, pte_loop=0;
	int r=-1;
	//cprintf("\nin fork envid:%x\n", thisenv->env_id);
	set_pgfault_handler(pgfault);
  810138:	c7 04 24 1e ff 80 00 	movl   $0x80ff1e,(%esp)
  81013f:	e8 92 1a 00 00       	call   811bd6 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  810144:	b8 08 00 00 00       	mov    $0x8,%eax
  810149:	cd 30                	int    $0x30
  81014b:	89 c6                	mov    %eax,%esi
  81014d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if((envid=sys_exofork())<0)
  810150:	85 c0                	test   %eax,%eax
  810152:	79 20                	jns    810174 <fork+0x45>
		panic("\nCannot create a child process:%e\n",envid);
  810154:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810158:	c7 44 24 08 04 49 81 	movl   $0x814904,0x8(%esp)
  81015f:	00 
  810160:	c7 44 24 04 cb 00 00 	movl   $0xcb,0x4(%esp)
  810167:	00 
  810168:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  81016f:	e8 c6 ee ff ff       	call   80f03a <_panic>
	//cprintf("\nenvid of newly created child:%x\n",envid);
	if (envid == 0) {
  810174:	bb 00 00 00 00       	mov    $0x0,%ebx
  810179:	85 c0                	test   %eax,%eax
  81017b:	75 21                	jne    81019e <fork+0x6f>
		// We're the child.
		// The copied value of the global variable 'thisenv'
		// is no longer valid (it refers to the parent!).
		// Fix it and return 0.
		thisenv = &envs[ENVX(sys_getenvid())];
  81017d:	e8 55 fa ff ff       	call   80fbd7 <sys_getenvid>
  810182:	25 ff 03 00 00       	and    $0x3ff,%eax
  810187:	6b c0 7c             	imul   $0x7c,%eax,%eax
  81018a:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  81018f:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c
		//set_pgfault_handler(pgfault);
		return 0;
  810194:	b8 00 00 00 00       	mov    $0x0,%eax
  810199:	e9 88 01 00 00       	jmp    810326 <fork+0x1f7>
	//Incrementing by PGSIZE in loop because 1 page of pgsize corresponds to 1 page taable entry
	//Incrementing the address by 4MB because uvpd has no entry means 1 uvpd->4 MB region so need to skip it.
	while(addr<(UXSTACKTOP-PGSIZE))
	{
		//cprintf("parent address:%x",addr);
		if(uvpd[PDX(addr)] & PTE_P)
  81019e:	89 d8                	mov    %ebx,%eax
  8101a0:	c1 e8 16             	shr    $0x16,%eax
  8101a3:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  8101aa:	a8 01                	test   $0x1,%al
  8101ac:	0f 84 e0 00 00 00    	je     810292 <fork+0x163>
		{
			if(uvpt[PGNUM(addr)] & PTE_P)
  8101b2:	89 df                	mov    %ebx,%edi
  8101b4:	c1 ef 0c             	shr    $0xc,%edi
  8101b7:	8b 04 bd 00 00 40 ef 	mov    -0x10c00000(,%edi,4),%eax
  8101be:	a8 01                	test   $0x1,%al
  8101c0:	0f 84 c4 00 00 00    	je     81028a <fork+0x15b>
	int perm = PTE_P|PTE_U;  //this will keep genuine read as read ony pages. Neither child or parent can edit it.
	uintptr_t addr;
	envid_t eid=-1;
	int next_check = 1;
	//extract the the page table entry from uvpt to check the permissions of page mapped at virtual address pn*PGSIZE
	addr = uvpt[pn]; //page table entry for the page(data page)
  8101c6:	8b 04 bd 00 00 40 ef 	mov    -0x10c00000(,%edi,4),%eax
	//need to check whether the entry is write or cow orread
	///cprintf("\norig perm:%x\n",PGOFF(addr));

	if((addr & PTE_SYSCALL) & PTE_SHARE){
  8101cd:	f6 c4 04             	test   $0x4,%ah
  8101d0:	74 0d                	je     8101df <fork+0xb0>
		perm |= (addr & PTE_SYSCALL); //not sure whether to and with fff or PTE_SYSCALL
  8101d2:	25 07 0e 00 00       	and    $0xe07,%eax
  8101d7:	83 c8 05             	or     $0x5,%eax
  8101da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8101dd:	eb 1b                	jmp    8101fa <fork+0xcb>
		next_check=0;
	}

	if(((addr & PTE_W) || (addr & PTE_COW)) & next_check)
  8101df:	25 02 08 00 00       	and    $0x802,%eax
//
static int
duppage(envid_t envid, unsigned pn)
{
	int r;
	int perm = PTE_P|PTE_U;  //this will keep genuine read as read ony pages. Neither child or parent can edit it.
  8101e4:	83 f8 01             	cmp    $0x1,%eax
  8101e7:	19 c0                	sbb    %eax,%eax
  8101e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8101ec:	81 65 e4 00 f8 ff ff 	andl   $0xfffff800,-0x1c(%ebp)
  8101f3:	81 45 e4 05 08 00 00 	addl   $0x805,-0x1c(%ebp)
		perm |= PTE_COW;
	}

	//realligning the virtual address to page boundary
	//basically shifting 12 bits to left to make it correct virtual address
	addr = pn *PGSIZE;
  8101fa:	c1 e7 0c             	shl    $0xc,%edi
	//cprintf("\nperm:%x \npn:%p \naddr:%p\n",perm, pn, addr);
	//eid = sys_getenvid();
	//cprintf("\nchecking source - envid:%d - %d.\ndestn:%d", eid, thisenv->env_id, envid);
	//cprintf("add:%p envid:%d",addr, thisenv->env_id);
	//So in dest envid we have create page table entry mapping 
	if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, perm)) < 0)
  8101fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810200:	89 44 24 10          	mov    %eax,0x10(%esp)
  810204:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  810208:	8b 45 e0             	mov    -0x20(%ebp),%eax
  81020b:	89 44 24 08          	mov    %eax,0x8(%esp)
  81020f:	89 7c 24 04          	mov    %edi,0x4(%esp)
  810213:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81021a:	e8 4a fa ff ff       	call   80fc69 <sys_page_map>
  81021f:	85 c0                	test   %eax,%eax
  810221:	79 20                	jns    810243 <fork+0x114>
		panic("sys_page_map: %e", r);
  810223:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810227:	c7 44 24 08 bc 48 81 	movl   $0x8148bc,0x8(%esp)
  81022e:	00 
  81022f:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  810236:	00 
  810237:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  81023e:	e8 f7 ed ff ff       	call   80f03a <_panic>
	if ((r = sys_page_map(0, (void *)addr, 0, (void *)addr, perm)) < 0)
  810243:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810246:	89 44 24 10          	mov    %eax,0x10(%esp)
  81024a:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  81024e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810255:	00 
  810256:	89 7c 24 04          	mov    %edi,0x4(%esp)
  81025a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810261:	e8 03 fa ff ff       	call   80fc69 <sys_page_map>
  810266:	85 c0                	test   %eax,%eax
  810268:	79 20                	jns    81028a <fork+0x15b>
		panic("sys_page_map: %e", r);
  81026a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81026e:	c7 44 24 08 bc 48 81 	movl   $0x8148bc,0x8(%esp)
  810275:	00 
  810276:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  81027d:	00 
  81027e:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  810285:	e8 b0 ed ff ff       	call   80f03a <_panic>
			if(uvpt[PGNUM(addr)] & PTE_P)
			{
				//cprintf("\ncalling duppgae for address %x\n",addr);
				duppage(envid, PGNUM(addr));
			}
			addr += PGSIZE;
  81028a:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  810290:	eb 06                	jmp    810298 <fork+0x169>
		}
		else
		{
			addr = addr + PTSIZE;
  810292:	81 c3 00 00 40 00    	add    $0x400000,%ebx
		//set_pgfault_handler(pgfault);
		return 0;
	}
	//Incrementing by PGSIZE in loop because 1 page of pgsize corresponds to 1 page taable entry
	//Incrementing the address by 4MB because uvpd has no entry means 1 uvpd->4 MB region so need to skip it.
	while(addr<(UXSTACKTOP-PGSIZE))
  810298:	81 fb ff ef bf ee    	cmp    $0xeebfefff,%ebx
  81029e:	0f 86 fa fe ff ff    	jbe    81019e <fork+0x6f>
		{
			addr = addr + PTSIZE;
		}
	}

	if ((r = sys_page_alloc(envid,(void *)UXSTACKTOP-PGSIZE, PTE_P|PTE_U|PTE_W)) < 0)
  8102a4:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  8102ab:	00 
  8102ac:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  8102b3:	ee 
  8102b4:	89 34 24             	mov    %esi,(%esp)
  8102b7:	e8 59 f9 ff ff       	call   80fc15 <sys_page_alloc>
  8102bc:	85 c0                	test   %eax,%eax
  8102be:	79 20                	jns    8102e0 <fork+0x1b1>
		panic("sys_page_alloc: %e", r);
  8102c0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8102c4:	c7 44 24 08 a9 48 81 	movl   $0x8148a9,0x8(%esp)
  8102cb:	00 
  8102cc:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  8102d3:	00 
  8102d4:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  8102db:	e8 5a ed ff ff       	call   80f03a <_panic>
	if ((r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall)) < 0)
  8102e0:	c7 44 24 04 69 1c 81 	movl   $0x811c69,0x4(%esp)
  8102e7:	00 
  8102e8:	89 34 24             	mov    %esi,(%esp)
  8102eb:	e8 e5 fa ff ff       	call   80fdd5 <sys_env_set_pgfault_upcall>
  8102f0:	85 c0                	test   %eax,%eax
  8102f2:	79 20                	jns    810314 <fork+0x1e5>
		panic("pagefault upcall setup error: %e", r);
  8102f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8102f8:	c7 44 24 08 28 49 81 	movl   $0x814928,0x8(%esp)
  8102ff:	00 
  810300:	c7 44 24 04 ed 00 00 	movl   $0xed,0x4(%esp)
  810307:	00 
  810308:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  81030f:	e8 26 ed ff ff       	call   80f03a <_panic>
	sys_env_set_status(envid, ENV_RUNNABLE);
  810314:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  81031b:	00 
  81031c:	89 34 24             	mov    %esi,(%esp)
  81031f:	e8 0b fa ff ff       	call   80fd2f <sys_env_set_status>
	//cprintf("\n fork exiting - envid:%x\n",thisenv->env_id);
	return envid;
  810324:	89 f0                	mov    %esi,%eax

}
  810326:	83 c4 2c             	add    $0x2c,%esp
  810329:	5b                   	pop    %ebx
  81032a:	5e                   	pop    %esi
  81032b:	5f                   	pop    %edi
  81032c:	5d                   	pop    %ebp
  81032d:	c3                   	ret    

0081032e <sfork>:

// Challenge!
int
sfork(void)
{
  81032e:	55                   	push   %ebp
  81032f:	89 e5                	mov    %esp,%ebp
  810331:	57                   	push   %edi
  810332:	56                   	push   %esi
  810333:	53                   	push   %ebx
  810334:	83 ec 2c             	sub    $0x2c,%esp
	pde_t pdentry=0;
	uintptr_t addr=0;
	int pdindex = 0, pte_perm=0, pte_loop=0;
	int r=-1;

	set_pgfault_handler(pgfault);
  810337:	c7 04 24 1e ff 80 00 	movl   $0x80ff1e,(%esp)
  81033e:	e8 93 18 00 00       	call   811bd6 <set_pgfault_handler>
  810343:	b8 08 00 00 00       	mov    $0x8,%eax
  810348:	cd 30                	int    $0x30
  81034a:	89 c6                	mov    %eax,%esi
	if((envid=sys_exofork())<0)
  81034c:	85 c0                	test   %eax,%eax
  81034e:	79 20                	jns    810370 <sfork+0x42>
		panic("\nCannot create a child process:%e\n",envid);
  810350:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810354:	c7 44 24 08 04 49 81 	movl   $0x814904,0x8(%esp)
  81035b:	00 
  81035c:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  810363:	00 
  810364:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  81036b:	e8 ca ec ff ff       	call   80f03a <_panic>
  810370:	89 c7                	mov    %eax,%edi
	//cprintf("\nenvid of newly created child:%x\n",envid);
	if (envid == 0) {
  810372:	bb 00 00 00 00       	mov    $0x0,%ebx
  810377:	85 c0                	test   %eax,%eax
  810379:	75 2d                	jne    8103a8 <sfork+0x7a>
		// We're the child.
		// The copied value of the global variable 'thisenv'
		// is no longer valid (it refers to the parent!).
		// Fix it and return 0.
		thisenv = &envs[ENVX(sys_getenvid())];
  81037b:	e8 57 f8 ff ff       	call   80fbd7 <sys_getenvid>
  810380:	25 ff 03 00 00       	and    $0x3ff,%eax
  810385:	6b c0 7c             	imul   $0x7c,%eax,%eax
  810388:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  81038d:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c
		set_pgfault_handler(pgfault);
  810392:	c7 04 24 1e ff 80 00 	movl   $0x80ff1e,(%esp)
  810399:	e8 38 18 00 00       	call   811bd6 <set_pgfault_handler>
		return 0;
  81039e:	b8 00 00 00 00       	mov    $0x0,%eax
  8103a3:	e9 1d 01 00 00       	jmp    8104c5 <sfork+0x197>
	//Incrementing by PGSIZE in loop because 1 page of pgsize corresponds to 1 page taable entry
	//Incrementing the address by 4MB because uvpd has no entry means 1 uvpd->4 MB region so need to skip it.
	while(addr<(USTACKTOP-PGSIZE))
	{
		//cprintf("parent address:%x",addr);
		if(uvpd[PDX(addr)] & PTE_P)
  8103a8:	89 d8                	mov    %ebx,%eax
  8103aa:	c1 e8 16             	shr    $0x16,%eax
  8103ad:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  8103b4:	a8 01                	test   $0x1,%al
  8103b6:	74 69                	je     810421 <sfork+0xf3>
		{
			if(uvpt[PGNUM(addr)] & PTE_P)
  8103b8:	89 d8                	mov    %ebx,%eax
  8103ba:	c1 e8 0c             	shr    $0xc,%eax
  8103bd:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  8103c4:	f6 c2 01             	test   $0x1,%dl
  8103c7:	74 50                	je     810419 <sfork+0xeb>
	int r;
	int perm = PTE_P|PTE_U;  //this will keep genuine read as read ony pages. Neither child or parent can edit it.
	uintptr_t addr;
	envid_t eid=-1;
	//extract the the page table entry from uvpt to check the permissions of page mapped at virtual address pn*PGSIZE
	addr = uvpt[pn]; //page table entry for the page(data page)
  8103c9:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
	
	perm = PGOFF(addr) & PTE_SYSCALL;

	//realligning the virtual address to page boundary
	//basically shifting 12 bits to left to make it correct virtual address
	addr = pn *PGSIZE;
  8103d0:	c1 e0 0c             	shl    $0xc,%eax
	envid_t eid=-1;
	//extract the the page table entry from uvpt to check the permissions of page mapped at virtual address pn*PGSIZE
	addr = uvpt[pn]; //page table entry for the page(data page)
	//need to check whether the entry is write or cow orread
	
	perm = PGOFF(addr) & PTE_SYSCALL;
  8103d3:	81 e2 07 0e 00 00    	and    $0xe07,%edx

	//realligning the virtual address to page boundary
	//basically shifting 12 bits to left to make it correct virtual address
	addr = pn *PGSIZE;
	//cprintf("\nperm:%x \npn:%p \naddr:%p\n",perm, pn, addr);
	if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, perm)) < 0)
  8103d9:	89 54 24 10          	mov    %edx,0x10(%esp)
  8103dd:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8103e1:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8103e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8103e9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8103f0:	e8 74 f8 ff ff       	call   80fc69 <sys_page_map>
  8103f5:	85 c0                	test   %eax,%eax
  8103f7:	79 20                	jns    810419 <sfork+0xeb>
		panic("sys_page_map: %e", r);
  8103f9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8103fd:	c7 44 24 08 bc 48 81 	movl   $0x8148bc,0x8(%esp)
  810404:	00 
  810405:	c7 44 24 04 a8 00 00 	movl   $0xa8,0x4(%esp)
  81040c:	00 
  81040d:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  810414:	e8 21 ec ff ff       	call   80f03a <_panic>
			if(uvpt[PGNUM(addr)] & PTE_P)
			{
				//cprintf("\ncalling duppgae for address %x\n",addr);
				s_duppage(envid, PGNUM(addr));
			}
			addr += PGSIZE;
  810419:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  81041f:	eb 06                	jmp    810427 <sfork+0xf9>
		}
		else
		{
			addr = addr + PTSIZE;
  810421:	81 c3 00 00 40 00    	add    $0x400000,%ebx
		set_pgfault_handler(pgfault);
		return 0;
	}
	//Incrementing by PGSIZE in loop because 1 page of pgsize corresponds to 1 page taable entry
	//Incrementing the address by 4MB because uvpd has no entry means 1 uvpd->4 MB region so need to skip it.
	while(addr<(USTACKTOP-PGSIZE))
  810427:	81 fb ff cf bf ee    	cmp    $0xeebfcfff,%ebx
  81042d:	0f 86 75 ff ff ff    	jbe    8103a8 <sfork+0x7a>
		{
			addr = addr + PTSIZE;
		}
	}

	sf_stack_duppage(envid, (void *)USTACKTOP-PGSIZE);
  810433:	c7 44 24 04 00 d0 bf 	movl   $0xeebfd000,0x4(%esp)
  81043a:	ee 
  81043b:	89 34 24             	mov    %esi,(%esp)
  81043e:	e8 07 fc ff ff       	call   81004a <sf_stack_duppage>
			s_duppage(envid, PGNUM(addr));
		}
		addr += PGSIZE;
	}*/

	if ((r = sys_page_alloc(envid,(void *)UXSTACKTOP-PGSIZE, PTE_P|PTE_U|PTE_W)) < 0)
  810443:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  81044a:	00 
  81044b:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  810452:	ee 
  810453:	89 34 24             	mov    %esi,(%esp)
  810456:	e8 ba f7 ff ff       	call   80fc15 <sys_page_alloc>
  81045b:	85 c0                	test   %eax,%eax
  81045d:	79 20                	jns    81047f <sfork+0x151>
		panic("sys_page_alloc: %e", r);
  81045f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810463:	c7 44 24 08 a9 48 81 	movl   $0x8148a9,0x8(%esp)
  81046a:	00 
  81046b:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  810472:	00 
  810473:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  81047a:	e8 bb eb ff ff       	call   80f03a <_panic>

	
	if ((r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall)) < 0)
  81047f:	c7 44 24 04 69 1c 81 	movl   $0x811c69,0x4(%esp)
  810486:	00 
  810487:	89 34 24             	mov    %esi,(%esp)
  81048a:	e8 46 f9 ff ff       	call   80fdd5 <sys_env_set_pgfault_upcall>
  81048f:	85 c0                	test   %eax,%eax
  810491:	79 20                	jns    8104b3 <sfork+0x185>
		panic("pagefault upcall setup error: %e", r);
  810493:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810497:	c7 44 24 08 28 49 81 	movl   $0x814928,0x8(%esp)
  81049e:	00 
  81049f:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  8104a6:	00 
  8104a7:	c7 04 24 9e 48 81 00 	movl   $0x81489e,(%esp)
  8104ae:	e8 87 eb ff ff       	call   80f03a <_panic>
	sys_env_set_status(envid, ENV_RUNNABLE);
  8104b3:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  8104ba:	00 
  8104bb:	89 34 24             	mov    %esi,(%esp)
  8104be:	e8 6c f8 ff ff       	call   80fd2f <sys_env_set_status>
	return envid;
  8104c3:	89 f0                	mov    %esi,%eax

}
  8104c5:	83 c4 2c             	add    $0x2c,%esp
  8104c8:	5b                   	pop    %ebx
  8104c9:	5e                   	pop    %esi
  8104ca:	5f                   	pop    %edi
  8104cb:	5d                   	pop    %ebp
  8104cc:	c3                   	ret    
  8104cd:	66 90                	xchg   %ax,%ax
  8104cf:	90                   	nop

008104d0 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  8104d0:	55                   	push   %ebp
  8104d1:	89 e5                	mov    %esp,%ebp
  8104d3:	56                   	push   %esi
  8104d4:	53                   	push   %ebx
  8104d5:	83 ec 10             	sub    $0x10,%esp
  8104d8:	8b 75 08             	mov    0x8(%ebp),%esi
  8104db:	8b 45 0c             	mov    0xc(%ebp),%eax
  8104de:	8b 5d 10             	mov    0x10(%ebp),%ebx
	//env_upd = &envs[ENVX(sys_getenvid())];
	//thisenv = env_upd;
	//Setting pg > UTOP if pg ==NULL
	//This indicates that receiver don't need page mapping
	//cprintf("\n receiver got control id:%x\n",thisenv->env_id);
	if(pg == NULL)
  8104e1:	85 c0                	test   %eax,%eax
		pg = (void *)0xF0000000;
  8104e3:	ba 00 00 00 f0       	mov    $0xf0000000,%edx
  8104e8:	0f 44 c2             	cmove  %edx,%eax
	ret = sys_ipc_recv(pg);
  8104eb:	89 04 24             	mov    %eax,(%esp)
  8104ee:	e8 58 f9 ff ff       	call   80fe4b <sys_ipc_recv>
	//cprintf("\nreceived ret:%d envid:%x\n",ret, thisenv->env_id);
	if(!ret)
  8104f3:	85 c0                	test   %eax,%eax
  8104f5:	75 26                	jne    81051d <ipc_recv+0x4d>
	{
		//successfully received the message
		if(from_env_store)
  8104f7:	85 f6                	test   %esi,%esi
  8104f9:	74 0a                	je     810505 <ipc_recv+0x35>
			*from_env_store = thisenv->env_ipc_from;
  8104fb:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  810500:	8b 40 74             	mov    0x74(%eax),%eax
  810503:	89 06                	mov    %eax,(%esi)
		if(perm_store)
  810505:	85 db                	test   %ebx,%ebx
  810507:	74 0a                	je     810513 <ipc_recv+0x43>
			*perm_store = thisenv->env_ipc_perm;
  810509:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  81050e:	8b 40 78             	mov    0x78(%eax),%eax
  810511:	89 03                	mov    %eax,(%ebx)
		return thisenv->env_ipc_value;
  810513:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  810518:	8b 40 70             	mov    0x70(%eax),%eax
  81051b:	eb 14                	jmp    810531 <ipc_recv+0x61>
	}
	else
	{
		if(from_env_store)
  81051d:	85 f6                	test   %esi,%esi
  81051f:	74 06                	je     810527 <ipc_recv+0x57>
			*from_env_store = 0;
  810521:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if(perm_store)
  810527:	85 db                	test   %ebx,%ebx
  810529:	74 06                	je     810531 <ipc_recv+0x61>
			*perm_store = 0;
  81052b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		return ret;
	}

	return ret;
}
  810531:	83 c4 10             	add    $0x10,%esp
  810534:	5b                   	pop    %ebx
  810535:	5e                   	pop    %esi
  810536:	5d                   	pop    %ebp
  810537:	c3                   	ret    

00810538 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  810538:	55                   	push   %ebp
  810539:	89 e5                	mov    %esp,%ebp
  81053b:	57                   	push   %edi
  81053c:	56                   	push   %esi
  81053d:	53                   	push   %ebx
  81053e:	83 ec 1c             	sub    $0x1c,%esp
  810541:	8b 7d 08             	mov    0x8(%ebp),%edi
  810544:	8b 75 0c             	mov    0xc(%ebp),%esi
  810547:	8b 5d 10             	mov    0x10(%ebp),%ebx

	//env_upd = &envs[ENVX(sys_getenvid())];
	//thisenv = env_upd;
	//Setting pg > UTOP if pg ==NULL
	//This indicates that receiver don't need page mapping
	if(pg == NULL)
  81054a:	85 db                	test   %ebx,%ebx
		pg = (void *)0xF0000000;
  81054c:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
  810551:	0f 44 d8             	cmove  %eax,%ebx
	while(1)
	{
		//cprintf("\nsend-ipc trying send env_id:%x\n",thisenv->env_id);
		ret = sys_ipc_try_send(to_env, val, pg, perm);
  810554:	8b 45 14             	mov    0x14(%ebp),%eax
  810557:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81055b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81055f:	89 74 24 04          	mov    %esi,0x4(%esp)
  810563:	89 3c 24             	mov    %edi,(%esp)
  810566:	e8 bd f8 ff ff       	call   80fe28 <sys_ipc_try_send>
		//cprintf("\nsend return value:%d env_id:%x\n",ret, thisenv->env_id);
		if(ret==0)
  81056b:	85 c0                	test   %eax,%eax
  81056d:	74 28                	je     810597 <ipc_send+0x5f>
			break;
		else if(ret != -E_IPC_NOT_RECV){
  81056f:	83 f8 f9             	cmp    $0xfffffff9,%eax
  810572:	74 1c                	je     810590 <ipc_send+0x58>
			panic("\nError while sending IPC message");
  810574:	c7 44 24 08 4c 49 81 	movl   $0x81494c,0x8(%esp)
  81057b:	00 
  81057c:	c7 44 24 04 5a 00 00 	movl   $0x5a,0x4(%esp)
  810583:	00 
  810584:	c7 04 24 6d 49 81 00 	movl   $0x81496d,(%esp)
  81058b:	e8 aa ea ff ff       	call   80f03a <_panic>
		}
		//cprintf("\nsend yielding:%x", thisenv->env_id);
		sys_yield();			
  810590:	e8 61 f6 ff ff       	call   80fbf6 <sys_yield>
	}
  810595:	eb bd                	jmp    810554 <ipc_send+0x1c>
	//sys_yield();
	//cprintf("\nsender successfully yielding\n");
	//sys_yield();
	//cprintf("\nexiting send\n");
	
}
  810597:	83 c4 1c             	add    $0x1c,%esp
  81059a:	5b                   	pop    %ebx
  81059b:	5e                   	pop    %esi
  81059c:	5f                   	pop    %edi
  81059d:	5d                   	pop    %ebp
  81059e:	c3                   	ret    

0081059f <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  81059f:	55                   	push   %ebp
  8105a0:	89 e5                	mov    %esp,%ebp
  8105a2:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  8105a5:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  8105aa:	6b d0 7c             	imul   $0x7c,%eax,%edx
  8105ad:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  8105b3:	8b 52 50             	mov    0x50(%edx),%edx
  8105b6:	39 ca                	cmp    %ecx,%edx
  8105b8:	75 0d                	jne    8105c7 <ipc_find_env+0x28>
			return envs[i].env_id;
  8105ba:	6b c0 7c             	imul   $0x7c,%eax,%eax
  8105bd:	05 08 00 c0 ee       	add    $0xeec00008,%eax
  8105c2:	8b 40 40             	mov    0x40(%eax),%eax
  8105c5:	eb 0e                	jmp    8105d5 <ipc_find_env+0x36>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  8105c7:	83 c0 01             	add    $0x1,%eax
  8105ca:	3d 00 04 00 00       	cmp    $0x400,%eax
  8105cf:	75 d9                	jne    8105aa <ipc_find_env+0xb>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  8105d1:	66 b8 00 00          	mov    $0x0,%ax
}
  8105d5:	5d                   	pop    %ebp
  8105d6:	c3                   	ret    
  8105d7:	66 90                	xchg   %ax,%ax
  8105d9:	66 90                	xchg   %ax,%ax
  8105db:	66 90                	xchg   %ax,%ax
  8105dd:	66 90                	xchg   %ax,%ax
  8105df:	90                   	nop

008105e0 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  8105e0:	55                   	push   %ebp
  8105e1:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  8105e3:	8b 45 08             	mov    0x8(%ebp),%eax
  8105e6:	05 00 00 00 30       	add    $0x30000000,%eax
  8105eb:	c1 e8 0c             	shr    $0xc,%eax
}
  8105ee:	5d                   	pop    %ebp
  8105ef:	c3                   	ret    

008105f0 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  8105f0:	55                   	push   %ebp
  8105f1:	89 e5                	mov    %esp,%ebp
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  8105f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8105f6:	05 00 00 00 30       	add    $0x30000000,%eax
}

char*
fd2data(struct Fd *fd)
{
	return INDEX2DATA(fd2num(fd));
  8105fb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810600:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  810605:	5d                   	pop    %ebp
  810606:	c3                   	ret    

00810607 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  810607:	55                   	push   %ebp
  810608:	89 e5                	mov    %esp,%ebp
  81060a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81060d:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  810612:	89 c2                	mov    %eax,%edx
  810614:	c1 ea 16             	shr    $0x16,%edx
  810617:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  81061e:	f6 c2 01             	test   $0x1,%dl
  810621:	74 11                	je     810634 <fd_alloc+0x2d>
  810623:	89 c2                	mov    %eax,%edx
  810625:	c1 ea 0c             	shr    $0xc,%edx
  810628:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  81062f:	f6 c2 01             	test   $0x1,%dl
  810632:	75 09                	jne    81063d <fd_alloc+0x36>
			*fd_store = fd;
  810634:	89 01                	mov    %eax,(%ecx)
			return 0;
  810636:	b8 00 00 00 00       	mov    $0x0,%eax
  81063b:	eb 17                	jmp    810654 <fd_alloc+0x4d>
  81063d:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  810642:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  810647:	75 c9                	jne    810612 <fd_alloc+0xb>
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  810649:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return -E_MAX_OPEN;
  81064f:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  810654:	5d                   	pop    %ebp
  810655:	c3                   	ret    

00810656 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  810656:	55                   	push   %ebp
  810657:	89 e5                	mov    %esp,%ebp
  810659:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  81065c:	83 f8 1f             	cmp    $0x1f,%eax
  81065f:	77 36                	ja     810697 <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  810661:	c1 e0 0c             	shl    $0xc,%eax
  810664:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  810669:	89 c2                	mov    %eax,%edx
  81066b:	c1 ea 16             	shr    $0x16,%edx
  81066e:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  810675:	f6 c2 01             	test   $0x1,%dl
  810678:	74 24                	je     81069e <fd_lookup+0x48>
  81067a:	89 c2                	mov    %eax,%edx
  81067c:	c1 ea 0c             	shr    $0xc,%edx
  81067f:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  810686:	f6 c2 01             	test   $0x1,%dl
  810689:	74 1a                	je     8106a5 <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  81068b:	8b 55 0c             	mov    0xc(%ebp),%edx
  81068e:	89 02                	mov    %eax,(%edx)
	return 0;
  810690:	b8 00 00 00 00       	mov    $0x0,%eax
  810695:	eb 13                	jmp    8106aa <fd_lookup+0x54>
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  810697:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  81069c:	eb 0c                	jmp    8106aa <fd_lookup+0x54>
	}
	fd = INDEX2FD(fdnum);
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  81069e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8106a3:	eb 05                	jmp    8106aa <fd_lookup+0x54>
  8106a5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	}
	*fd_store = fd;
	return 0;
}
  8106aa:	5d                   	pop    %ebp
  8106ab:	c3                   	ret    

008106ac <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  8106ac:	55                   	push   %ebp
  8106ad:	89 e5                	mov    %esp,%ebp
  8106af:	83 ec 18             	sub    $0x18,%esp
  8106b2:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  8106b5:	ba 00 00 00 00       	mov    $0x0,%edx
  8106ba:	eb 13                	jmp    8106cf <dev_lookup+0x23>
		if (devtab[i]->dev_id == dev_id) {
  8106bc:	39 08                	cmp    %ecx,(%eax)
  8106be:	75 0c                	jne    8106cc <dev_lookup+0x20>
			*dev = devtab[i];
  8106c0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8106c3:	89 01                	mov    %eax,(%ecx)
			return 0;
  8106c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8106ca:	eb 38                	jmp    810704 <dev_lookup+0x58>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8106cc:	83 c2 01             	add    $0x1,%edx
  8106cf:	8b 04 95 f4 49 81 00 	mov    0x8149f4(,%edx,4),%eax
  8106d6:	85 c0                	test   %eax,%eax
  8106d8:	75 e2                	jne    8106bc <dev_lookup+0x10>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8106da:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  8106df:	8b 40 48             	mov    0x48(%eax),%eax
  8106e2:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8106e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8106ea:	c7 04 24 78 49 81 00 	movl   $0x814978,(%esp)
  8106f1:	e8 3d ea ff ff       	call   80f133 <cprintf>
	*dev = 0;
  8106f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106f9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  8106ff:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  810704:	c9                   	leave  
  810705:	c3                   	ret    

00810706 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  810706:	55                   	push   %ebp
  810707:	89 e5                	mov    %esp,%ebp
  810709:	56                   	push   %esi
  81070a:	53                   	push   %ebx
  81070b:	83 ec 20             	sub    $0x20,%esp
  81070e:	8b 75 08             	mov    0x8(%ebp),%esi
  810711:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  810714:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810717:	89 44 24 04          	mov    %eax,0x4(%esp)
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  81071b:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  810721:	c1 e8 0c             	shr    $0xc,%eax
fd_close(struct Fd *fd, bool must_exist)
{
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  810724:	89 04 24             	mov    %eax,(%esp)
  810727:	e8 2a ff ff ff       	call   810656 <fd_lookup>
  81072c:	85 c0                	test   %eax,%eax
  81072e:	78 05                	js     810735 <fd_close+0x2f>
	    || fd != fd2)
  810730:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  810733:	74 0c                	je     810741 <fd_close+0x3b>
		return (must_exist ? r : 0);
  810735:	84 db                	test   %bl,%bl
  810737:	ba 00 00 00 00       	mov    $0x0,%edx
  81073c:	0f 44 c2             	cmove  %edx,%eax
  81073f:	eb 3f                	jmp    810780 <fd_close+0x7a>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  810741:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810744:	89 44 24 04          	mov    %eax,0x4(%esp)
  810748:	8b 06                	mov    (%esi),%eax
  81074a:	89 04 24             	mov    %eax,(%esp)
  81074d:	e8 5a ff ff ff       	call   8106ac <dev_lookup>
  810752:	89 c3                	mov    %eax,%ebx
  810754:	85 c0                	test   %eax,%eax
  810756:	78 16                	js     81076e <fd_close+0x68>
		if (dev->dev_close)
  810758:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81075b:	8b 40 10             	mov    0x10(%eax),%eax
			r = (*dev->dev_close)(fd);
		else
			r = 0;
  81075e:	bb 00 00 00 00       	mov    $0x0,%ebx
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
	    || fd != fd2)
		return (must_exist ? r : 0);
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
		if (dev->dev_close)
  810763:	85 c0                	test   %eax,%eax
  810765:	74 07                	je     81076e <fd_close+0x68>
			r = (*dev->dev_close)(fd);
  810767:	89 34 24             	mov    %esi,(%esp)
  81076a:	ff d0                	call   *%eax
  81076c:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  81076e:	89 74 24 04          	mov    %esi,0x4(%esp)
  810772:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810779:	e8 3e f5 ff ff       	call   80fcbc <sys_page_unmap>
	return r;
  81077e:	89 d8                	mov    %ebx,%eax
}
  810780:	83 c4 20             	add    $0x20,%esp
  810783:	5b                   	pop    %ebx
  810784:	5e                   	pop    %esi
  810785:	5d                   	pop    %ebp
  810786:	c3                   	ret    

00810787 <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  810787:	55                   	push   %ebp
  810788:	89 e5                	mov    %esp,%ebp
  81078a:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  81078d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810790:	89 44 24 04          	mov    %eax,0x4(%esp)
  810794:	8b 45 08             	mov    0x8(%ebp),%eax
  810797:	89 04 24             	mov    %eax,(%esp)
  81079a:	e8 b7 fe ff ff       	call   810656 <fd_lookup>
  81079f:	89 c2                	mov    %eax,%edx
  8107a1:	85 d2                	test   %edx,%edx
  8107a3:	78 13                	js     8107b8 <close+0x31>
		return r;
	else
		return fd_close(fd, 1);
  8107a5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8107ac:	00 
  8107ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8107b0:	89 04 24             	mov    %eax,(%esp)
  8107b3:	e8 4e ff ff ff       	call   810706 <fd_close>
}
  8107b8:	c9                   	leave  
  8107b9:	c3                   	ret    

008107ba <close_all>:

void
close_all(void)
{
  8107ba:	55                   	push   %ebp
  8107bb:	89 e5                	mov    %esp,%ebp
  8107bd:	53                   	push   %ebx
  8107be:	83 ec 14             	sub    $0x14,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  8107c1:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  8107c6:	89 1c 24             	mov    %ebx,(%esp)
  8107c9:	e8 b9 ff ff ff       	call   810787 <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  8107ce:	83 c3 01             	add    $0x1,%ebx
  8107d1:	83 fb 20             	cmp    $0x20,%ebx
  8107d4:	75 f0                	jne    8107c6 <close_all+0xc>
		close(i);
}
  8107d6:	83 c4 14             	add    $0x14,%esp
  8107d9:	5b                   	pop    %ebx
  8107da:	5d                   	pop    %ebp
  8107db:	c3                   	ret    

008107dc <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  8107dc:	55                   	push   %ebp
  8107dd:	89 e5                	mov    %esp,%ebp
  8107df:	57                   	push   %edi
  8107e0:	56                   	push   %esi
  8107e1:	53                   	push   %ebx
  8107e2:	83 ec 3c             	sub    $0x3c,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  8107e5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8107e8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8107ec:	8b 45 08             	mov    0x8(%ebp),%eax
  8107ef:	89 04 24             	mov    %eax,(%esp)
  8107f2:	e8 5f fe ff ff       	call   810656 <fd_lookup>
  8107f7:	89 c2                	mov    %eax,%edx
  8107f9:	85 d2                	test   %edx,%edx
  8107fb:	0f 88 e1 00 00 00    	js     8108e2 <dup+0x106>
		return r;
	close(newfdnum);
  810801:	8b 45 0c             	mov    0xc(%ebp),%eax
  810804:	89 04 24             	mov    %eax,(%esp)
  810807:	e8 7b ff ff ff       	call   810787 <close>

	newfd = INDEX2FD(newfdnum);
  81080c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  81080f:	c1 e3 0c             	shl    $0xc,%ebx
  810812:	81 eb 00 00 00 30    	sub    $0x30000000,%ebx
	ova = fd2data(oldfd);
  810818:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81081b:	89 04 24             	mov    %eax,(%esp)
  81081e:	e8 cd fd ff ff       	call   8105f0 <fd2data>
  810823:	89 c6                	mov    %eax,%esi
	nva = fd2data(newfd);
  810825:	89 1c 24             	mov    %ebx,(%esp)
  810828:	e8 c3 fd ff ff       	call   8105f0 <fd2data>
  81082d:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  81082f:	89 f0                	mov    %esi,%eax
  810831:	c1 e8 16             	shr    $0x16,%eax
  810834:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  81083b:	a8 01                	test   $0x1,%al
  81083d:	74 43                	je     810882 <dup+0xa6>
  81083f:	89 f0                	mov    %esi,%eax
  810841:	c1 e8 0c             	shr    $0xc,%eax
  810844:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  81084b:	f6 c2 01             	test   $0x1,%dl
  81084e:	74 32                	je     810882 <dup+0xa6>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  810850:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810857:	25 07 0e 00 00       	and    $0xe07,%eax
  81085c:	89 44 24 10          	mov    %eax,0x10(%esp)
  810860:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  810864:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81086b:	00 
  81086c:	89 74 24 04          	mov    %esi,0x4(%esp)
  810870:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810877:	e8 ed f3 ff ff       	call   80fc69 <sys_page_map>
  81087c:	89 c6                	mov    %eax,%esi
  81087e:	85 c0                	test   %eax,%eax
  810880:	78 3e                	js     8108c0 <dup+0xe4>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  810882:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810885:	89 c2                	mov    %eax,%edx
  810887:	c1 ea 0c             	shr    $0xc,%edx
  81088a:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  810891:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  810897:	89 54 24 10          	mov    %edx,0x10(%esp)
  81089b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  81089f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8108a6:	00 
  8108a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8108ab:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8108b2:	e8 b2 f3 ff ff       	call   80fc69 <sys_page_map>
  8108b7:	89 c6                	mov    %eax,%esi
		goto err;

	return newfdnum;
  8108b9:	8b 45 0c             	mov    0xc(%ebp),%eax
	nva = fd2data(newfd);

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8108bc:	85 f6                	test   %esi,%esi
  8108be:	79 22                	jns    8108e2 <dup+0x106>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  8108c0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8108c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8108cb:	e8 ec f3 ff ff       	call   80fcbc <sys_page_unmap>
	sys_page_unmap(0, nva);
  8108d0:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8108d4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8108db:	e8 dc f3 ff ff       	call   80fcbc <sys_page_unmap>
	return r;
  8108e0:	89 f0                	mov    %esi,%eax
}
  8108e2:	83 c4 3c             	add    $0x3c,%esp
  8108e5:	5b                   	pop    %ebx
  8108e6:	5e                   	pop    %esi
  8108e7:	5f                   	pop    %edi
  8108e8:	5d                   	pop    %ebp
  8108e9:	c3                   	ret    

008108ea <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  8108ea:	55                   	push   %ebp
  8108eb:	89 e5                	mov    %esp,%ebp
  8108ed:	53                   	push   %ebx
  8108ee:	83 ec 24             	sub    $0x24,%esp
  8108f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8108f4:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8108f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8108fb:	89 1c 24             	mov    %ebx,(%esp)
  8108fe:	e8 53 fd ff ff       	call   810656 <fd_lookup>
  810903:	89 c2                	mov    %eax,%edx
  810905:	85 d2                	test   %edx,%edx
  810907:	78 6d                	js     810976 <read+0x8c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810909:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81090c:	89 44 24 04          	mov    %eax,0x4(%esp)
  810910:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810913:	8b 00                	mov    (%eax),%eax
  810915:	89 04 24             	mov    %eax,(%esp)
  810918:	e8 8f fd ff ff       	call   8106ac <dev_lookup>
  81091d:	85 c0                	test   %eax,%eax
  81091f:	78 55                	js     810976 <read+0x8c>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  810921:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810924:	8b 50 08             	mov    0x8(%eax),%edx
  810927:	83 e2 03             	and    $0x3,%edx
  81092a:	83 fa 01             	cmp    $0x1,%edx
  81092d:	75 23                	jne    810952 <read+0x68>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  81092f:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  810934:	8b 40 48             	mov    0x48(%eax),%eax
  810937:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81093b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81093f:	c7 04 24 b9 49 81 00 	movl   $0x8149b9,(%esp)
  810946:	e8 e8 e7 ff ff       	call   80f133 <cprintf>
		return -E_INVAL;
  81094b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810950:	eb 24                	jmp    810976 <read+0x8c>
	}
	if (!dev->dev_read)
  810952:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810955:	8b 52 08             	mov    0x8(%edx),%edx
  810958:	85 d2                	test   %edx,%edx
  81095a:	74 15                	je     810971 <read+0x87>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  81095c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  81095f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810963:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810966:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  81096a:	89 04 24             	mov    %eax,(%esp)
  81096d:	ff d2                	call   *%edx
  81096f:	eb 05                	jmp    810976 <read+0x8c>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
		return -E_NOT_SUPP;
  810971:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_read)(fd, buf, n);
}
  810976:	83 c4 24             	add    $0x24,%esp
  810979:	5b                   	pop    %ebx
  81097a:	5d                   	pop    %ebp
  81097b:	c3                   	ret    

0081097c <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  81097c:	55                   	push   %ebp
  81097d:	89 e5                	mov    %esp,%ebp
  81097f:	57                   	push   %edi
  810980:	56                   	push   %esi
  810981:	53                   	push   %ebx
  810982:	83 ec 1c             	sub    $0x1c,%esp
  810985:	8b 7d 08             	mov    0x8(%ebp),%edi
  810988:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  81098b:	bb 00 00 00 00       	mov    $0x0,%ebx
  810990:	eb 23                	jmp    8109b5 <readn+0x39>
		m = read(fdnum, (char*)buf + tot, n - tot);
  810992:	89 f0                	mov    %esi,%eax
  810994:	29 d8                	sub    %ebx,%eax
  810996:	89 44 24 08          	mov    %eax,0x8(%esp)
  81099a:	89 d8                	mov    %ebx,%eax
  81099c:	03 45 0c             	add    0xc(%ebp),%eax
  81099f:	89 44 24 04          	mov    %eax,0x4(%esp)
  8109a3:	89 3c 24             	mov    %edi,(%esp)
  8109a6:	e8 3f ff ff ff       	call   8108ea <read>
		if (m < 0)
  8109ab:	85 c0                	test   %eax,%eax
  8109ad:	78 10                	js     8109bf <readn+0x43>
			return m;
		if (m == 0)
  8109af:	85 c0                	test   %eax,%eax
  8109b1:	74 0a                	je     8109bd <readn+0x41>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8109b3:	01 c3                	add    %eax,%ebx
  8109b5:	39 f3                	cmp    %esi,%ebx
  8109b7:	72 d9                	jb     810992 <readn+0x16>
  8109b9:	89 d8                	mov    %ebx,%eax
  8109bb:	eb 02                	jmp    8109bf <readn+0x43>
  8109bd:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  8109bf:	83 c4 1c             	add    $0x1c,%esp
  8109c2:	5b                   	pop    %ebx
  8109c3:	5e                   	pop    %esi
  8109c4:	5f                   	pop    %edi
  8109c5:	5d                   	pop    %ebp
  8109c6:	c3                   	ret    

008109c7 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  8109c7:	55                   	push   %ebp
  8109c8:	89 e5                	mov    %esp,%ebp
  8109ca:	53                   	push   %ebx
  8109cb:	83 ec 24             	sub    $0x24,%esp
  8109ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8109d1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8109d4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8109d8:	89 1c 24             	mov    %ebx,(%esp)
  8109db:	e8 76 fc ff ff       	call   810656 <fd_lookup>
  8109e0:	89 c2                	mov    %eax,%edx
  8109e2:	85 d2                	test   %edx,%edx
  8109e4:	78 68                	js     810a4e <write+0x87>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8109e6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8109e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8109ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8109f0:	8b 00                	mov    (%eax),%eax
  8109f2:	89 04 24             	mov    %eax,(%esp)
  8109f5:	e8 b2 fc ff ff       	call   8106ac <dev_lookup>
  8109fa:	85 c0                	test   %eax,%eax
  8109fc:	78 50                	js     810a4e <write+0x87>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8109fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810a01:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  810a05:	75 23                	jne    810a2a <write+0x63>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  810a07:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  810a0c:	8b 40 48             	mov    0x48(%eax),%eax
  810a0f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810a13:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a17:	c7 04 24 d5 49 81 00 	movl   $0x8149d5,(%esp)
  810a1e:	e8 10 e7 ff ff       	call   80f133 <cprintf>
		return -E_INVAL;
  810a23:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810a28:	eb 24                	jmp    810a4e <write+0x87>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  810a2a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810a2d:	8b 52 0c             	mov    0xc(%edx),%edx
  810a30:	85 d2                	test   %edx,%edx
  810a32:	74 15                	je     810a49 <write+0x82>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  810a34:	8b 4d 10             	mov    0x10(%ebp),%ecx
  810a37:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810a3b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810a3e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  810a42:	89 04 24             	mov    %eax,(%esp)
  810a45:	ff d2                	call   *%edx
  810a47:	eb 05                	jmp    810a4e <write+0x87>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
		return -E_NOT_SUPP;
  810a49:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_write)(fd, buf, n);
}
  810a4e:	83 c4 24             	add    $0x24,%esp
  810a51:	5b                   	pop    %ebx
  810a52:	5d                   	pop    %ebp
  810a53:	c3                   	ret    

00810a54 <seek>:

int
seek(int fdnum, off_t offset)
{
  810a54:	55                   	push   %ebp
  810a55:	89 e5                	mov    %esp,%ebp
  810a57:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810a5a:	8d 45 fc             	lea    -0x4(%ebp),%eax
  810a5d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a61:	8b 45 08             	mov    0x8(%ebp),%eax
  810a64:	89 04 24             	mov    %eax,(%esp)
  810a67:	e8 ea fb ff ff       	call   810656 <fd_lookup>
  810a6c:	85 c0                	test   %eax,%eax
  810a6e:	78 0e                	js     810a7e <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  810a70:	8b 45 fc             	mov    -0x4(%ebp),%eax
  810a73:	8b 55 0c             	mov    0xc(%ebp),%edx
  810a76:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  810a79:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810a7e:	c9                   	leave  
  810a7f:	c3                   	ret    

00810a80 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  810a80:	55                   	push   %ebp
  810a81:	89 e5                	mov    %esp,%ebp
  810a83:	53                   	push   %ebx
  810a84:	83 ec 24             	sub    $0x24,%esp
  810a87:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  810a8a:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810a8d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a91:	89 1c 24             	mov    %ebx,(%esp)
  810a94:	e8 bd fb ff ff       	call   810656 <fd_lookup>
  810a99:	89 c2                	mov    %eax,%edx
  810a9b:	85 d2                	test   %edx,%edx
  810a9d:	78 61                	js     810b00 <ftruncate+0x80>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810a9f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810aa2:	89 44 24 04          	mov    %eax,0x4(%esp)
  810aa6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810aa9:	8b 00                	mov    (%eax),%eax
  810aab:	89 04 24             	mov    %eax,(%esp)
  810aae:	e8 f9 fb ff ff       	call   8106ac <dev_lookup>
  810ab3:	85 c0                	test   %eax,%eax
  810ab5:	78 49                	js     810b00 <ftruncate+0x80>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  810ab7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810aba:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  810abe:	75 23                	jne    810ae3 <ftruncate+0x63>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  810ac0:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  810ac5:	8b 40 48             	mov    0x48(%eax),%eax
  810ac8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810acc:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ad0:	c7 04 24 98 49 81 00 	movl   $0x814998,(%esp)
  810ad7:	e8 57 e6 ff ff       	call   80f133 <cprintf>
			thisenv->env_id, fdnum);
		return -E_INVAL;
  810adc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810ae1:	eb 1d                	jmp    810b00 <ftruncate+0x80>
	}
	if (!dev->dev_trunc)
  810ae3:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810ae6:	8b 52 18             	mov    0x18(%edx),%edx
  810ae9:	85 d2                	test   %edx,%edx
  810aeb:	74 0e                	je     810afb <ftruncate+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  810aed:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810af0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  810af4:	89 04 24             	mov    %eax,(%esp)
  810af7:	ff d2                	call   *%edx
  810af9:	eb 05                	jmp    810b00 <ftruncate+0x80>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
		return -E_NOT_SUPP;
  810afb:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_trunc)(fd, newsize);
}
  810b00:	83 c4 24             	add    $0x24,%esp
  810b03:	5b                   	pop    %ebx
  810b04:	5d                   	pop    %ebp
  810b05:	c3                   	ret    

00810b06 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  810b06:	55                   	push   %ebp
  810b07:	89 e5                	mov    %esp,%ebp
  810b09:	53                   	push   %ebx
  810b0a:	83 ec 24             	sub    $0x24,%esp
  810b0d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810b10:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810b13:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b17:	8b 45 08             	mov    0x8(%ebp),%eax
  810b1a:	89 04 24             	mov    %eax,(%esp)
  810b1d:	e8 34 fb ff ff       	call   810656 <fd_lookup>
  810b22:	89 c2                	mov    %eax,%edx
  810b24:	85 d2                	test   %edx,%edx
  810b26:	78 52                	js     810b7a <fstat+0x74>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810b28:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810b2b:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810b32:	8b 00                	mov    (%eax),%eax
  810b34:	89 04 24             	mov    %eax,(%esp)
  810b37:	e8 70 fb ff ff       	call   8106ac <dev_lookup>
  810b3c:	85 c0                	test   %eax,%eax
  810b3e:	78 3a                	js     810b7a <fstat+0x74>
		return r;
	if (!dev->dev_stat)
  810b40:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810b43:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  810b47:	74 2c                	je     810b75 <fstat+0x6f>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  810b49:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  810b4c:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  810b53:	00 00 00 
	stat->st_isdir = 0;
  810b56:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810b5d:	00 00 00 
	stat->st_dev = dev;
  810b60:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  810b66:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810b6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810b6d:	89 14 24             	mov    %edx,(%esp)
  810b70:	ff 50 14             	call   *0x14(%eax)
  810b73:	eb 05                	jmp    810b7a <fstat+0x74>

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
  810b75:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	stat->st_name[0] = 0;
	stat->st_size = 0;
	stat->st_isdir = 0;
	stat->st_dev = dev;
	return (*dev->dev_stat)(fd, stat);
}
  810b7a:	83 c4 24             	add    $0x24,%esp
  810b7d:	5b                   	pop    %ebx
  810b7e:	5d                   	pop    %ebp
  810b7f:	c3                   	ret    

00810b80 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  810b80:	55                   	push   %ebp
  810b81:	89 e5                	mov    %esp,%ebp
  810b83:	56                   	push   %esi
  810b84:	53                   	push   %ebx
  810b85:	83 ec 10             	sub    $0x10,%esp
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  810b88:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810b8f:	00 
  810b90:	8b 45 08             	mov    0x8(%ebp),%eax
  810b93:	89 04 24             	mov    %eax,(%esp)
  810b96:	e8 99 02 00 00       	call   810e34 <open>
  810b9b:	89 c3                	mov    %eax,%ebx
  810b9d:	85 db                	test   %ebx,%ebx
  810b9f:	78 1b                	js     810bbc <stat+0x3c>
		return fd;
	r = fstat(fd, stat);
  810ba1:	8b 45 0c             	mov    0xc(%ebp),%eax
  810ba4:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ba8:	89 1c 24             	mov    %ebx,(%esp)
  810bab:	e8 56 ff ff ff       	call   810b06 <fstat>
  810bb0:	89 c6                	mov    %eax,%esi
	close(fd);
  810bb2:	89 1c 24             	mov    %ebx,(%esp)
  810bb5:	e8 cd fb ff ff       	call   810787 <close>
	return r;
  810bba:	89 f0                	mov    %esi,%eax
}
  810bbc:	83 c4 10             	add    $0x10,%esp
  810bbf:	5b                   	pop    %ebx
  810bc0:	5e                   	pop    %esi
  810bc1:	5d                   	pop    %ebp
  810bc2:	c3                   	ret    

00810bc3 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  810bc3:	55                   	push   %ebp
  810bc4:	89 e5                	mov    %esp,%ebp
  810bc6:	56                   	push   %esi
  810bc7:	53                   	push   %ebx
  810bc8:	83 ec 10             	sub    $0x10,%esp
  810bcb:	89 c6                	mov    %eax,%esi
  810bcd:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  810bcf:	83 3d ec c1 b3 00 00 	cmpl   $0x0,0xb3c1ec
  810bd6:	75 11                	jne    810be9 <fsipc+0x26>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  810bd8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  810bdf:	e8 bb f9 ff ff       	call   81059f <ipc_find_env>
  810be4:	a3 ec c1 b3 00       	mov    %eax,0xb3c1ec
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  810be9:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  810bf0:	00 
  810bf1:	c7 44 24 08 00 d0 b3 	movl   $0xb3d000,0x8(%esp)
  810bf8:	00 
  810bf9:	89 74 24 04          	mov    %esi,0x4(%esp)
  810bfd:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  810c02:	89 04 24             	mov    %eax,(%esp)
  810c05:	e8 2e f9 ff ff       	call   810538 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  810c0a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810c11:	00 
  810c12:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810c16:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810c1d:	e8 ae f8 ff ff       	call   8104d0 <ipc_recv>
}
  810c22:	83 c4 10             	add    $0x10,%esp
  810c25:	5b                   	pop    %ebx
  810c26:	5e                   	pop    %esi
  810c27:	5d                   	pop    %ebp
  810c28:	c3                   	ret    

00810c29 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  810c29:	55                   	push   %ebp
  810c2a:	89 e5                	mov    %esp,%ebp
  810c2c:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  810c2f:	8b 45 08             	mov    0x8(%ebp),%eax
  810c32:	8b 40 0c             	mov    0xc(%eax),%eax
  810c35:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.set_size.req_size = newsize;
  810c3a:	8b 45 0c             	mov    0xc(%ebp),%eax
  810c3d:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return fsipc(FSREQ_SET_SIZE, NULL);
  810c42:	ba 00 00 00 00       	mov    $0x0,%edx
  810c47:	b8 02 00 00 00       	mov    $0x2,%eax
  810c4c:	e8 72 ff ff ff       	call   810bc3 <fsipc>
}
  810c51:	c9                   	leave  
  810c52:	c3                   	ret    

00810c53 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  810c53:	55                   	push   %ebp
  810c54:	89 e5                	mov    %esp,%ebp
  810c56:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  810c59:	8b 45 08             	mov    0x8(%ebp),%eax
  810c5c:	8b 40 0c             	mov    0xc(%eax),%eax
  810c5f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return fsipc(FSREQ_FLUSH, NULL);
  810c64:	ba 00 00 00 00       	mov    $0x0,%edx
  810c69:	b8 06 00 00 00       	mov    $0x6,%eax
  810c6e:	e8 50 ff ff ff       	call   810bc3 <fsipc>
}
  810c73:	c9                   	leave  
  810c74:	c3                   	ret    

00810c75 <devfile_stat>:
	return r;
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  810c75:	55                   	push   %ebp
  810c76:	89 e5                	mov    %esp,%ebp
  810c78:	53                   	push   %ebx
  810c79:	83 ec 14             	sub    $0x14,%esp
  810c7c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  810c7f:	8b 45 08             	mov    0x8(%ebp),%eax
  810c82:	8b 40 0c             	mov    0xc(%eax),%eax
  810c85:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  810c8a:	ba 00 00 00 00       	mov    $0x0,%edx
  810c8f:	b8 05 00 00 00       	mov    $0x5,%eax
  810c94:	e8 2a ff ff ff       	call   810bc3 <fsipc>
  810c99:	89 c2                	mov    %eax,%edx
  810c9b:	85 d2                	test   %edx,%edx
  810c9d:	78 2b                	js     810cca <devfile_stat+0x55>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  810c9f:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  810ca6:	00 
  810ca7:	89 1c 24             	mov    %ebx,(%esp)
  810caa:	e8 f8 ea ff ff       	call   80f7a7 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  810caf:	a1 80 d0 b3 00       	mov    0xb3d080,%eax
  810cb4:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  810cba:	a1 84 d0 b3 00       	mov    0xb3d084,%eax
  810cbf:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  810cc5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810cca:	83 c4 14             	add    $0x14,%esp
  810ccd:	5b                   	pop    %ebx
  810cce:	5d                   	pop    %ebp
  810ccf:	c3                   	ret    

00810cd0 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  810cd0:	55                   	push   %ebp
  810cd1:	89 e5                	mov    %esp,%ebp
  810cd3:	53                   	push   %ebx
  810cd4:	83 ec 14             	sub    $0x14,%esp
  810cd7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// bytes than requested.
	// LAB 5: Your code here
	//panic("devfile_write not implemented");
	int r;
	int count = 0;
	if(n > (PGSIZE - (sizeof(int) + sizeof(size_t))))
  810cda:	81 fb f8 0f 00 00    	cmp    $0xff8,%ebx
		count = PGSIZE - (sizeof(int) + sizeof(size_t));
	else
		count = n;
  810ce0:	b8 f8 0f 00 00       	mov    $0xff8,%eax
  810ce5:	0f 46 c3             	cmovbe %ebx,%eax
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  810ce8:	8b 55 08             	mov    0x8(%ebp),%edx
  810ceb:	8b 52 0c             	mov    0xc(%edx),%edx
  810cee:	89 15 00 d0 b3 00    	mov    %edx,0xb3d000
	fsipcbuf.write.req_n = count;
  810cf4:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	memmove(fsipcbuf.write.req_buf, buf, count);
  810cf9:	89 44 24 08          	mov    %eax,0x8(%esp)
  810cfd:	8b 45 0c             	mov    0xc(%ebp),%eax
  810d00:	89 44 24 04          	mov    %eax,0x4(%esp)
  810d04:	c7 04 24 08 d0 b3 00 	movl   $0xb3d008,(%esp)
  810d0b:	e8 34 ec ff ff       	call   80f944 <memmove>
	cprintf("\n%s\n",fsipcbuf.write.req_buf);
  810d10:	c7 44 24 04 08 d0 b3 	movl   $0xb3d008,0x4(%esp)
  810d17:	00 
  810d18:	c7 04 24 08 4a 81 00 	movl   $0x814a08,(%esp)
  810d1f:	e8 0f e4 ff ff       	call   80f133 <cprintf>
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  810d24:	ba 00 00 00 00       	mov    $0x0,%edx
  810d29:	b8 04 00 00 00       	mov    $0x4,%eax
  810d2e:	e8 90 fe ff ff       	call   810bc3 <fsipc>
  810d33:	85 c0                	test   %eax,%eax
  810d35:	78 53                	js     810d8a <devfile_write+0xba>
		return r;
	assert(r <= n);
  810d37:	39 c3                	cmp    %eax,%ebx
  810d39:	73 24                	jae    810d5f <devfile_write+0x8f>
  810d3b:	c7 44 24 0c 0d 4a 81 	movl   $0x814a0d,0xc(%esp)
  810d42:	00 
  810d43:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  810d4a:	00 
  810d4b:	c7 44 24 04 9d 00 00 	movl   $0x9d,0x4(%esp)
  810d52:	00 
  810d53:	c7 04 24 14 4a 81 00 	movl   $0x814a14,(%esp)
  810d5a:	e8 db e2 ff ff       	call   80f03a <_panic>
	assert(r <= PGSIZE);
  810d5f:	3d 00 10 00 00       	cmp    $0x1000,%eax
  810d64:	7e 24                	jle    810d8a <devfile_write+0xba>
  810d66:	c7 44 24 0c 1f 4a 81 	movl   $0x814a1f,0xc(%esp)
  810d6d:	00 
  810d6e:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  810d75:	00 
  810d76:	c7 44 24 04 9e 00 00 	movl   $0x9e,0x4(%esp)
  810d7d:	00 
  810d7e:	c7 04 24 14 4a 81 00 	movl   $0x814a14,(%esp)
  810d85:	e8 b0 e2 ff ff       	call   80f03a <_panic>
	return r;
}
  810d8a:	83 c4 14             	add    $0x14,%esp
  810d8d:	5b                   	pop    %ebx
  810d8e:	5d                   	pop    %ebp
  810d8f:	c3                   	ret    

00810d90 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  810d90:	55                   	push   %ebp
  810d91:	89 e5                	mov    %esp,%ebp
  810d93:	56                   	push   %esi
  810d94:	53                   	push   %ebx
  810d95:	83 ec 10             	sub    $0x10,%esp
  810d98:	8b 75 10             	mov    0x10(%ebp),%esi
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  810d9b:	8b 45 08             	mov    0x8(%ebp),%eax
  810d9e:	8b 40 0c             	mov    0xc(%eax),%eax
  810da1:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.read.req_n = n;
  810da6:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  810dac:	ba 00 00 00 00       	mov    $0x0,%edx
  810db1:	b8 03 00 00 00       	mov    $0x3,%eax
  810db6:	e8 08 fe ff ff       	call   810bc3 <fsipc>
  810dbb:	89 c3                	mov    %eax,%ebx
  810dbd:	85 c0                	test   %eax,%eax
  810dbf:	78 6a                	js     810e2b <devfile_read+0x9b>
		return r;
	assert(r <= n);
  810dc1:	39 c6                	cmp    %eax,%esi
  810dc3:	73 24                	jae    810de9 <devfile_read+0x59>
  810dc5:	c7 44 24 0c 0d 4a 81 	movl   $0x814a0d,0xc(%esp)
  810dcc:	00 
  810dcd:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  810dd4:	00 
  810dd5:	c7 44 24 04 7c 00 00 	movl   $0x7c,0x4(%esp)
  810ddc:	00 
  810ddd:	c7 04 24 14 4a 81 00 	movl   $0x814a14,(%esp)
  810de4:	e8 51 e2 ff ff       	call   80f03a <_panic>
	assert(r <= PGSIZE);
  810de9:	3d 00 10 00 00       	cmp    $0x1000,%eax
  810dee:	7e 24                	jle    810e14 <devfile_read+0x84>
  810df0:	c7 44 24 0c 1f 4a 81 	movl   $0x814a1f,0xc(%esp)
  810df7:	00 
  810df8:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  810dff:	00 
  810e00:	c7 44 24 04 7d 00 00 	movl   $0x7d,0x4(%esp)
  810e07:	00 
  810e08:	c7 04 24 14 4a 81 00 	movl   $0x814a14,(%esp)
  810e0f:	e8 26 e2 ff ff       	call   80f03a <_panic>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  810e14:	89 44 24 08          	mov    %eax,0x8(%esp)
  810e18:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  810e1f:	00 
  810e20:	8b 45 0c             	mov    0xc(%ebp),%eax
  810e23:	89 04 24             	mov    %eax,(%esp)
  810e26:	e8 19 eb ff ff       	call   80f944 <memmove>
	return r;
}
  810e2b:	89 d8                	mov    %ebx,%eax
  810e2d:	83 c4 10             	add    $0x10,%esp
  810e30:	5b                   	pop    %ebx
  810e31:	5e                   	pop    %esi
  810e32:	5d                   	pop    %ebp
  810e33:	c3                   	ret    

00810e34 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  810e34:	55                   	push   %ebp
  810e35:	89 e5                	mov    %esp,%ebp
  810e37:	53                   	push   %ebx
  810e38:	83 ec 24             	sub    $0x24,%esp
  810e3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// file descriptor.

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  810e3e:	89 1c 24             	mov    %ebx,(%esp)
  810e41:	e8 2a e9 ff ff       	call   80f770 <strlen>
  810e46:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  810e4b:	7f 60                	jg     810ead <open+0x79>
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  810e4d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810e50:	89 04 24             	mov    %eax,(%esp)
  810e53:	e8 af f7 ff ff       	call   810607 <fd_alloc>
  810e58:	89 c2                	mov    %eax,%edx
  810e5a:	85 d2                	test   %edx,%edx
  810e5c:	78 54                	js     810eb2 <open+0x7e>
		return r;

	strcpy(fsipcbuf.open.req_path, path);
  810e5e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810e62:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  810e69:	e8 39 e9 ff ff       	call   80f7a7 <strcpy>
	fsipcbuf.open.req_omode = mode;
  810e6e:	8b 45 0c             	mov    0xc(%ebp),%eax
  810e71:	a3 00 d4 b3 00       	mov    %eax,0xb3d400

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  810e76:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810e79:	b8 01 00 00 00       	mov    $0x1,%eax
  810e7e:	e8 40 fd ff ff       	call   810bc3 <fsipc>
  810e83:	89 c3                	mov    %eax,%ebx
  810e85:	85 c0                	test   %eax,%eax
  810e87:	79 17                	jns    810ea0 <open+0x6c>
		fd_close(fd, 0);
  810e89:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810e90:	00 
  810e91:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e94:	89 04 24             	mov    %eax,(%esp)
  810e97:	e8 6a f8 ff ff       	call   810706 <fd_close>
		return r;
  810e9c:	89 d8                	mov    %ebx,%eax
  810e9e:	eb 12                	jmp    810eb2 <open+0x7e>
	}

	return fd2num(fd);
  810ea0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810ea3:	89 04 24             	mov    %eax,(%esp)
  810ea6:	e8 35 f7 ff ff       	call   8105e0 <fd2num>
  810eab:	eb 05                	jmp    810eb2 <open+0x7e>

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;
  810ead:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		fd_close(fd, 0);
		return r;
	}

	return fd2num(fd);
}
  810eb2:	83 c4 24             	add    $0x24,%esp
  810eb5:	5b                   	pop    %ebx
  810eb6:	5d                   	pop    %ebp
  810eb7:	c3                   	ret    

00810eb8 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  810eb8:	55                   	push   %ebp
  810eb9:	89 e5                	mov    %esp,%ebp
  810ebb:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  810ebe:	ba 00 00 00 00       	mov    $0x0,%edx
  810ec3:	b8 08 00 00 00       	mov    $0x8,%eax
  810ec8:	e8 f6 fc ff ff       	call   810bc3 <fsipc>
}
  810ecd:	c9                   	leave  
  810ece:	c3                   	ret    

00810ecf <evict>:

int evict(void)
{
  810ecf:	55                   	push   %ebp
  810ed0:	89 e5                	mov    %esp,%ebp
  810ed2:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nevict called in file.c\n");
  810ed5:	c7 04 24 2b 4a 81 00 	movl   $0x814a2b,(%esp)
  810edc:	e8 52 e2 ff ff       	call   80f133 <cprintf>

	return fsipc(FSREQ_EVICT, NULL);
  810ee1:	ba 00 00 00 00       	mov    $0x0,%edx
  810ee6:	b8 09 00 00 00       	mov    $0x9,%eax
  810eeb:	e8 d3 fc ff ff       	call   810bc3 <fsipc>
}
  810ef0:	c9                   	leave  
  810ef1:	c3                   	ret    
  810ef2:	66 90                	xchg   %ax,%ax
  810ef4:	66 90                	xchg   %ax,%ax
  810ef6:	66 90                	xchg   %ax,%ax
  810ef8:	66 90                	xchg   %ax,%ax
  810efa:	66 90                	xchg   %ax,%ax
  810efc:	66 90                	xchg   %ax,%ax
  810efe:	66 90                	xchg   %ax,%ax

00810f00 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  810f00:	55                   	push   %ebp
  810f01:	89 e5                	mov    %esp,%ebp
  810f03:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  810f06:	c7 44 24 04 44 4a 81 	movl   $0x814a44,0x4(%esp)
  810f0d:	00 
  810f0e:	8b 45 0c             	mov    0xc(%ebp),%eax
  810f11:	89 04 24             	mov    %eax,(%esp)
  810f14:	e8 8e e8 ff ff       	call   80f7a7 <strcpy>
	return 0;
}
  810f19:	b8 00 00 00 00       	mov    $0x0,%eax
  810f1e:	c9                   	leave  
  810f1f:	c3                   	ret    

00810f20 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  810f20:	55                   	push   %ebp
  810f21:	89 e5                	mov    %esp,%ebp
  810f23:	53                   	push   %ebx
  810f24:	83 ec 14             	sub    $0x14,%esp
  810f27:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  810f2a:	89 1c 24             	mov    %ebx,(%esp)
  810f2d:	e8 5d 0d 00 00       	call   811c8f <pageref>
		return nsipc_close(fd->fd_sock.sockid);
	else
		return 0;
  810f32:	ba 00 00 00 00       	mov    $0x0,%edx
}

static int
devsock_close(struct Fd *fd)
{
	if (pageref(fd) == 1)
  810f37:	83 f8 01             	cmp    $0x1,%eax
  810f3a:	75 0d                	jne    810f49 <devsock_close+0x29>
		return nsipc_close(fd->fd_sock.sockid);
  810f3c:	8b 43 0c             	mov    0xc(%ebx),%eax
  810f3f:	89 04 24             	mov    %eax,(%esp)
  810f42:	e8 29 03 00 00       	call   811270 <nsipc_close>
  810f47:	89 c2                	mov    %eax,%edx
	else
		return 0;
}
  810f49:	89 d0                	mov    %edx,%eax
  810f4b:	83 c4 14             	add    $0x14,%esp
  810f4e:	5b                   	pop    %ebx
  810f4f:	5d                   	pop    %ebp
  810f50:	c3                   	ret    

00810f51 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  810f51:	55                   	push   %ebp
  810f52:	89 e5                	mov    %esp,%ebp
  810f54:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  810f57:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810f5e:	00 
  810f5f:	8b 45 10             	mov    0x10(%ebp),%eax
  810f62:	89 44 24 08          	mov    %eax,0x8(%esp)
  810f66:	8b 45 0c             	mov    0xc(%ebp),%eax
  810f69:	89 44 24 04          	mov    %eax,0x4(%esp)
  810f6d:	8b 45 08             	mov    0x8(%ebp),%eax
  810f70:	8b 40 0c             	mov    0xc(%eax),%eax
  810f73:	89 04 24             	mov    %eax,(%esp)
  810f76:	e8 f0 03 00 00       	call   81136b <nsipc_send>
}
  810f7b:	c9                   	leave  
  810f7c:	c3                   	ret    

00810f7d <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  810f7d:	55                   	push   %ebp
  810f7e:	89 e5                	mov    %esp,%ebp
  810f80:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  810f83:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810f8a:	00 
  810f8b:	8b 45 10             	mov    0x10(%ebp),%eax
  810f8e:	89 44 24 08          	mov    %eax,0x8(%esp)
  810f92:	8b 45 0c             	mov    0xc(%ebp),%eax
  810f95:	89 44 24 04          	mov    %eax,0x4(%esp)
  810f99:	8b 45 08             	mov    0x8(%ebp),%eax
  810f9c:	8b 40 0c             	mov    0xc(%eax),%eax
  810f9f:	89 04 24             	mov    %eax,(%esp)
  810fa2:	e8 44 03 00 00       	call   8112eb <nsipc_recv>
}
  810fa7:	c9                   	leave  
  810fa8:	c3                   	ret    

00810fa9 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  810fa9:	55                   	push   %ebp
  810faa:	89 e5                	mov    %esp,%ebp
  810fac:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  810faf:	8d 55 f4             	lea    -0xc(%ebp),%edx
  810fb2:	89 54 24 04          	mov    %edx,0x4(%esp)
  810fb6:	89 04 24             	mov    %eax,(%esp)
  810fb9:	e8 98 f6 ff ff       	call   810656 <fd_lookup>
  810fbe:	85 c0                	test   %eax,%eax
  810fc0:	78 17                	js     810fd9 <fd2sockid+0x30>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  810fc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810fc5:	8b 0d 08 53 81 00    	mov    0x815308,%ecx
  810fcb:	39 08                	cmp    %ecx,(%eax)
  810fcd:	75 05                	jne    810fd4 <fd2sockid+0x2b>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  810fcf:	8b 40 0c             	mov    0xc(%eax),%eax
  810fd2:	eb 05                	jmp    810fd9 <fd2sockid+0x30>
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
		return -E_NOT_SUPP;
  810fd4:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return sfd->fd_sock.sockid;
}
  810fd9:	c9                   	leave  
  810fda:	c3                   	ret    

00810fdb <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  810fdb:	55                   	push   %ebp
  810fdc:	89 e5                	mov    %esp,%ebp
  810fde:	56                   	push   %esi
  810fdf:	53                   	push   %ebx
  810fe0:	83 ec 20             	sub    $0x20,%esp
  810fe3:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  810fe5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810fe8:	89 04 24             	mov    %eax,(%esp)
  810feb:	e8 17 f6 ff ff       	call   810607 <fd_alloc>
  810ff0:	89 c3                	mov    %eax,%ebx
  810ff2:	85 c0                	test   %eax,%eax
  810ff4:	78 21                	js     811017 <alloc_sockfd+0x3c>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  810ff6:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  810ffd:	00 
  810ffe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811001:	89 44 24 04          	mov    %eax,0x4(%esp)
  811005:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81100c:	e8 04 ec ff ff       	call   80fc15 <sys_page_alloc>
  811011:	89 c3                	mov    %eax,%ebx
  811013:	85 c0                	test   %eax,%eax
  811015:	79 0c                	jns    811023 <alloc_sockfd+0x48>
		nsipc_close(sockid);
  811017:	89 34 24             	mov    %esi,(%esp)
  81101a:	e8 51 02 00 00       	call   811270 <nsipc_close>
		return r;
  81101f:	89 d8                	mov    %ebx,%eax
  811021:	eb 20                	jmp    811043 <alloc_sockfd+0x68>
	}

	sfd->fd_dev_id = devsock.dev_id;
  811023:	8b 15 08 53 81 00    	mov    0x815308,%edx
  811029:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81102c:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  81102e:	8b 55 f4             	mov    -0xc(%ebp),%edx
  811031:	c7 42 08 02 00 00 00 	movl   $0x2,0x8(%edx)
	sfd->fd_sock.sockid = sockid;
  811038:	89 72 0c             	mov    %esi,0xc(%edx)
	return fd2num(sfd);
  81103b:	89 14 24             	mov    %edx,(%esp)
  81103e:	e8 9d f5 ff ff       	call   8105e0 <fd2num>
}
  811043:	83 c4 20             	add    $0x20,%esp
  811046:	5b                   	pop    %ebx
  811047:	5e                   	pop    %esi
  811048:	5d                   	pop    %ebp
  811049:	c3                   	ret    

0081104a <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  81104a:	55                   	push   %ebp
  81104b:	89 e5                	mov    %esp,%ebp
  81104d:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  811050:	8b 45 08             	mov    0x8(%ebp),%eax
  811053:	e8 51 ff ff ff       	call   810fa9 <fd2sockid>
		return r;
  811058:	89 c1                	mov    %eax,%ecx

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
  81105a:	85 c0                	test   %eax,%eax
  81105c:	78 23                	js     811081 <accept+0x37>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  81105e:	8b 55 10             	mov    0x10(%ebp),%edx
  811061:	89 54 24 08          	mov    %edx,0x8(%esp)
  811065:	8b 55 0c             	mov    0xc(%ebp),%edx
  811068:	89 54 24 04          	mov    %edx,0x4(%esp)
  81106c:	89 04 24             	mov    %eax,(%esp)
  81106f:	e8 45 01 00 00       	call   8111b9 <nsipc_accept>
		return r;
  811074:	89 c1                	mov    %eax,%ecx
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  811076:	85 c0                	test   %eax,%eax
  811078:	78 07                	js     811081 <accept+0x37>
		return r;
	return alloc_sockfd(r);
  81107a:	e8 5c ff ff ff       	call   810fdb <alloc_sockfd>
  81107f:	89 c1                	mov    %eax,%ecx
}
  811081:	89 c8                	mov    %ecx,%eax
  811083:	c9                   	leave  
  811084:	c3                   	ret    

00811085 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  811085:	55                   	push   %ebp
  811086:	89 e5                	mov    %esp,%ebp
  811088:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  81108b:	8b 45 08             	mov    0x8(%ebp),%eax
  81108e:	e8 16 ff ff ff       	call   810fa9 <fd2sockid>
  811093:	89 c2                	mov    %eax,%edx
  811095:	85 d2                	test   %edx,%edx
  811097:	78 16                	js     8110af <bind+0x2a>
		return r;
	return nsipc_bind(r, name, namelen);
  811099:	8b 45 10             	mov    0x10(%ebp),%eax
  81109c:	89 44 24 08          	mov    %eax,0x8(%esp)
  8110a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8110a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8110a7:	89 14 24             	mov    %edx,(%esp)
  8110aa:	e8 60 01 00 00       	call   81120f <nsipc_bind>
}
  8110af:	c9                   	leave  
  8110b0:	c3                   	ret    

008110b1 <shutdown>:

int
shutdown(int s, int how)
{
  8110b1:	55                   	push   %ebp
  8110b2:	89 e5                	mov    %esp,%ebp
  8110b4:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8110b7:	8b 45 08             	mov    0x8(%ebp),%eax
  8110ba:	e8 ea fe ff ff       	call   810fa9 <fd2sockid>
  8110bf:	89 c2                	mov    %eax,%edx
  8110c1:	85 d2                	test   %edx,%edx
  8110c3:	78 0f                	js     8110d4 <shutdown+0x23>
		return r;
	return nsipc_shutdown(r, how);
  8110c5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8110c8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8110cc:	89 14 24             	mov    %edx,(%esp)
  8110cf:	e8 7a 01 00 00       	call   81124e <nsipc_shutdown>
}
  8110d4:	c9                   	leave  
  8110d5:	c3                   	ret    

008110d6 <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8110d6:	55                   	push   %ebp
  8110d7:	89 e5                	mov    %esp,%ebp
  8110d9:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8110dc:	8b 45 08             	mov    0x8(%ebp),%eax
  8110df:	e8 c5 fe ff ff       	call   810fa9 <fd2sockid>
  8110e4:	89 c2                	mov    %eax,%edx
  8110e6:	85 d2                	test   %edx,%edx
  8110e8:	78 16                	js     811100 <connect+0x2a>
		return r;
	return nsipc_connect(r, name, namelen);
  8110ea:	8b 45 10             	mov    0x10(%ebp),%eax
  8110ed:	89 44 24 08          	mov    %eax,0x8(%esp)
  8110f1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8110f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8110f8:	89 14 24             	mov    %edx,(%esp)
  8110fb:	e8 8a 01 00 00       	call   81128a <nsipc_connect>
}
  811100:	c9                   	leave  
  811101:	c3                   	ret    

00811102 <listen>:

int
listen(int s, int backlog)
{
  811102:	55                   	push   %ebp
  811103:	89 e5                	mov    %esp,%ebp
  811105:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  811108:	8b 45 08             	mov    0x8(%ebp),%eax
  81110b:	e8 99 fe ff ff       	call   810fa9 <fd2sockid>
  811110:	89 c2                	mov    %eax,%edx
  811112:	85 d2                	test   %edx,%edx
  811114:	78 0f                	js     811125 <listen+0x23>
		return r;
	return nsipc_listen(r, backlog);
  811116:	8b 45 0c             	mov    0xc(%ebp),%eax
  811119:	89 44 24 04          	mov    %eax,0x4(%esp)
  81111d:	89 14 24             	mov    %edx,(%esp)
  811120:	e8 a4 01 00 00       	call   8112c9 <nsipc_listen>
}
  811125:	c9                   	leave  
  811126:	c3                   	ret    

00811127 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  811127:	55                   	push   %ebp
  811128:	89 e5                	mov    %esp,%ebp
  81112a:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  81112d:	8b 45 10             	mov    0x10(%ebp),%eax
  811130:	89 44 24 08          	mov    %eax,0x8(%esp)
  811134:	8b 45 0c             	mov    0xc(%ebp),%eax
  811137:	89 44 24 04          	mov    %eax,0x4(%esp)
  81113b:	8b 45 08             	mov    0x8(%ebp),%eax
  81113e:	89 04 24             	mov    %eax,(%esp)
  811141:	e8 98 02 00 00       	call   8113de <nsipc_socket>
  811146:	89 c2                	mov    %eax,%edx
  811148:	85 d2                	test   %edx,%edx
  81114a:	78 05                	js     811151 <socket+0x2a>
		return r;
	return alloc_sockfd(r);
  81114c:	e8 8a fe ff ff       	call   810fdb <alloc_sockfd>
}
  811151:	c9                   	leave  
  811152:	c3                   	ret    

00811153 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  811153:	55                   	push   %ebp
  811154:	89 e5                	mov    %esp,%ebp
  811156:	53                   	push   %ebx
  811157:	83 ec 14             	sub    $0x14,%esp
  81115a:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  81115c:	83 3d f0 c1 b3 00 00 	cmpl   $0x0,0xb3c1f0
  811163:	75 11                	jne    811176 <nsipc+0x23>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  811165:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  81116c:	e8 2e f4 ff ff       	call   81059f <ipc_find_env>
  811171:	a3 f0 c1 b3 00       	mov    %eax,0xb3c1f0
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  811176:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  81117d:	00 
  81117e:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  811185:	00 
  811186:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81118a:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  81118f:	89 04 24             	mov    %eax,(%esp)
  811192:	e8 a1 f3 ff ff       	call   810538 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  811197:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81119e:	00 
  81119f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8111a6:	00 
  8111a7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8111ae:	e8 1d f3 ff ff       	call   8104d0 <ipc_recv>
}
  8111b3:	83 c4 14             	add    $0x14,%esp
  8111b6:	5b                   	pop    %ebx
  8111b7:	5d                   	pop    %ebp
  8111b8:	c3                   	ret    

008111b9 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8111b9:	55                   	push   %ebp
  8111ba:	89 e5                	mov    %esp,%ebp
  8111bc:	56                   	push   %esi
  8111bd:	53                   	push   %ebx
  8111be:	83 ec 10             	sub    $0x10,%esp
  8111c1:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  8111c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8111c7:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.accept.req_addrlen = *addrlen;
  8111cc:	8b 06                	mov    (%esi),%eax
  8111ce:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8111d3:	b8 01 00 00 00       	mov    $0x1,%eax
  8111d8:	e8 76 ff ff ff       	call   811153 <nsipc>
  8111dd:	89 c3                	mov    %eax,%ebx
  8111df:	85 c0                	test   %eax,%eax
  8111e1:	78 23                	js     811206 <nsipc_accept+0x4d>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8111e3:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  8111e8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8111ec:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  8111f3:	00 
  8111f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8111f7:	89 04 24             	mov    %eax,(%esp)
  8111fa:	e8 45 e7 ff ff       	call   80f944 <memmove>
		*addrlen = ret->ret_addrlen;
  8111ff:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  811204:	89 06                	mov    %eax,(%esi)
	}
	return r;
}
  811206:	89 d8                	mov    %ebx,%eax
  811208:	83 c4 10             	add    $0x10,%esp
  81120b:	5b                   	pop    %ebx
  81120c:	5e                   	pop    %esi
  81120d:	5d                   	pop    %ebp
  81120e:	c3                   	ret    

0081120f <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  81120f:	55                   	push   %ebp
  811210:	89 e5                	mov    %esp,%ebp
  811212:	53                   	push   %ebx
  811213:	83 ec 14             	sub    $0x14,%esp
  811216:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  811219:	8b 45 08             	mov    0x8(%ebp),%eax
  81121c:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  811221:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  811225:	8b 45 0c             	mov    0xc(%ebp),%eax
  811228:	89 44 24 04          	mov    %eax,0x4(%esp)
  81122c:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  811233:	e8 0c e7 ff ff       	call   80f944 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  811238:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  81123e:	b8 02 00 00 00       	mov    $0x2,%eax
  811243:	e8 0b ff ff ff       	call   811153 <nsipc>
}
  811248:	83 c4 14             	add    $0x14,%esp
  81124b:	5b                   	pop    %ebx
  81124c:	5d                   	pop    %ebp
  81124d:	c3                   	ret    

0081124e <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  81124e:	55                   	push   %ebp
  81124f:	89 e5                	mov    %esp,%ebp
  811251:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  811254:	8b 45 08             	mov    0x8(%ebp),%eax
  811257:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  81125c:	8b 45 0c             	mov    0xc(%ebp),%eax
  81125f:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  811264:	b8 03 00 00 00       	mov    $0x3,%eax
  811269:	e8 e5 fe ff ff       	call   811153 <nsipc>
}
  81126e:	c9                   	leave  
  81126f:	c3                   	ret    

00811270 <nsipc_close>:

int
nsipc_close(int s)
{
  811270:	55                   	push   %ebp
  811271:	89 e5                	mov    %esp,%ebp
  811273:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  811276:	8b 45 08             	mov    0x8(%ebp),%eax
  811279:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  81127e:	b8 04 00 00 00       	mov    $0x4,%eax
  811283:	e8 cb fe ff ff       	call   811153 <nsipc>
}
  811288:	c9                   	leave  
  811289:	c3                   	ret    

0081128a <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  81128a:	55                   	push   %ebp
  81128b:	89 e5                	mov    %esp,%ebp
  81128d:	53                   	push   %ebx
  81128e:	83 ec 14             	sub    $0x14,%esp
  811291:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  811294:	8b 45 08             	mov    0x8(%ebp),%eax
  811297:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  81129c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8112a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8112a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8112a7:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  8112ae:	e8 91 e6 ff ff       	call   80f944 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  8112b3:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  8112b9:	b8 05 00 00 00       	mov    $0x5,%eax
  8112be:	e8 90 fe ff ff       	call   811153 <nsipc>
}
  8112c3:	83 c4 14             	add    $0x14,%esp
  8112c6:	5b                   	pop    %ebx
  8112c7:	5d                   	pop    %ebp
  8112c8:	c3                   	ret    

008112c9 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  8112c9:	55                   	push   %ebp
  8112ca:	89 e5                	mov    %esp,%ebp
  8112cc:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  8112cf:	8b 45 08             	mov    0x8(%ebp),%eax
  8112d2:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  8112d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8112da:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  8112df:	b8 06 00 00 00       	mov    $0x6,%eax
  8112e4:	e8 6a fe ff ff       	call   811153 <nsipc>
}
  8112e9:	c9                   	leave  
  8112ea:	c3                   	ret    

008112eb <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8112eb:	55                   	push   %ebp
  8112ec:	89 e5                	mov    %esp,%ebp
  8112ee:	56                   	push   %esi
  8112ef:	53                   	push   %ebx
  8112f0:	83 ec 10             	sub    $0x10,%esp
  8112f3:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  8112f6:	8b 45 08             	mov    0x8(%ebp),%eax
  8112f9:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  8112fe:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  811304:	8b 45 14             	mov    0x14(%ebp),%eax
  811307:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  81130c:	b8 07 00 00 00       	mov    $0x7,%eax
  811311:	e8 3d fe ff ff       	call   811153 <nsipc>
  811316:	89 c3                	mov    %eax,%ebx
  811318:	85 c0                	test   %eax,%eax
  81131a:	78 46                	js     811362 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  81131c:	39 f0                	cmp    %esi,%eax
  81131e:	7f 07                	jg     811327 <nsipc_recv+0x3c>
  811320:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  811325:	7e 24                	jle    81134b <nsipc_recv+0x60>
  811327:	c7 44 24 0c 50 4a 81 	movl   $0x814a50,0xc(%esp)
  81132e:	00 
  81132f:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  811336:	00 
  811337:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  81133e:	00 
  81133f:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  811346:	e8 ef dc ff ff       	call   80f03a <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  81134b:	89 44 24 08          	mov    %eax,0x8(%esp)
  81134f:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  811356:	00 
  811357:	8b 45 0c             	mov    0xc(%ebp),%eax
  81135a:	89 04 24             	mov    %eax,(%esp)
  81135d:	e8 e2 e5 ff ff       	call   80f944 <memmove>
	}

	return r;
}
  811362:	89 d8                	mov    %ebx,%eax
  811364:	83 c4 10             	add    $0x10,%esp
  811367:	5b                   	pop    %ebx
  811368:	5e                   	pop    %esi
  811369:	5d                   	pop    %ebp
  81136a:	c3                   	ret    

0081136b <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  81136b:	55                   	push   %ebp
  81136c:	89 e5                	mov    %esp,%ebp
  81136e:	53                   	push   %ebx
  81136f:	83 ec 14             	sub    $0x14,%esp
  811372:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  811375:	8b 45 08             	mov    0x8(%ebp),%eax
  811378:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  81137d:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  811383:	7e 24                	jle    8113a9 <nsipc_send+0x3e>
  811385:	c7 44 24 0c 71 4a 81 	movl   $0x814a71,0xc(%esp)
  81138c:	00 
  81138d:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  811394:	00 
  811395:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
  81139c:	00 
  81139d:	c7 04 24 65 4a 81 00 	movl   $0x814a65,(%esp)
  8113a4:	e8 91 dc ff ff       	call   80f03a <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  8113a9:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8113ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  8113b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8113b4:	c7 04 24 0c e0 b3 00 	movl   $0xb3e00c,(%esp)
  8113bb:	e8 84 e5 ff ff       	call   80f944 <memmove>
	nsipcbuf.send.req_size = size;
  8113c0:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  8113c6:	8b 45 14             	mov    0x14(%ebp),%eax
  8113c9:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  8113ce:	b8 08 00 00 00       	mov    $0x8,%eax
  8113d3:	e8 7b fd ff ff       	call   811153 <nsipc>
}
  8113d8:	83 c4 14             	add    $0x14,%esp
  8113db:	5b                   	pop    %ebx
  8113dc:	5d                   	pop    %ebp
  8113dd:	c3                   	ret    

008113de <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  8113de:	55                   	push   %ebp
  8113df:	89 e5                	mov    %esp,%ebp
  8113e1:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  8113e4:	8b 45 08             	mov    0x8(%ebp),%eax
  8113e7:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  8113ec:	8b 45 0c             	mov    0xc(%ebp),%eax
  8113ef:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  8113f4:	8b 45 10             	mov    0x10(%ebp),%eax
  8113f7:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  8113fc:	b8 09 00 00 00       	mov    $0x9,%eax
  811401:	e8 4d fd ff ff       	call   811153 <nsipc>
}
  811406:	c9                   	leave  
  811407:	c3                   	ret    
  811408:	66 90                	xchg   %ax,%ax
  81140a:	66 90                	xchg   %ax,%ax
  81140c:	66 90                	xchg   %ax,%ax
  81140e:	66 90                	xchg   %ax,%ax

00811410 <free>:
	return v;
}

void
free(void *v)
{
  811410:	55                   	push   %ebp
  811411:	89 e5                	mov    %esp,%ebp
  811413:	53                   	push   %ebx
  811414:	83 ec 14             	sub    $0x14,%esp
  811417:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  81141a:	85 db                	test   %ebx,%ebx
  81141c:	0f 84 ba 00 00 00    	je     8114dc <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  811422:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  811428:	76 08                	jbe    811432 <free+0x22>
  81142a:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  811430:	76 24                	jbe    811456 <free+0x46>
  811432:	c7 44 24 0c 80 4a 81 	movl   $0x814a80,0xc(%esp)
  811439:	00 
  81143a:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  811441:	00 
  811442:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  811449:	00 
  81144a:	c7 04 24 b0 4a 81 00 	movl   $0x814ab0,(%esp)
  811451:	e8 e4 db ff ff       	call   80f03a <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  811456:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  81145c:	eb 4a                	jmp    8114a8 <free+0x98>
		sys_page_unmap(0, c);
  81145e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811462:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811469:	e8 4e e8 ff ff       	call   80fcbc <sys_page_unmap>
		c += PGSIZE;
  81146e:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  811474:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  81147a:	76 08                	jbe    811484 <free+0x74>
  81147c:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  811482:	76 24                	jbe    8114a8 <free+0x98>
  811484:	c7 44 24 0c bd 4a 81 	movl   $0x814abd,0xc(%esp)
  81148b:	00 
  81148c:	c7 44 24 08 1f 37 81 	movl   $0x81371f,0x8(%esp)
  811493:	00 
  811494:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  81149b:	00 
  81149c:	c7 04 24 b0 4a 81 00 	movl   $0x814ab0,(%esp)
  8114a3:	e8 92 db ff ff       	call   80f03a <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8114a8:	89 d8                	mov    %ebx,%eax
  8114aa:	c1 e8 0c             	shr    $0xc,%eax
  8114ad:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8114b4:	f6 c4 02             	test   $0x2,%ah
  8114b7:	75 a5                	jne    81145e <free+0x4e>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  8114b9:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  8114bf:	83 e8 01             	sub    $0x1,%eax
  8114c2:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  8114c8:	85 c0                	test   %eax,%eax
  8114ca:	75 10                	jne    8114dc <free+0xcc>
		sys_page_unmap(0, c);
  8114cc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8114d0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8114d7:	e8 e0 e7 ff ff       	call   80fcbc <sys_page_unmap>
}
  8114dc:	83 c4 14             	add    $0x14,%esp
  8114df:	5b                   	pop    %ebx
  8114e0:	5d                   	pop    %ebp
  8114e1:	c3                   	ret    

008114e2 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  8114e2:	55                   	push   %ebp
  8114e3:	89 e5                	mov    %esp,%ebp
  8114e5:	57                   	push   %edi
  8114e6:	56                   	push   %esi
  8114e7:	53                   	push   %ebx
  8114e8:	83 ec 2c             	sub    $0x2c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  8114eb:	83 3d f4 c1 b3 00 00 	cmpl   $0x0,0xb3c1f4
  8114f2:	75 0a                	jne    8114fe <malloc+0x1c>
		mptr = mbegin;
  8114f4:	c7 05 f4 c1 b3 00 00 	movl   $0x8000000,0xb3c1f4
  8114fb:	00 00 08 

	n = ROUNDUP(n, 4);
  8114fe:	8b 45 08             	mov    0x8(%ebp),%eax
  811501:	83 c0 03             	add    $0x3,%eax
  811504:	83 e0 fc             	and    $0xfffffffc,%eax
  811507:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (n >= MAXMALLOC)
  81150a:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  81150f:	0f 87 64 01 00 00    	ja     811679 <malloc+0x197>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  811515:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  81151a:	a9 ff 0f 00 00       	test   $0xfff,%eax
  81151f:	75 15                	jne    811536 <malloc+0x54>
  811521:	8b 35 f4 c1 b3 00    	mov    0xb3c1f4,%esi
	return 1;
}

void*
malloc(size_t n)
{
  811527:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  81152e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  811531:	8d 78 04             	lea    0x4(%eax),%edi
  811534:	eb 50                	jmp    811586 <malloc+0xa4>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  811536:	89 c1                	mov    %eax,%ecx
  811538:	c1 e9 0c             	shr    $0xc,%ecx
  81153b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  81153e:	8d 54 18 03          	lea    0x3(%eax,%ebx,1),%edx
  811542:	c1 ea 0c             	shr    $0xc,%edx
  811545:	39 d1                	cmp    %edx,%ecx
  811547:	75 1f                	jne    811568 <malloc+0x86>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  811549:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  81154f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  811555:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  811559:	89 da                	mov    %ebx,%edx
  81155b:	01 c2                	add    %eax,%edx
  81155d:	89 15 f4 c1 b3 00    	mov    %edx,0xb3c1f4
			return v;
  811563:	e9 2f 01 00 00       	jmp    811697 <malloc+0x1b5>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  811568:	89 04 24             	mov    %eax,(%esp)
  81156b:	e8 a0 fe ff ff       	call   811410 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  811570:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  811575:	05 00 10 00 00       	add    $0x1000,%eax
  81157a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  81157f:	a3 f4 c1 b3 00       	mov    %eax,0xb3c1f4
  811584:	eb 9b                	jmp    811521 <malloc+0x3f>
  811586:	89 75 e4             	mov    %esi,-0x1c(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  811589:	89 fb                	mov    %edi,%ebx
  81158b:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81158e:	89 f0                	mov    %esi,%eax
  811590:	eb 36                	jmp    8115c8 <malloc+0xe6>
		if (va >= (uintptr_t) mend
  811592:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  811597:	0f 87 e3 00 00 00    	ja     811680 <malloc+0x19e>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  81159d:	89 c2                	mov    %eax,%edx
  81159f:	c1 ea 16             	shr    $0x16,%edx
  8115a2:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  8115a9:	f6 c2 01             	test   $0x1,%dl
  8115ac:	74 15                	je     8115c3 <malloc+0xe1>
  8115ae:	89 c2                	mov    %eax,%edx
  8115b0:	c1 ea 0c             	shr    $0xc,%edx
  8115b3:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  8115ba:	f6 c2 01             	test   $0x1,%dl
  8115bd:	0f 85 bd 00 00 00    	jne    811680 <malloc+0x19e>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8115c3:	05 00 10 00 00       	add    $0x1000,%eax
  8115c8:	39 c1                	cmp    %eax,%ecx
  8115ca:	77 c6                	ja     811592 <malloc+0xb0>
  8115cc:	eb 7e                	jmp    81164c <malloc+0x16a>
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
			if (++nwrap == 2)
  8115ce:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
  8115d2:	74 07                	je     8115db <malloc+0xf9>
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  8115d4:	be 00 00 00 08       	mov    $0x8000000,%esi
  8115d9:	eb ab                	jmp    811586 <malloc+0xa4>
  8115db:	c7 05 f4 c1 b3 00 00 	movl   $0x8000000,0xb3c1f4
  8115e2:	00 00 08 
			if (++nwrap == 2)
				return 0;	/* out of address space */
  8115e5:	b8 00 00 00 00       	mov    $0x0,%eax
  8115ea:	e9 a8 00 00 00       	jmp    811697 <malloc+0x1b5>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8115ef:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
  8115f5:	39 df                	cmp    %ebx,%edi
  8115f7:	19 c0                	sbb    %eax,%eax
  8115f9:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8115fe:	83 c8 07             	or     $0x7,%eax
  811601:	89 44 24 08          	mov    %eax,0x8(%esp)
  811605:	03 15 f4 c1 b3 00    	add    0xb3c1f4,%edx
  81160b:	89 54 24 04          	mov    %edx,0x4(%esp)
  81160f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811616:	e8 fa e5 ff ff       	call   80fc15 <sys_page_alloc>
  81161b:	85 c0                	test   %eax,%eax
  81161d:	78 22                	js     811641 <malloc+0x15f>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  81161f:	89 fe                	mov    %edi,%esi
  811621:	eb 36                	jmp    811659 <malloc+0x177>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  811623:	89 f0                	mov    %esi,%eax
  811625:	03 05 f4 c1 b3 00    	add    0xb3c1f4,%eax
  81162b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81162f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811636:	e8 81 e6 ff ff       	call   80fcbc <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  81163b:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  811641:	85 f6                	test   %esi,%esi
  811643:	79 de                	jns    811623 <malloc+0x141>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  811645:	b8 00 00 00 00       	mov    $0x0,%eax
  81164a:	eb 4b                	jmp    811697 <malloc+0x1b5>
  81164c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81164f:	a3 f4 c1 b3 00       	mov    %eax,0xb3c1f4
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  811654:	be 00 00 00 00       	mov    $0x0,%esi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  811659:	89 f2                	mov    %esi,%edx
  81165b:	39 de                	cmp    %ebx,%esi
  81165d:	72 90                	jb     8115ef <malloc+0x10d>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  81165f:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  811664:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  81166b:	00 
	v = mptr;
	mptr += n;
  81166c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  81166f:	01 c2                	add    %eax,%edx
  811671:	89 15 f4 c1 b3 00    	mov    %edx,0xb3c1f4
	return v;
  811677:	eb 1e                	jmp    811697 <malloc+0x1b5>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  811679:	b8 00 00 00 00       	mov    $0x0,%eax
  81167e:	eb 17                	jmp    811697 <malloc+0x1b5>
  811680:	81 c6 00 10 00 00    	add    $0x1000,%esi
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  811686:	81 fe 00 00 00 10    	cmp    $0x10000000,%esi
  81168c:	0f 84 3c ff ff ff    	je     8115ce <malloc+0xec>
  811692:	e9 ef fe ff ff       	jmp    811586 <malloc+0xa4>
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  811697:	83 c4 2c             	add    $0x2c,%esp
  81169a:	5b                   	pop    %ebx
  81169b:	5e                   	pop    %esi
  81169c:	5f                   	pop    %edi
  81169d:	5d                   	pop    %ebp
  81169e:	c3                   	ret    

0081169f <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  81169f:	55                   	push   %ebp
  8116a0:	89 e5                	mov    %esp,%ebp
  8116a2:	56                   	push   %esi
  8116a3:	53                   	push   %ebx
  8116a4:	83 ec 10             	sub    $0x10,%esp
  8116a7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8116aa:	8b 45 08             	mov    0x8(%ebp),%eax
  8116ad:	89 04 24             	mov    %eax,(%esp)
  8116b0:	e8 3b ef ff ff       	call   8105f0 <fd2data>
  8116b5:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  8116b7:	c7 44 24 04 d5 4a 81 	movl   $0x814ad5,0x4(%esp)
  8116be:	00 
  8116bf:	89 1c 24             	mov    %ebx,(%esp)
  8116c2:	e8 e0 e0 ff ff       	call   80f7a7 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  8116c7:	8b 46 04             	mov    0x4(%esi),%eax
  8116ca:	2b 06                	sub    (%esi),%eax
  8116cc:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  8116d2:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8116d9:	00 00 00 
	stat->st_dev = &devpipe;
  8116dc:	c7 83 88 00 00 00 24 	movl   $0x815324,0x88(%ebx)
  8116e3:	53 81 00 
	return 0;
}
  8116e6:	b8 00 00 00 00       	mov    $0x0,%eax
  8116eb:	83 c4 10             	add    $0x10,%esp
  8116ee:	5b                   	pop    %ebx
  8116ef:	5e                   	pop    %esi
  8116f0:	5d                   	pop    %ebp
  8116f1:	c3                   	ret    

008116f2 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  8116f2:	55                   	push   %ebp
  8116f3:	89 e5                	mov    %esp,%ebp
  8116f5:	53                   	push   %ebx
  8116f6:	83 ec 14             	sub    $0x14,%esp
  8116f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  8116fc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811700:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811707:	e8 b0 e5 ff ff       	call   80fcbc <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  81170c:	89 1c 24             	mov    %ebx,(%esp)
  81170f:	e8 dc ee ff ff       	call   8105f0 <fd2data>
  811714:	89 44 24 04          	mov    %eax,0x4(%esp)
  811718:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81171f:	e8 98 e5 ff ff       	call   80fcbc <sys_page_unmap>
}
  811724:	83 c4 14             	add    $0x14,%esp
  811727:	5b                   	pop    %ebx
  811728:	5d                   	pop    %ebp
  811729:	c3                   	ret    

0081172a <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  81172a:	55                   	push   %ebp
  81172b:	89 e5                	mov    %esp,%ebp
  81172d:	57                   	push   %edi
  81172e:	56                   	push   %esi
  81172f:	53                   	push   %ebx
  811730:	83 ec 2c             	sub    $0x2c,%esp
  811733:	89 c6                	mov    %eax,%esi
  811735:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  811738:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  81173d:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  811740:	89 34 24             	mov    %esi,(%esp)
  811743:	e8 47 05 00 00       	call   811c8f <pageref>
  811748:	89 c7                	mov    %eax,%edi
  81174a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81174d:	89 04 24             	mov    %eax,(%esp)
  811750:	e8 3a 05 00 00       	call   811c8f <pageref>
  811755:	39 c7                	cmp    %eax,%edi
  811757:	0f 94 c2             	sete   %dl
  81175a:	0f b6 c2             	movzbl %dl,%eax
		nn = thisenv->env_runs;
  81175d:	8b 0d 7c c2 b3 00    	mov    0xb3c27c,%ecx
  811763:	8b 79 58             	mov    0x58(%ecx),%edi
		if (n == nn)
  811766:	39 fb                	cmp    %edi,%ebx
  811768:	74 21                	je     81178b <_pipeisclosed+0x61>
			return ret;
		if (n != nn && ret == 1)
  81176a:	84 d2                	test   %dl,%dl
  81176c:	74 ca                	je     811738 <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  81176e:	8b 51 58             	mov    0x58(%ecx),%edx
  811771:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811775:	89 54 24 08          	mov    %edx,0x8(%esp)
  811779:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81177d:	c7 04 24 dc 4a 81 00 	movl   $0x814adc,(%esp)
  811784:	e8 aa d9 ff ff       	call   80f133 <cprintf>
  811789:	eb ad                	jmp    811738 <_pipeisclosed+0xe>
	}
}
  81178b:	83 c4 2c             	add    $0x2c,%esp
  81178e:	5b                   	pop    %ebx
  81178f:	5e                   	pop    %esi
  811790:	5f                   	pop    %edi
  811791:	5d                   	pop    %ebp
  811792:	c3                   	ret    

00811793 <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  811793:	55                   	push   %ebp
  811794:	89 e5                	mov    %esp,%ebp
  811796:	57                   	push   %edi
  811797:	56                   	push   %esi
  811798:	53                   	push   %ebx
  811799:	83 ec 1c             	sub    $0x1c,%esp
  81179c:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  81179f:	89 34 24             	mov    %esi,(%esp)
  8117a2:	e8 49 ee ff ff       	call   8105f0 <fd2data>
  8117a7:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8117a9:	bf 00 00 00 00       	mov    $0x0,%edi
  8117ae:	eb 45                	jmp    8117f5 <devpipe_write+0x62>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  8117b0:	89 da                	mov    %ebx,%edx
  8117b2:	89 f0                	mov    %esi,%eax
  8117b4:	e8 71 ff ff ff       	call   81172a <_pipeisclosed>
  8117b9:	85 c0                	test   %eax,%eax
  8117bb:	75 41                	jne    8117fe <devpipe_write+0x6b>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  8117bd:	e8 34 e4 ff ff       	call   80fbf6 <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  8117c2:	8b 43 04             	mov    0x4(%ebx),%eax
  8117c5:	8b 0b                	mov    (%ebx),%ecx
  8117c7:	8d 51 20             	lea    0x20(%ecx),%edx
  8117ca:	39 d0                	cmp    %edx,%eax
  8117cc:	73 e2                	jae    8117b0 <devpipe_write+0x1d>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  8117ce:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8117d1:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  8117d5:	88 4d e7             	mov    %cl,-0x19(%ebp)
  8117d8:	99                   	cltd   
  8117d9:	c1 ea 1b             	shr    $0x1b,%edx
  8117dc:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  8117df:	83 e1 1f             	and    $0x1f,%ecx
  8117e2:	29 d1                	sub    %edx,%ecx
  8117e4:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
  8117e8:	88 54 0b 08          	mov    %dl,0x8(%ebx,%ecx,1)
		p->p_wpos++;
  8117ec:	83 c0 01             	add    $0x1,%eax
  8117ef:	89 43 04             	mov    %eax,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8117f2:	83 c7 01             	add    $0x1,%edi
  8117f5:	3b 7d 10             	cmp    0x10(%ebp),%edi
  8117f8:	75 c8                	jne    8117c2 <devpipe_write+0x2f>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  8117fa:	89 f8                	mov    %edi,%eax
  8117fc:	eb 05                	jmp    811803 <devpipe_write+0x70>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
  8117fe:	b8 00 00 00 00       	mov    $0x0,%eax
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
}
  811803:	83 c4 1c             	add    $0x1c,%esp
  811806:	5b                   	pop    %ebx
  811807:	5e                   	pop    %esi
  811808:	5f                   	pop    %edi
  811809:	5d                   	pop    %ebp
  81180a:	c3                   	ret    

0081180b <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  81180b:	55                   	push   %ebp
  81180c:	89 e5                	mov    %esp,%ebp
  81180e:	57                   	push   %edi
  81180f:	56                   	push   %esi
  811810:	53                   	push   %ebx
  811811:	83 ec 1c             	sub    $0x1c,%esp
  811814:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  811817:	89 3c 24             	mov    %edi,(%esp)
  81181a:	e8 d1 ed ff ff       	call   8105f0 <fd2data>
  81181f:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  811821:	be 00 00 00 00       	mov    $0x0,%esi
  811826:	eb 3d                	jmp    811865 <devpipe_read+0x5a>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  811828:	85 f6                	test   %esi,%esi
  81182a:	74 04                	je     811830 <devpipe_read+0x25>
				return i;
  81182c:	89 f0                	mov    %esi,%eax
  81182e:	eb 43                	jmp    811873 <devpipe_read+0x68>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  811830:	89 da                	mov    %ebx,%edx
  811832:	89 f8                	mov    %edi,%eax
  811834:	e8 f1 fe ff ff       	call   81172a <_pipeisclosed>
  811839:	85 c0                	test   %eax,%eax
  81183b:	75 31                	jne    81186e <devpipe_read+0x63>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  81183d:	e8 b4 e3 ff ff       	call   80fbf6 <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  811842:	8b 03                	mov    (%ebx),%eax
  811844:	3b 43 04             	cmp    0x4(%ebx),%eax
  811847:	74 df                	je     811828 <devpipe_read+0x1d>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  811849:	99                   	cltd   
  81184a:	c1 ea 1b             	shr    $0x1b,%edx
  81184d:	01 d0                	add    %edx,%eax
  81184f:	83 e0 1f             	and    $0x1f,%eax
  811852:	29 d0                	sub    %edx,%eax
  811854:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  811859:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81185c:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  81185f:	83 03 01             	addl   $0x1,(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  811862:	83 c6 01             	add    $0x1,%esi
  811865:	3b 75 10             	cmp    0x10(%ebp),%esi
  811868:	75 d8                	jne    811842 <devpipe_read+0x37>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  81186a:	89 f0                	mov    %esi,%eax
  81186c:	eb 05                	jmp    811873 <devpipe_read+0x68>
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
  81186e:	b8 00 00 00 00       	mov    $0x0,%eax
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
}
  811873:	83 c4 1c             	add    $0x1c,%esp
  811876:	5b                   	pop    %ebx
  811877:	5e                   	pop    %esi
  811878:	5f                   	pop    %edi
  811879:	5d                   	pop    %ebp
  81187a:	c3                   	ret    

0081187b <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  81187b:	55                   	push   %ebp
  81187c:	89 e5                	mov    %esp,%ebp
  81187e:	56                   	push   %esi
  81187f:	53                   	push   %ebx
  811880:	83 ec 30             	sub    $0x30,%esp
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  811883:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811886:	89 04 24             	mov    %eax,(%esp)
  811889:	e8 79 ed ff ff       	call   810607 <fd_alloc>
  81188e:	89 c2                	mov    %eax,%edx
  811890:	85 d2                	test   %edx,%edx
  811892:	0f 88 4d 01 00 00    	js     8119e5 <pipe+0x16a>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811898:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  81189f:	00 
  8118a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8118a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8118a7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8118ae:	e8 62 e3 ff ff       	call   80fc15 <sys_page_alloc>
  8118b3:	89 c2                	mov    %eax,%edx
  8118b5:	85 d2                	test   %edx,%edx
  8118b7:	0f 88 28 01 00 00    	js     8119e5 <pipe+0x16a>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  8118bd:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8118c0:	89 04 24             	mov    %eax,(%esp)
  8118c3:	e8 3f ed ff ff       	call   810607 <fd_alloc>
  8118c8:	89 c3                	mov    %eax,%ebx
  8118ca:	85 c0                	test   %eax,%eax
  8118cc:	0f 88 fe 00 00 00    	js     8119d0 <pipe+0x155>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8118d2:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8118d9:	00 
  8118da:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8118dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8118e1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8118e8:	e8 28 e3 ff ff       	call   80fc15 <sys_page_alloc>
  8118ed:	89 c3                	mov    %eax,%ebx
  8118ef:	85 c0                	test   %eax,%eax
  8118f1:	0f 88 d9 00 00 00    	js     8119d0 <pipe+0x155>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  8118f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8118fa:	89 04 24             	mov    %eax,(%esp)
  8118fd:	e8 ee ec ff ff       	call   8105f0 <fd2data>
  811902:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811904:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  81190b:	00 
  81190c:	89 44 24 04          	mov    %eax,0x4(%esp)
  811910:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811917:	e8 f9 e2 ff ff       	call   80fc15 <sys_page_alloc>
  81191c:	89 c3                	mov    %eax,%ebx
  81191e:	85 c0                	test   %eax,%eax
  811920:	0f 88 97 00 00 00    	js     8119bd <pipe+0x142>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811926:	8b 45 f0             	mov    -0x10(%ebp),%eax
  811929:	89 04 24             	mov    %eax,(%esp)
  81192c:	e8 bf ec ff ff       	call   8105f0 <fd2data>
  811931:	c7 44 24 10 07 04 00 	movl   $0x407,0x10(%esp)
  811938:	00 
  811939:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81193d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811944:	00 
  811945:	89 74 24 04          	mov    %esi,0x4(%esp)
  811949:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811950:	e8 14 e3 ff ff       	call   80fc69 <sys_page_map>
  811955:	89 c3                	mov    %eax,%ebx
  811957:	85 c0                	test   %eax,%eax
  811959:	78 52                	js     8119ad <pipe+0x132>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  81195b:	8b 15 24 53 81 00    	mov    0x815324,%edx
  811961:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811964:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  811966:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811969:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  811970:	8b 15 24 53 81 00    	mov    0x815324,%edx
  811976:	8b 45 f0             	mov    -0x10(%ebp),%eax
  811979:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  81197b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81197e:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  811985:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811988:	89 04 24             	mov    %eax,(%esp)
  81198b:	e8 50 ec ff ff       	call   8105e0 <fd2num>
  811990:	8b 4d 08             	mov    0x8(%ebp),%ecx
  811993:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  811995:	8b 45 f0             	mov    -0x10(%ebp),%eax
  811998:	89 04 24             	mov    %eax,(%esp)
  81199b:	e8 40 ec ff ff       	call   8105e0 <fd2num>
  8119a0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8119a3:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  8119a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8119ab:	eb 38                	jmp    8119e5 <pipe+0x16a>

    err3:
	sys_page_unmap(0, va);
  8119ad:	89 74 24 04          	mov    %esi,0x4(%esp)
  8119b1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8119b8:	e8 ff e2 ff ff       	call   80fcbc <sys_page_unmap>
    err2:
	sys_page_unmap(0, fd1);
  8119bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8119c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8119c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8119cb:	e8 ec e2 ff ff       	call   80fcbc <sys_page_unmap>
    err1:
	sys_page_unmap(0, fd0);
  8119d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8119d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8119d7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8119de:	e8 d9 e2 ff ff       	call   80fcbc <sys_page_unmap>
  8119e3:	89 d8                	mov    %ebx,%eax
    err:
	return r;
}
  8119e5:	83 c4 30             	add    $0x30,%esp
  8119e8:	5b                   	pop    %ebx
  8119e9:	5e                   	pop    %esi
  8119ea:	5d                   	pop    %ebp
  8119eb:	c3                   	ret    

008119ec <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  8119ec:	55                   	push   %ebp
  8119ed:	89 e5                	mov    %esp,%ebp
  8119ef:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8119f2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8119f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8119f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8119fc:	89 04 24             	mov    %eax,(%esp)
  8119ff:	e8 52 ec ff ff       	call   810656 <fd_lookup>
  811a04:	89 c2                	mov    %eax,%edx
  811a06:	85 d2                	test   %edx,%edx
  811a08:	78 15                	js     811a1f <pipeisclosed+0x33>
		return r;
	p = (struct Pipe*) fd2data(fd);
  811a0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811a0d:	89 04 24             	mov    %eax,(%esp)
  811a10:	e8 db eb ff ff       	call   8105f0 <fd2data>
	return _pipeisclosed(fd, p);
  811a15:	89 c2                	mov    %eax,%edx
  811a17:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811a1a:	e8 0b fd ff ff       	call   81172a <_pipeisclosed>
}
  811a1f:	c9                   	leave  
  811a20:	c3                   	ret    
  811a21:	66 90                	xchg   %ax,%ax
  811a23:	66 90                	xchg   %ax,%ax
  811a25:	66 90                	xchg   %ax,%ax
  811a27:	66 90                	xchg   %ax,%ax
  811a29:	66 90                	xchg   %ax,%ax
  811a2b:	66 90                	xchg   %ax,%ax
  811a2d:	66 90                	xchg   %ax,%ax
  811a2f:	90                   	nop

00811a30 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  811a30:	55                   	push   %ebp
  811a31:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  811a33:	b8 00 00 00 00       	mov    $0x0,%eax
  811a38:	5d                   	pop    %ebp
  811a39:	c3                   	ret    

00811a3a <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  811a3a:	55                   	push   %ebp
  811a3b:	89 e5                	mov    %esp,%ebp
  811a3d:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<cons>");
  811a40:	c7 44 24 04 f4 4a 81 	movl   $0x814af4,0x4(%esp)
  811a47:	00 
  811a48:	8b 45 0c             	mov    0xc(%ebp),%eax
  811a4b:	89 04 24             	mov    %eax,(%esp)
  811a4e:	e8 54 dd ff ff       	call   80f7a7 <strcpy>
	return 0;
}
  811a53:	b8 00 00 00 00       	mov    $0x0,%eax
  811a58:	c9                   	leave  
  811a59:	c3                   	ret    

00811a5a <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  811a5a:	55                   	push   %ebp
  811a5b:	89 e5                	mov    %esp,%ebp
  811a5d:	57                   	push   %edi
  811a5e:	56                   	push   %esi
  811a5f:	53                   	push   %ebx
  811a60:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  811a66:	bb 00 00 00 00       	mov    $0x0,%ebx
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  811a6b:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  811a71:	eb 31                	jmp    811aa4 <devcons_write+0x4a>
		m = n - tot;
  811a73:	8b 75 10             	mov    0x10(%ebp),%esi
  811a76:	29 de                	sub    %ebx,%esi
		if (m > sizeof(buf) - 1)
  811a78:	83 fe 7f             	cmp    $0x7f,%esi
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  811a7b:	ba 7f 00 00 00       	mov    $0x7f,%edx
  811a80:	0f 47 f2             	cmova  %edx,%esi
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  811a83:	89 74 24 08          	mov    %esi,0x8(%esp)
  811a87:	03 45 0c             	add    0xc(%ebp),%eax
  811a8a:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a8e:	89 3c 24             	mov    %edi,(%esp)
  811a91:	e8 ae de ff ff       	call   80f944 <memmove>
		sys_cputs(buf, m);
  811a96:	89 74 24 04          	mov    %esi,0x4(%esp)
  811a9a:	89 3c 24             	mov    %edi,(%esp)
  811a9d:	e8 54 e0 ff ff       	call   80faf6 <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  811aa2:	01 f3                	add    %esi,%ebx
  811aa4:	89 d8                	mov    %ebx,%eax
  811aa6:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  811aa9:	72 c8                	jb     811a73 <devcons_write+0x19>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  811aab:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  811ab1:	5b                   	pop    %ebx
  811ab2:	5e                   	pop    %esi
  811ab3:	5f                   	pop    %edi
  811ab4:	5d                   	pop    %ebp
  811ab5:	c3                   	ret    

00811ab6 <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  811ab6:	55                   	push   %ebp
  811ab7:	89 e5                	mov    %esp,%ebp
  811ab9:	83 ec 08             	sub    $0x8,%esp
	int c;

	if (n == 0)
		return 0;
  811abc:	b8 00 00 00 00       	mov    $0x0,%eax
static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
	int c;

	if (n == 0)
  811ac1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  811ac5:	75 07                	jne    811ace <devcons_read+0x18>
  811ac7:	eb 2a                	jmp    811af3 <devcons_read+0x3d>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  811ac9:	e8 28 e1 ff ff       	call   80fbf6 <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  811ace:	66 90                	xchg   %ax,%ax
  811ad0:	e8 3f e0 ff ff       	call   80fb14 <sys_cgetc>
  811ad5:	85 c0                	test   %eax,%eax
  811ad7:	74 f0                	je     811ac9 <devcons_read+0x13>
		sys_yield();
	if (c < 0)
  811ad9:	85 c0                	test   %eax,%eax
  811adb:	78 16                	js     811af3 <devcons_read+0x3d>
		return c;
	if (c == 0x04)	// ctl-d is eof
  811add:	83 f8 04             	cmp    $0x4,%eax
  811ae0:	74 0c                	je     811aee <devcons_read+0x38>
		return 0;
	*(char*)vbuf = c;
  811ae2:	8b 55 0c             	mov    0xc(%ebp),%edx
  811ae5:	88 02                	mov    %al,(%edx)
	return 1;
  811ae7:	b8 01 00 00 00       	mov    $0x1,%eax
  811aec:	eb 05                	jmp    811af3 <devcons_read+0x3d>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  811aee:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  811af3:	c9                   	leave  
  811af4:	c3                   	ret    

00811af5 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  811af5:	55                   	push   %ebp
  811af6:	89 e5                	mov    %esp,%ebp
  811af8:	83 ec 28             	sub    $0x28,%esp
	char c = ch;
  811afb:	8b 45 08             	mov    0x8(%ebp),%eax
  811afe:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  811b01:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  811b08:	00 
  811b09:	8d 45 f7             	lea    -0x9(%ebp),%eax
  811b0c:	89 04 24             	mov    %eax,(%esp)
  811b0f:	e8 e2 df ff ff       	call   80faf6 <sys_cputs>
}
  811b14:	c9                   	leave  
  811b15:	c3                   	ret    

00811b16 <getchar>:

int
getchar(void)
{
  811b16:	55                   	push   %ebp
  811b17:	89 e5                	mov    %esp,%ebp
  811b19:	83 ec 28             	sub    $0x28,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  811b1c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  811b23:	00 
  811b24:	8d 45 f7             	lea    -0x9(%ebp),%eax
  811b27:	89 44 24 04          	mov    %eax,0x4(%esp)
  811b2b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811b32:	e8 b3 ed ff ff       	call   8108ea <read>
	if (r < 0)
  811b37:	85 c0                	test   %eax,%eax
  811b39:	78 0f                	js     811b4a <getchar+0x34>
		return r;
	if (r < 1)
  811b3b:	85 c0                	test   %eax,%eax
  811b3d:	7e 06                	jle    811b45 <getchar+0x2f>
		return -E_EOF;
	return c;
  811b3f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  811b43:	eb 05                	jmp    811b4a <getchar+0x34>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  811b45:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  811b4a:	c9                   	leave  
  811b4b:	c3                   	ret    

00811b4c <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  811b4c:	55                   	push   %ebp
  811b4d:	89 e5                	mov    %esp,%ebp
  811b4f:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  811b52:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811b55:	89 44 24 04          	mov    %eax,0x4(%esp)
  811b59:	8b 45 08             	mov    0x8(%ebp),%eax
  811b5c:	89 04 24             	mov    %eax,(%esp)
  811b5f:	e8 f2 ea ff ff       	call   810656 <fd_lookup>
  811b64:	85 c0                	test   %eax,%eax
  811b66:	78 11                	js     811b79 <iscons+0x2d>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  811b68:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811b6b:	8b 15 40 53 81 00    	mov    0x815340,%edx
  811b71:	39 10                	cmp    %edx,(%eax)
  811b73:	0f 94 c0             	sete   %al
  811b76:	0f b6 c0             	movzbl %al,%eax
}
  811b79:	c9                   	leave  
  811b7a:	c3                   	ret    

00811b7b <opencons>:

int
opencons(void)
{
  811b7b:	55                   	push   %ebp
  811b7c:	89 e5                	mov    %esp,%ebp
  811b7e:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  811b81:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811b84:	89 04 24             	mov    %eax,(%esp)
  811b87:	e8 7b ea ff ff       	call   810607 <fd_alloc>
		return r;
  811b8c:	89 c2                	mov    %eax,%edx
opencons(void)
{
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  811b8e:	85 c0                	test   %eax,%eax
  811b90:	78 40                	js     811bd2 <opencons+0x57>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  811b92:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  811b99:	00 
  811b9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811b9d:	89 44 24 04          	mov    %eax,0x4(%esp)
  811ba1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811ba8:	e8 68 e0 ff ff       	call   80fc15 <sys_page_alloc>
		return r;
  811bad:	89 c2                	mov    %eax,%edx
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  811baf:	85 c0                	test   %eax,%eax
  811bb1:	78 1f                	js     811bd2 <opencons+0x57>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  811bb3:	8b 15 40 53 81 00    	mov    0x815340,%edx
  811bb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811bbc:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  811bbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811bc1:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  811bc8:	89 04 24             	mov    %eax,(%esp)
  811bcb:	e8 10 ea ff ff       	call   8105e0 <fd2num>
  811bd0:	89 c2                	mov    %eax,%edx
}
  811bd2:	89 d0                	mov    %edx,%eax
  811bd4:	c9                   	leave  
  811bd5:	c3                   	ret    

00811bd6 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  811bd6:	55                   	push   %ebp
  811bd7:	89 e5                	mov    %esp,%ebp
  811bd9:	83 ec 18             	sub    $0x18,%esp
	int r;

	if (_pgfault_handler == 0) {
  811bdc:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  811be3:	75 7a                	jne    811c5f <set_pgfault_handler+0x89>
		// First time through!
		// LAB 4: Your code here.

		//panic("set_pgfault_handler not implemented");
		//dont know--->>UXSTACKTOP-PGSIZE-'1'
		if ((r = sys_page_alloc(sys_getenvid(),(void *)UXSTACKTOP-PGSIZE, PTE_P|PTE_U|PTE_W)) < 0)
  811be5:	e8 ed df ff ff       	call   80fbd7 <sys_getenvid>
  811bea:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  811bf1:	00 
  811bf2:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  811bf9:	ee 
  811bfa:	89 04 24             	mov    %eax,(%esp)
  811bfd:	e8 13 e0 ff ff       	call   80fc15 <sys_page_alloc>
  811c02:	85 c0                	test   %eax,%eax
  811c04:	79 20                	jns    811c26 <set_pgfault_handler+0x50>
			panic("sys_page_alloc: %e", r);
  811c06:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811c0a:	c7 44 24 08 a9 48 81 	movl   $0x8148a9,0x8(%esp)
  811c11:	00 
  811c12:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  811c19:	00 
  811c1a:	c7 04 24 00 4b 81 00 	movl   $0x814b00,(%esp)
  811c21:	e8 14 d4 ff ff       	call   80f03a <_panic>
		if ((r = sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall)) < 0)
  811c26:	e8 ac df ff ff       	call   80fbd7 <sys_getenvid>
  811c2b:	c7 44 24 04 69 1c 81 	movl   $0x811c69,0x4(%esp)
  811c32:	00 
  811c33:	89 04 24             	mov    %eax,(%esp)
  811c36:	e8 9a e1 ff ff       	call   80fdd5 <sys_env_set_pgfault_upcall>
  811c3b:	85 c0                	test   %eax,%eax
  811c3d:	79 20                	jns    811c5f <set_pgfault_handler+0x89>
			panic("pagefault upcall setup error: %e", r);
  811c3f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811c43:	c7 44 24 08 28 49 81 	movl   $0x814928,0x8(%esp)
  811c4a:	00 
  811c4b:	c7 44 24 04 26 00 00 	movl   $0x26,0x4(%esp)
  811c52:	00 
  811c53:	c7 04 24 00 4b 81 00 	movl   $0x814b00,(%esp)
  811c5a:	e8 db d3 ff ff       	call   80f03a <_panic>

	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  811c5f:	8b 45 08             	mov    0x8(%ebp),%eax
  811c62:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
}
  811c67:	c9                   	leave  
  811c68:	c3                   	ret    

00811c69 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  811c69:	54                   	push   %esp
	movl _pgfault_handler, %eax
  811c6a:	a1 00 f0 b3 00       	mov    0xb3f000,%eax
	call *%eax
  811c6f:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  811c71:	83 c4 04             	add    $0x4,%esp
	// LAB 4: Your code here.
 	// need to check whether the pagefault is recursive pagefault or just the 1st page fault
 	//if recursive an reserve word UXSTACKTOP is pushed on uxstacktop. So compare it if match then it is  

 	
	movl 48(%esp), %eax    //has the old esp
  811c74:	8b 44 24 30          	mov    0x30(%esp),%eax
	movl 40(%esp), %ebx    //has the old eip
  811c78:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	subl $4, %eax
  811c7c:	83 e8 04             	sub    $0x4,%eax
	//we cannot do addl operations once registers and eflags are popped. 
	//So making 48(%esp) to point to (oldesp-4) which currently eax have. So we just need to pop esp at right time.
	movl %eax, 48(%esp)
  811c7f:	89 44 24 30          	mov    %eax,0x30(%esp)

	movl %ebx, (%eax)
  811c83:	89 18                	mov    %ebx,(%eax)
	// remember to decrement tf_esp when changing stack while returning
	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.

	addl $8, %esp   //skip error and faultva
  811c85:	83 c4 08             	add    $0x8,%esp
	popal
  811c88:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.

	addl $4, %esp
  811c89:	83 c4 04             	add    $0x4,%esp
	popfl
  811c8c:	9d                   	popf   

	
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp
  811c8d:	5c                   	pop    %esp


	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  811c8e:	c3                   	ret    

00811c8f <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  811c8f:	55                   	push   %ebp
  811c90:	89 e5                	mov    %esp,%ebp
  811c92:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  811c95:	89 d0                	mov    %edx,%eax
  811c97:	c1 e8 16             	shr    $0x16,%eax
  811c9a:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  811ca1:	b8 00 00 00 00       	mov    $0x0,%eax
int
pageref(void *v)
{
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  811ca6:	f6 c1 01             	test   $0x1,%cl
  811ca9:	74 1d                	je     811cc8 <pageref+0x39>
		return 0;
	pte = uvpt[PGNUM(v)];
  811cab:	c1 ea 0c             	shr    $0xc,%edx
  811cae:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  811cb5:	f6 c2 01             	test   $0x1,%dl
  811cb8:	74 0e                	je     811cc8 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  811cba:	c1 ea 0c             	shr    $0xc,%edx
  811cbd:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  811cc4:	ef 
  811cc5:	0f b7 c0             	movzwl %ax,%eax
}
  811cc8:	5d                   	pop    %ebp
  811cc9:	c3                   	ret    
  811cca:	66 90                	xchg   %ax,%ax
  811ccc:	66 90                	xchg   %ax,%ax
  811cce:	66 90                	xchg   %ax,%ax

00811cd0 <__udivdi3>:
  811cd0:	55                   	push   %ebp
  811cd1:	57                   	push   %edi
  811cd2:	56                   	push   %esi
  811cd3:	83 ec 0c             	sub    $0xc,%esp
  811cd6:	8b 44 24 28          	mov    0x28(%esp),%eax
  811cda:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  811cde:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  811ce2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  811ce6:	85 c0                	test   %eax,%eax
  811ce8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811cec:	89 ea                	mov    %ebp,%edx
  811cee:	89 0c 24             	mov    %ecx,(%esp)
  811cf1:	75 2d                	jne    811d20 <__udivdi3+0x50>
  811cf3:	39 e9                	cmp    %ebp,%ecx
  811cf5:	77 61                	ja     811d58 <__udivdi3+0x88>
  811cf7:	85 c9                	test   %ecx,%ecx
  811cf9:	89 ce                	mov    %ecx,%esi
  811cfb:	75 0b                	jne    811d08 <__udivdi3+0x38>
  811cfd:	b8 01 00 00 00       	mov    $0x1,%eax
  811d02:	31 d2                	xor    %edx,%edx
  811d04:	f7 f1                	div    %ecx
  811d06:	89 c6                	mov    %eax,%esi
  811d08:	31 d2                	xor    %edx,%edx
  811d0a:	89 e8                	mov    %ebp,%eax
  811d0c:	f7 f6                	div    %esi
  811d0e:	89 c5                	mov    %eax,%ebp
  811d10:	89 f8                	mov    %edi,%eax
  811d12:	f7 f6                	div    %esi
  811d14:	89 ea                	mov    %ebp,%edx
  811d16:	83 c4 0c             	add    $0xc,%esp
  811d19:	5e                   	pop    %esi
  811d1a:	5f                   	pop    %edi
  811d1b:	5d                   	pop    %ebp
  811d1c:	c3                   	ret    
  811d1d:	8d 76 00             	lea    0x0(%esi),%esi
  811d20:	39 e8                	cmp    %ebp,%eax
  811d22:	77 24                	ja     811d48 <__udivdi3+0x78>
  811d24:	0f bd e8             	bsr    %eax,%ebp
  811d27:	83 f5 1f             	xor    $0x1f,%ebp
  811d2a:	75 3c                	jne    811d68 <__udivdi3+0x98>
  811d2c:	8b 74 24 04          	mov    0x4(%esp),%esi
  811d30:	39 34 24             	cmp    %esi,(%esp)
  811d33:	0f 86 9f 00 00 00    	jbe    811dd8 <__udivdi3+0x108>
  811d39:	39 d0                	cmp    %edx,%eax
  811d3b:	0f 82 97 00 00 00    	jb     811dd8 <__udivdi3+0x108>
  811d41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811d48:	31 d2                	xor    %edx,%edx
  811d4a:	31 c0                	xor    %eax,%eax
  811d4c:	83 c4 0c             	add    $0xc,%esp
  811d4f:	5e                   	pop    %esi
  811d50:	5f                   	pop    %edi
  811d51:	5d                   	pop    %ebp
  811d52:	c3                   	ret    
  811d53:	90                   	nop
  811d54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811d58:	89 f8                	mov    %edi,%eax
  811d5a:	f7 f1                	div    %ecx
  811d5c:	31 d2                	xor    %edx,%edx
  811d5e:	83 c4 0c             	add    $0xc,%esp
  811d61:	5e                   	pop    %esi
  811d62:	5f                   	pop    %edi
  811d63:	5d                   	pop    %ebp
  811d64:	c3                   	ret    
  811d65:	8d 76 00             	lea    0x0(%esi),%esi
  811d68:	89 e9                	mov    %ebp,%ecx
  811d6a:	8b 3c 24             	mov    (%esp),%edi
  811d6d:	d3 e0                	shl    %cl,%eax
  811d6f:	89 c6                	mov    %eax,%esi
  811d71:	b8 20 00 00 00       	mov    $0x20,%eax
  811d76:	29 e8                	sub    %ebp,%eax
  811d78:	89 c1                	mov    %eax,%ecx
  811d7a:	d3 ef                	shr    %cl,%edi
  811d7c:	89 e9                	mov    %ebp,%ecx
  811d7e:	89 7c 24 08          	mov    %edi,0x8(%esp)
  811d82:	8b 3c 24             	mov    (%esp),%edi
  811d85:	09 74 24 08          	or     %esi,0x8(%esp)
  811d89:	89 d6                	mov    %edx,%esi
  811d8b:	d3 e7                	shl    %cl,%edi
  811d8d:	89 c1                	mov    %eax,%ecx
  811d8f:	89 3c 24             	mov    %edi,(%esp)
  811d92:	8b 7c 24 04          	mov    0x4(%esp),%edi
  811d96:	d3 ee                	shr    %cl,%esi
  811d98:	89 e9                	mov    %ebp,%ecx
  811d9a:	d3 e2                	shl    %cl,%edx
  811d9c:	89 c1                	mov    %eax,%ecx
  811d9e:	d3 ef                	shr    %cl,%edi
  811da0:	09 d7                	or     %edx,%edi
  811da2:	89 f2                	mov    %esi,%edx
  811da4:	89 f8                	mov    %edi,%eax
  811da6:	f7 74 24 08          	divl   0x8(%esp)
  811daa:	89 d6                	mov    %edx,%esi
  811dac:	89 c7                	mov    %eax,%edi
  811dae:	f7 24 24             	mull   (%esp)
  811db1:	39 d6                	cmp    %edx,%esi
  811db3:	89 14 24             	mov    %edx,(%esp)
  811db6:	72 30                	jb     811de8 <__udivdi3+0x118>
  811db8:	8b 54 24 04          	mov    0x4(%esp),%edx
  811dbc:	89 e9                	mov    %ebp,%ecx
  811dbe:	d3 e2                	shl    %cl,%edx
  811dc0:	39 c2                	cmp    %eax,%edx
  811dc2:	73 05                	jae    811dc9 <__udivdi3+0xf9>
  811dc4:	3b 34 24             	cmp    (%esp),%esi
  811dc7:	74 1f                	je     811de8 <__udivdi3+0x118>
  811dc9:	89 f8                	mov    %edi,%eax
  811dcb:	31 d2                	xor    %edx,%edx
  811dcd:	e9 7a ff ff ff       	jmp    811d4c <__udivdi3+0x7c>
  811dd2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811dd8:	31 d2                	xor    %edx,%edx
  811dda:	b8 01 00 00 00       	mov    $0x1,%eax
  811ddf:	e9 68 ff ff ff       	jmp    811d4c <__udivdi3+0x7c>
  811de4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811de8:	8d 47 ff             	lea    -0x1(%edi),%eax
  811deb:	31 d2                	xor    %edx,%edx
  811ded:	83 c4 0c             	add    $0xc,%esp
  811df0:	5e                   	pop    %esi
  811df1:	5f                   	pop    %edi
  811df2:	5d                   	pop    %ebp
  811df3:	c3                   	ret    
  811df4:	66 90                	xchg   %ax,%ax
  811df6:	66 90                	xchg   %ax,%ax
  811df8:	66 90                	xchg   %ax,%ax
  811dfa:	66 90                	xchg   %ax,%ax
  811dfc:	66 90                	xchg   %ax,%ax
  811dfe:	66 90                	xchg   %ax,%ax

00811e00 <__umoddi3>:
  811e00:	55                   	push   %ebp
  811e01:	57                   	push   %edi
  811e02:	56                   	push   %esi
  811e03:	83 ec 14             	sub    $0x14,%esp
  811e06:	8b 44 24 28          	mov    0x28(%esp),%eax
  811e0a:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  811e0e:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  811e12:	89 c7                	mov    %eax,%edi
  811e14:	89 44 24 04          	mov    %eax,0x4(%esp)
  811e18:	8b 44 24 30          	mov    0x30(%esp),%eax
  811e1c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  811e20:	89 34 24             	mov    %esi,(%esp)
  811e23:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811e27:	85 c0                	test   %eax,%eax
  811e29:	89 c2                	mov    %eax,%edx
  811e2b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811e2f:	75 17                	jne    811e48 <__umoddi3+0x48>
  811e31:	39 fe                	cmp    %edi,%esi
  811e33:	76 4b                	jbe    811e80 <__umoddi3+0x80>
  811e35:	89 c8                	mov    %ecx,%eax
  811e37:	89 fa                	mov    %edi,%edx
  811e39:	f7 f6                	div    %esi
  811e3b:	89 d0                	mov    %edx,%eax
  811e3d:	31 d2                	xor    %edx,%edx
  811e3f:	83 c4 14             	add    $0x14,%esp
  811e42:	5e                   	pop    %esi
  811e43:	5f                   	pop    %edi
  811e44:	5d                   	pop    %ebp
  811e45:	c3                   	ret    
  811e46:	66 90                	xchg   %ax,%ax
  811e48:	39 f8                	cmp    %edi,%eax
  811e4a:	77 54                	ja     811ea0 <__umoddi3+0xa0>
  811e4c:	0f bd e8             	bsr    %eax,%ebp
  811e4f:	83 f5 1f             	xor    $0x1f,%ebp
  811e52:	75 5c                	jne    811eb0 <__umoddi3+0xb0>
  811e54:	8b 7c 24 08          	mov    0x8(%esp),%edi
  811e58:	39 3c 24             	cmp    %edi,(%esp)
  811e5b:	0f 87 e7 00 00 00    	ja     811f48 <__umoddi3+0x148>
  811e61:	8b 7c 24 04          	mov    0x4(%esp),%edi
  811e65:	29 f1                	sub    %esi,%ecx
  811e67:	19 c7                	sbb    %eax,%edi
  811e69:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811e6d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811e71:	8b 44 24 08          	mov    0x8(%esp),%eax
  811e75:	8b 54 24 0c          	mov    0xc(%esp),%edx
  811e79:	83 c4 14             	add    $0x14,%esp
  811e7c:	5e                   	pop    %esi
  811e7d:	5f                   	pop    %edi
  811e7e:	5d                   	pop    %ebp
  811e7f:	c3                   	ret    
  811e80:	85 f6                	test   %esi,%esi
  811e82:	89 f5                	mov    %esi,%ebp
  811e84:	75 0b                	jne    811e91 <__umoddi3+0x91>
  811e86:	b8 01 00 00 00       	mov    $0x1,%eax
  811e8b:	31 d2                	xor    %edx,%edx
  811e8d:	f7 f6                	div    %esi
  811e8f:	89 c5                	mov    %eax,%ebp
  811e91:	8b 44 24 04          	mov    0x4(%esp),%eax
  811e95:	31 d2                	xor    %edx,%edx
  811e97:	f7 f5                	div    %ebp
  811e99:	89 c8                	mov    %ecx,%eax
  811e9b:	f7 f5                	div    %ebp
  811e9d:	eb 9c                	jmp    811e3b <__umoddi3+0x3b>
  811e9f:	90                   	nop
  811ea0:	89 c8                	mov    %ecx,%eax
  811ea2:	89 fa                	mov    %edi,%edx
  811ea4:	83 c4 14             	add    $0x14,%esp
  811ea7:	5e                   	pop    %esi
  811ea8:	5f                   	pop    %edi
  811ea9:	5d                   	pop    %ebp
  811eaa:	c3                   	ret    
  811eab:	90                   	nop
  811eac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811eb0:	8b 04 24             	mov    (%esp),%eax
  811eb3:	be 20 00 00 00       	mov    $0x20,%esi
  811eb8:	89 e9                	mov    %ebp,%ecx
  811eba:	29 ee                	sub    %ebp,%esi
  811ebc:	d3 e2                	shl    %cl,%edx
  811ebe:	89 f1                	mov    %esi,%ecx
  811ec0:	d3 e8                	shr    %cl,%eax
  811ec2:	89 e9                	mov    %ebp,%ecx
  811ec4:	89 44 24 04          	mov    %eax,0x4(%esp)
  811ec8:	8b 04 24             	mov    (%esp),%eax
  811ecb:	09 54 24 04          	or     %edx,0x4(%esp)
  811ecf:	89 fa                	mov    %edi,%edx
  811ed1:	d3 e0                	shl    %cl,%eax
  811ed3:	89 f1                	mov    %esi,%ecx
  811ed5:	89 44 24 08          	mov    %eax,0x8(%esp)
  811ed9:	8b 44 24 10          	mov    0x10(%esp),%eax
  811edd:	d3 ea                	shr    %cl,%edx
  811edf:	89 e9                	mov    %ebp,%ecx
  811ee1:	d3 e7                	shl    %cl,%edi
  811ee3:	89 f1                	mov    %esi,%ecx
  811ee5:	d3 e8                	shr    %cl,%eax
  811ee7:	89 e9                	mov    %ebp,%ecx
  811ee9:	09 f8                	or     %edi,%eax
  811eeb:	8b 7c 24 10          	mov    0x10(%esp),%edi
  811eef:	f7 74 24 04          	divl   0x4(%esp)
  811ef3:	d3 e7                	shl    %cl,%edi
  811ef5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811ef9:	89 d7                	mov    %edx,%edi
  811efb:	f7 64 24 08          	mull   0x8(%esp)
  811eff:	39 d7                	cmp    %edx,%edi
  811f01:	89 c1                	mov    %eax,%ecx
  811f03:	89 14 24             	mov    %edx,(%esp)
  811f06:	72 2c                	jb     811f34 <__umoddi3+0x134>
  811f08:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  811f0c:	72 22                	jb     811f30 <__umoddi3+0x130>
  811f0e:	8b 44 24 0c          	mov    0xc(%esp),%eax
  811f12:	29 c8                	sub    %ecx,%eax
  811f14:	19 d7                	sbb    %edx,%edi
  811f16:	89 e9                	mov    %ebp,%ecx
  811f18:	89 fa                	mov    %edi,%edx
  811f1a:	d3 e8                	shr    %cl,%eax
  811f1c:	89 f1                	mov    %esi,%ecx
  811f1e:	d3 e2                	shl    %cl,%edx
  811f20:	89 e9                	mov    %ebp,%ecx
  811f22:	d3 ef                	shr    %cl,%edi
  811f24:	09 d0                	or     %edx,%eax
  811f26:	89 fa                	mov    %edi,%edx
  811f28:	83 c4 14             	add    $0x14,%esp
  811f2b:	5e                   	pop    %esi
  811f2c:	5f                   	pop    %edi
  811f2d:	5d                   	pop    %ebp
  811f2e:	c3                   	ret    
  811f2f:	90                   	nop
  811f30:	39 d7                	cmp    %edx,%edi
  811f32:	75 da                	jne    811f0e <__umoddi3+0x10e>
  811f34:	8b 14 24             	mov    (%esp),%edx
  811f37:	89 c1                	mov    %eax,%ecx
  811f39:	2b 4c 24 08          	sub    0x8(%esp),%ecx
  811f3d:	1b 54 24 04          	sbb    0x4(%esp),%edx
  811f41:	eb cb                	jmp    811f0e <__umoddi3+0x10e>
  811f43:	90                   	nop
  811f44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811f48:	3b 44 24 0c          	cmp    0xc(%esp),%eax
  811f4c:	0f 82 0f ff ff ff    	jb     811e61 <__umoddi3+0x61>
  811f52:	e9 1a ff ff ff       	jmp    811e71 <__umoddi3+0x71>
